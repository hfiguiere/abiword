./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-286-	
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-287-	const gchar* szMsg = (gchar *) gtk_object_get_data(GTK_OBJECT(widget),
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-288-													   "abi_statusbar_text");
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-289-	
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-290-	if (!szMsg || !*szMsg)
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp:291:		szMsg = "TODO This menu item doesn't have a StatusMessage defined.";
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-292-	
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-293-	pFrame->setStatusMessage(szMsg);
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-294-};
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-295-
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-296-/**
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-394-/**
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-395- * This function does the "hard" work.  It converts the "AbiSource menu" into
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-396- * a GnomeUIInfo structure (the "gnome format" to code the menus).  The function
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-397- * starts the conversion in the @pos "item" (an item can be a menu item,
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-398- * a submenu, etc...) of the menu.  Due to the recursive nature of this function,
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp:399: * the pos variable is passed by reference... <-- TODO: Explain that...
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-400- */
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-401-GnomeUIInfo * EV_UnixGnomeMenu::_convertMenu2UIInfo (int &pos)
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-402-{
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-403-	const EV_Menu_ActionSet * pMenuActionSet = m_pUnixApp->getMenuActionSet();
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-404-	int nItems = (int) m_pMenuLayout->getLayoutItemCount();
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-571-
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-572-		switch (pLayoutItem->getMenuLayoutFlags())
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-573-		{
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-574-		case EV_MLF_Normal:
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-575-		{
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp:576:			// TODO: Dynamic labels and widgets
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-577-			// see if we need to enable/disable and/or check/uncheck it.
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-578-			UT_Bool bEnable = UT_TRUE;
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-579-			UT_Bool bCheck = UT_FALSE;
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-580-			
./af/ev/unix/gnome/ev_UnixGnomeMenu.cpp-581-			if (pAction->hasGetStateFunction())
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-155-	      }
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-156-	    else // widget has no ->parent, so use the buffer's results
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-157-	      {
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-158-		UT_uint32 size = strlen(wd->m_comboEntryBuffer);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-159-		
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:160:		// TODO : do a real conversion to UT_UCSChar or figure out the casting
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-161-		
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-162-		// don't do changes for empty combo texts
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-163-		if (UT_strcmp(wd->m_comboEntryBuffer, ""))
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-164-		  {
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-165-		    UT_UCSChar * text = (UT_UCSChar *) wd->m_comboEntryBuffer;
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-455-			    break;
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-456-			  }
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-457-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-458-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-459-			case EV_TBIT_StaticLabel:
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:460:				// TODO do these...
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-461-				break;
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-462-					
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-463-			case EV_TBIT_Spacer:
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-464-				break;
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-465-					
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-564-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-565-	gtk_toolbar_set_button_relief(GTK_TOOLBAR (toolbar), GTK_RELIEF_NONE);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-566-	gtk_toolbar_set_tooltips(GTK_TOOLBAR (toolbar), TRUE);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-567-	gtk_toolbar_set_space_style(GTK_TOOLBAR (toolbar), GTK_TOOLBAR_SPACE_LINE);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-568-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:569:	// TODO: this really shouldn't be determined by us
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-570-	gtk_toolbar_set_space_size(GTK_TOOLBAR (toolbar), 10);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-571-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-572-	return toolbar;
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-573-}
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-574-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-585-	    gtk_widget_hide(m_wToolbar->parent);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-586-	    gtk_widget_queue_resize (m_wToolbar->parent->parent);
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-587-	  }
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-588-}
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-589-
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:590:// TODO: Dom, we copy *far* too much code from the GTK version here
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:591:// TODO: Dom, when all we change is the combo-text case
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp:592:// TODO: Dom, change that
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-593-UT_Bool EV_UnixGnomeToolbar::refreshToolbar(AV_View * pView, AV_ChangeMask mask)
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-594-{
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-595-	// make the toolbar reflect the current state of the document
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-596-	// at the current insertion point or selection.
./af/ev/unix/gnome/ev_UnixGnomeToolbar.cpp-597-	
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-129-			p[len-1] = 0;
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-130-		XAP_App::_setAbiSuiteLibDir(p);
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-131-		return;
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-132-	}
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-133-
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp:134:	// TODO what to do ??  try the current directory...
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-135-	
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-136-	UT_DEBUGMSG(("ABISUITE_HOME not set and -lib not given.  Assuming current directory....\n"));
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-137-
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-138-	getcwd(buf,sizeof(buf));
./af/xap/unix/gnome/xap_UnixGnomeApp.cpp-139-	int len = strlen(buf);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-95-	gtk_object_set_data (GTK_OBJECT (m_windowMain), 
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-96-						 "areaCurrentSym", m_areaCurrentSym);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-97-	gtk_box_pack_start(GTK_BOX(hbox), m_areaCurrentSym, TRUE, FALSE, 0);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-98-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-99-	// Now the Symbol Map. 
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp:100:	// TODO: 32 * x (19) = 608, 7 * y (21) = 147  FIXME!
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-101-	m_SymbolMap = _previewNew (608, 147);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-102-	gtk_object_set_data (GTK_OBJECT (m_windowMain), "SymbolMap", m_SymbolMap);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-103-	gtk_box_pack_start(GTK_BOX(vbox), m_SymbolMap, FALSE, FALSE, 0);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-104-	
./af/xap/unix/gnome/xap_UnixGnomeDlg_Insert_Symbol.cpp-105-	UT_XML_cloneNoAmpersands(tmp, pSS->getValue(XAP_STRING_ID_DLG_Insert));
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-123-	UT_ASSERT(parent);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-124-	gnome_dialog_set_parent(GNOME_DIALOG(gpd), GTK_WINDOW(parent));
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-125-	//centerDialog(parent, GTK_WIDGET(gpd));
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-126-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-127-	// 2.  Toggle dialog options to match persistent values
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp:128:	// TODO: We're not really persistant. I view this as a good thing, others don't.
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-129-	// Gnome Print really doesn't do persistance too well (limited accessor
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-130-	// functions), so we have to give something up in order to get the pretty
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-131-	// dialog (for now)
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-132-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-133-	UT_Bool preview = UT_FALSE;
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-217-void XAP_UnixGnomeDialog_Print::runModal(XAP_Frame * pFrame) 
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-218-{
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-219-       m_pUnixFrame = static_cast<XAP_UnixFrame *>(pFrame);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-220-       UT_ASSERT(m_pUnixFrame);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-221-       
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp:222:       // TODO: persistance
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-223-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-224-       _raisePrintDialog(pFrame);              
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-225-       if (m_answer == a_OK)
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-226-         _getGraphics();
./af/xap/unix/gnome/xap_UnixGnomeDlg_Print.cpp-227-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-310-	FREEP(tmp);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-311-	gtk_object_set_data (GTK_OBJECT (windowZoom), "framePreview", framePreview);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-312-	gtk_widget_show (framePreview);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-313-	gtk_box_pack_start (GTK_BOX (hboxFrames), framePreview, TRUE, TRUE, 0);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-314-
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp:315:	// TODO: do something dynamically here?  How do we set this "sample" font?
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-316-	frameSampleText = gtk_frame_new ("10 pt Times New Roman");
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-317-	gtk_object_set_data (GTK_OBJECT (windowZoom), "frameSampleText", frameSampleText);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-318-	gtk_widget_show (frameSampleText);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-319-	gtk_container_add (GTK_CONTAINER (framePreview), frameSampleText);
./af/xap/unix/gnome/xap_UnixGnomeDlg_Zoom.cpp-320-	gtk_widget_set_usize (frameSampleText, 221, 97);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-76-			filename = (char *) names->data;
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-77-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-78-			UT_Error error = pNewUnixFrame->loadDocument(filename, 0 /* IEFT_Unknown */);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-79-			if (error)
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-80-			{
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:81:				// TODO: warn user that we couldn't open that file
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-82-				
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-83-#if 1
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:84:				// TODO we crash if we just delete this without putting something
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:85:				// TODO in it, so let's go ahead and open an untitled document
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:86:				// TODO for now.
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-87-				pNewUnixFrame->loadDocument(NULL, 0 /* IEFT_Unknown */);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-88-#else
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-89-				delete pNewUnixFrame;
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-90-#endif
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-91-			}
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-94-		gnome_uri_list_free_strings (names);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-95-		break;
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-96-	}
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-97-	case TARGET_URL:
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-98-	{
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:99:		// TODO
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-100-#if 0
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-101-		XAP_Frame * pNewUnixFrame = pApp->newFrame();
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-102-		filename = (char *) selection_data->data;
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-103-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-104-		UT_Error error = pNewUnixFrame->loadDocument(filename, 0 /* IEFT_Unknown */)
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-195-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-196-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-197-	UT_ASSERT(m_pUnixMenu);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-198-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-199-	// create a toolbar instance for each toolbar listed in our base class.
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:200:	// TODO for some reason, the toolbar functions require the TLW to be
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp:201:	// TODO realized (they reference m_wTopLevelWindow->window) before we call them.
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-202-	gtk_widget_realize(m_wTopLevelWindow);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-203-
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-204-	gtk_signal_connect(GTK_OBJECT(m_wTopLevelWindow), "key_press_event",
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-205-					   GTK_SIGNAL_FUNC(_fe::key_press_event), NULL);
./af/xap/unix/gnome/xap_UnixGnomeFrame.cpp-206-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-255-{
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-256-        m_pApp         = pApp;
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-257-	m_gpm          = gpm;
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-258-	m_gpc          = gnome_print_master_get_context(gpm);
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-259-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp:260:	// TODO: be more robust about this
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-261-	const GnomePaper * paper = gnome_paper_with_name(mapPageSize (pageSize));
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-262-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-263-	UT_DEBUGMSG(("DOM: mapping '%s' returned '%s'\n", pageSize, mapPageSize (pageSize)));
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-264-	if (!paper)
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-265-			paper = gnome_paper_with_name (gnome_paper_name_default ());
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-354-void XAP_UnixGnomePrintGraphics::setFont(GR_Font* pFont)
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-355-{
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-356-	UT_ASSERT(pFont);
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-357-	PSFont * psFont = (static_cast<PSFont*> (pFont));
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-358-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp:359:	// TODO: We *must* be smarter about this, maybe a hash
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp:360:	// TODO: of PSFonts -> GnomeFonts
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-361-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-362-	if(m_pCurrentFont && GNOME_IS_FONT(m_pCurrentFont))
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-363-			gnome_font_unref(m_pCurrentFont);
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-364-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-365-	m_pCurrentFont = _allocGnomeFont(psFont);
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-498-	gnome_print_scale(m_gpc,
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-499-			  ((double) iDestWidth)  * _scale_factor_get (),
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-500-			  ((double) iDestHeight) * _scale_factor_get ());
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-501-				 
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-502-	/* 
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp:503:	 * TODO: one day support the alpha channel internally and then call
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-504-	 * gnome_print_rgbaimage()
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-505-	 */
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-506-	if (rgb)
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-507-		gnome_print_rgbimage(m_gpc, (const gchar*)image->data, image->width, 
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-508-				     image->height, (UT_sint32) (image->width) * 3);
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-598-	else
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-599-	  {
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-600-	    GnomePrintMasterPreview *preview;
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-601-	    const XAP_StringSet * pSS = m_pApp->getStringSet();
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-602-
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp:603:	    // TODO: translate me
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-604-	    preview = gnome_print_master_preview_new(m_gpm, pSS->getValue(XAP_STRING_ID_DLG_UP_PrintPreviewTitle));
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-605-	    gtk_widget_show(GTK_WIDGET(preview));
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-606-	  }
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-607-	
./af/xap/unix/gnome/xap_UnixGnomePrintGraphics.cpp-608-	gtk_object_unref(GTK_OBJECT(m_gpm));
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-157- 			}
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-158-
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-159-	// HACK : these calls to gtk reside properly in XAP_UnixApp::initialize(),
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-160-	// HACK : but need to be here to throw the splash screen as
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-161-	// HACK : soon as possible.
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:162:	// TODO : I've to change that to gnome_init call.
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-163-	gtk_set_locale();
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-164-	//	gnome_init(m_szAppName, "0.0", Args.m_argc, Args.m_argv);
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-165-	gtk_init(&Args.m_argc,&Args.m_argv);
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-166-
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-167-#ifdef HAVE_GNOMEVFS
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-201-UT_Bool AP_UnixGnomeApp::parseCommandLine(void)
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-202-{
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-203-	// parse the command line
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-204-	// <app> [--script <scriptname>]* [--dumpstrings] [--to <format>] [--geometry <format>] [<documentname>]*
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-205-	
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:206:	// TODO when we refactor the App classes, consider moving
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:207:	// TODO this to app-specific, cross-platform.
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-208-	
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-209-	int kWindowsOpened = 0;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-210-#ifdef ABI_OPT_JS
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-211- 	char *script = NULL;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-212-#endif
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-260-
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-261-	if (geometry)
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-262-	{
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-263-		// [--geometry <X geometry string>]
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-264-
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:265:		// TODO : does X have a dummy geometry value reserved for this?
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-266-		gint dummy = 1 << ((sizeof(gint) * 8) - 1);
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-267-		gint x = dummy;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-268-		gint y = dummy;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-269-		guint width = 0;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-270-		guint height = 0;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-311-		{
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-312-			kWindowsOpened++;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-313-		}
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-314-		else
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-315-		{
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:316:			// TODO: warn user that we couldn't open that file
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-317-			
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-318-#if 1
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:319:			// TODO we crash if we just delete this without putting something
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:320:			// TODO in it, so let's go ahead and open an untitled document
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:321:			// TODO for now.  this would cause us to get 2 untitled documents
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp:322:			// TODO if the user gave us 2 bogus pathnames....
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-323-			kWindowsOpened++;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-324-			pFirstUnixFrame->loadDocument(NULL, IEFT_Unknown);
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-325-#else
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-326-			delete pFirstUnixFrame;
./wp/ap/unix/gnome/ap_UnixGnomeApp.cpp-327-#endif
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-60-	m_wMainWindow = gnome_dialog_new (m_WindowName, NULL);
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-61-
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-62-	gtk_box_pack_start (GTK_BOX (GNOME_DIALOG (m_wMainWindow)->vbox),
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-63-						_constructWindowContents (), TRUE, TRUE, 0);
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-64-
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp:65:	// TODO: This call must be in _constructWindowContents
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-66-	gtk_window_add_accel_group (GTK_WINDOW (m_wMainWindow), m_accelGroup);
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-67-	
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-68-	// container for buttons
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-69-	gnome_dialog_append_button (GNOME_DIALOG (m_wMainWindow), GNOME_STOCK_BUTTON_PREV);
./wp/ap/unix/gnome/ap_UnixGnomeDialog_Goto.cpp-70-	m_wPrev = GTK_WIDGET (g_list_last (GNOME_DIALOG (m_wMainWindow)->buttons)->data);
