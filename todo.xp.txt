./af/ev/xp/ev_EditBinding.cpp-119-					if (m_peb[i][j])
./af/ev/xp/ev_EditBinding.cpp-120-						delete m_peb[i][j];
./af/ev/xp/ev_EditBinding.cpp-121-		}
./af/ev/xp/ev_EditBinding.cpp-122-	
./af/ev/xp/ev_EditBinding.cpp-123-
./af/ev/xp/ev_EditBinding.cpp:124:	// TODO Note[1]  we currently limit the range on regular (non-nvk)
./af/ev/xp/ev_EditBinding.cpp:125:	// TODO Note[1]  keys to 256.  This is probably OK for Latin1, but
./af/ev/xp/ev_EditBinding.cpp:126:	// TODO Note[1]  will probably need to be re-addressed later.
./af/ev/xp/ev_EditBinding.cpp-127-	
./af/ev/xp/ev_EditBinding.cpp-128-	EV_EditBinding *	m_peb[256][EV_COUNT_EMS_NoShift];
./af/ev/xp/ev_EditBinding.cpp-129-};
./af/ev/xp/ev_EditBinding.cpp-130-
./af/ev/xp/ev_EditBinding.cpp-131-/*****************************************************************/

./af/ev/xp/ev_EditBinding.cpp-216-{
./af/ev/xp/ev_EditBinding.cpp-217-	EV_EditMethod * pem = m_pemc->findEditMethodByName(szMethodName);
./af/ev/xp/ev_EditBinding.cpp-218-	if (!pem)
./af/ev/xp/ev_EditBinding.cpp-219-	{
./af/ev/xp/ev_EditBinding.cpp-220-		UT_DEBUGMSG(("Unknown method name [%s] in binding table.\n",szMethodName));
./af/ev/xp/ev_EditBinding.cpp:221:		UT_ASSERT(pem);				// TODO remove this and find a better way of doing a spelling-check...
./af/ev/xp/ev_EditBinding.cpp-222-		return UT_FALSE;
./af/ev/xp/ev_EditBinding.cpp-223-	}
./af/ev/xp/ev_EditBinding.cpp-224-
./af/ev/xp/ev_EditBinding.cpp-225-	EV_EditBinding * peb = new EV_EditBinding(pem);
./af/ev/xp/ev_EditBinding.cpp-226-	if (!peb)

./af/ev/xp/ev_EditBinding.cpp-277-				m_pebChar = new ev_EB_Char_Table();
./af/ev/xp/ev_EditBinding.cpp-278-				if (!m_pebChar)
./af/ev/xp/ev_EditBinding.cpp-279-					return UT_FALSE;
./af/ev/xp/ev_EditBinding.cpp-280-			}
./af/ev/xp/ev_EditBinding.cpp-281-			UT_uint32 n_evk = EV_EVK_ToNumber(eb);
./af/ev/xp/ev_EditBinding.cpp:282:			UT_ASSERT(n_evk < 256);		// TODO see note [1] above.
./af/ev/xp/ev_EditBinding.cpp-283-			UT_uint32 n_ems = EV_EMS_ToNumberNoShift(eb);
./af/ev/xp/ev_EditBinding.cpp-284-			if (m_pebChar->m_peb[n_evk][n_ems])
./af/ev/xp/ev_EditBinding.cpp-285-				return UT_FALSE;
./af/ev/xp/ev_EditBinding.cpp-286-			m_pebChar->m_peb[n_evk][n_ems] = peb;
./af/ev/xp/ev_EditBinding.cpp-287-			return UT_TRUE;

./af/ev/xp/ev_EditBinding.cpp-324-		else							// a non-nvk -- regular char
./af/ev/xp/ev_EditBinding.cpp-325-		{
./af/ev/xp/ev_EditBinding.cpp-326-			if (!m_pebChar)
./af/ev/xp/ev_EditBinding.cpp-327-				return UT_FALSE;
./af/ev/xp/ev_EditBinding.cpp-328-			UT_uint32 n_evk = EV_EVK_ToNumber(eb);
./af/ev/xp/ev_EditBinding.cpp:329:			UT_ASSERT(n_evk < 256);		// TODO see note [1] above.
./af/ev/xp/ev_EditBinding.cpp-330-			UT_uint32 n_ems = EV_EMS_ToNumberNoShift(eb);
./af/ev/xp/ev_EditBinding.cpp-331-			m_pebChar->m_peb[n_evk][n_ems] = 0;
./af/ev/xp/ev_EditBinding.cpp-332-			return UT_TRUE;
./af/ev/xp/ev_EditBinding.cpp-333-		}
./af/ev/xp/ev_EditBinding.cpp-334-	}

./af/ev/xp/ev_EditBinding.cpp-416-	else
./af/ev/xp/ev_EditBinding.cpp-417-	{
./af/ev/xp/ev_EditBinding.cpp-418-		// translate NVK
./af/ev/xp/ev_EditBinding.cpp-419-		const char * szNVK = NULL;
./af/ev/xp/ev_EditBinding.cpp-420-
./af/ev/xp/ev_EditBinding.cpp:421:		// TODO: look these up from table, rather than switch
./af/ev/xp/ev_EditBinding.cpp-422-		switch(EV_NamedKey(i-1))
./af/ev/xp/ev_EditBinding.cpp-423-		{
./af/ev/xp/ev_EditBinding.cpp-424-		case EV_NVK_DELETE:
./af/ev/xp/ev_EditBinding.cpp-425-			szNVK = "Del";
./af/ev/xp/ev_EditBinding.cpp-426-			break;

./af/ev/xp/ev_EditBinding.cpp-444-	return buf;
./af/ev/xp/ev_EditBinding.cpp-445-}
./af/ev/xp/ev_EditBinding.cpp-446-	
./af/ev/xp/ev_EditBinding.cpp-447-UT_Bool EV_EditBindingMap::parseEditBinding(void)
./af/ev/xp/ev_EditBinding.cpp-448-{
./af/ev/xp/ev_EditBinding.cpp:449:	/* TODO here we import a binding from a primitive ascii format
./af/ev/xp/ev_EditBinding.cpp:450:	** TODO or XML syntax.
./af/ev/xp/ev_EditBinding.cpp-451-	*/
./af/ev/xp/ev_EditBinding.cpp-452-	return UT_FALSE;
./af/ev/xp/ev_EditBinding.cpp-453-}

./af/ev/xp/ev_Menu_Actions.cpp-104-/*****************************************************************/
./af/ev/xp/ev_Menu_Actions.cpp-105-/*****************************************************************/
./af/ev/xp/ev_Menu_Actions.cpp-106-
./af/ev/xp/ev_Menu_Actions.cpp-107-EV_Menu_ActionSet::EV_Menu_ActionSet(XAP_Menu_Id first, XAP_Menu_Id last)
./af/ev/xp/ev_Menu_Actions.cpp-108-{
./af/ev/xp/ev_Menu_Actions.cpp:109:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Menu_Actions.cpp:110:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Menu_Actions.cpp-111-	m_actionTable = (EV_Menu_Action **)calloc((last-first+1),sizeof(EV_Menu_Action *));
./af/ev/xp/ev_Menu_Actions.cpp-112-	m_first = first;
./af/ev/xp/ev_Menu_Actions.cpp-113-	m_last = last;
./af/ev/xp/ev_Menu_Actions.cpp-114-}
./af/ev/xp/ev_Menu_Actions.cpp-115-

./af/ev/xp/ev_Menu_Labels.cpp-62-/*****************************************************************/
./af/ev/xp/ev_Menu_Labels.cpp-63-
./af/ev/xp/ev_Menu_Labels.cpp-64-EV_Menu_LabelSet::EV_Menu_LabelSet(const char * szLanguage,
./af/ev/xp/ev_Menu_Labels.cpp-65-								   XAP_Menu_Id first, XAP_Menu_Id last)
./af/ev/xp/ev_Menu_Labels.cpp-66-{
./af/ev/xp/ev_Menu_Labels.cpp:67:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Menu_Labels.cpp:68:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Menu_Labels.cpp-69-	UT_cloneString(m_szLanguage,szLanguage);
./af/ev/xp/ev_Menu_Labels.cpp-70-	m_labelTable = (EV_Menu_Label **)calloc((last-first+1),sizeof(EV_Menu_Label *));
./af/ev/xp/ev_Menu_Labels.cpp-71-	m_first = first;
./af/ev/xp/ev_Menu_Labels.cpp-72-	m_last = last;
./af/ev/xp/ev_Menu_Labels.cpp-73-}

./af/ev/xp/ev_Menu_Labels.cpp-107-	
./af/ev/xp/ev_Menu_Labels.cpp-108-	EV_Menu_Label * pLabel = m_labelTable[index];
./af/ev/xp/ev_Menu_Labels.cpp-109-
./af/ev/xp/ev_Menu_Labels.cpp-110-	// IDEA: some labelsets are sparse because their translation is behind
./af/ev/xp/ev_Menu_Labels.cpp-111-	// HACK: if no label, create a fallback JIT so we don't fail downstream
./af/ev/xp/ev_Menu_Labels.cpp:112:	// TODO: fall back to English instead like strings do (but not here)
./af/ev/xp/ev_Menu_Labels.cpp-113-	if (!pLabel)
./af/ev/xp/ev_Menu_Labels.cpp-114-	{
./af/ev/xp/ev_Menu_Labels.cpp-115-		UT_DEBUGMSG(("WARNING: %s translation for menu id [%d] not found.\n",m_szLanguage,id));
./af/ev/xp/ev_Menu_Labels.cpp-116-		// NOTE: only translators should see the following strings
./af/ev/xp/ev_Menu_Labels.cpp-117-		// NOTE: do *not* translate them

./af/ev/xp/ev_Menu_Layouts.cpp-50-
./af/ev/xp/ev_Menu_Layouts.cpp-51-EV_Menu_Layout::EV_Menu_Layout(const char * szName, UT_uint32 nrLayoutItems)
./af/ev/xp/ev_Menu_Layouts.cpp-52-{
./af/ev/xp/ev_Menu_Layouts.cpp-53-	UT_ASSERT(nrLayoutItems > 0);
./af/ev/xp/ev_Menu_Layouts.cpp-54-	m_nrLayoutItems = nrLayoutItems;
./af/ev/xp/ev_Menu_Layouts.cpp:55:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Menu_Layouts.cpp:56:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Menu_Layouts.cpp-57-	m_layoutTable = (EV_Menu_LayoutItem **)calloc(nrLayoutItems,sizeof(EV_Menu_LayoutItem *));
./af/ev/xp/ev_Menu_Layouts.cpp-58-	UT_ASSERT(m_layoutTable);
./af/ev/xp/ev_Menu_Layouts.cpp-59-	UT_cloneString(m_szName,szName);
./af/ev/xp/ev_Menu_Layouts.cpp-60-}
./af/ev/xp/ev_Menu_Layouts.cpp-61-

./af/ev/xp/ev_Mouse.cpp-56-	EV_EditMethodType t = pEM->getType();
./af/ev/xp/ev_Mouse.cpp-57-
./af/ev/xp/ev_Mouse.cpp-58-	if ((t & EV_EMT_REQUIREDATA) != 0)
./af/ev/xp/ev_Mouse.cpp-59-	{
./af/ev/xp/ev_Mouse.cpp-60-		// they bound a mouse event to something which requires a character.
./af/ev/xp/ev_Mouse.cpp:61:		// TODO we should ding this back when the binding was made ??
./af/ev/xp/ev_Mouse.cpp-62-		UT_DEBUGMSG(("    invoke aborted due to lack of data\n"));
./af/ev/xp/ev_Mouse.cpp-63-		return UT_FALSE;
./af/ev/xp/ev_Mouse.cpp-64-	}
./af/ev/xp/ev_Mouse.cpp-65-
./af/ev/xp/ev_Mouse.cpp-66-	EV_EditMethodCallData emcd;

./af/ev/xp/ev_Toolbar_Actions.cpp-79-/*****************************************************************/
./af/ev/xp/ev_Toolbar_Actions.cpp-80-/*****************************************************************/
./af/ev/xp/ev_Toolbar_Actions.cpp-81-
./af/ev/xp/ev_Toolbar_Actions.cpp-82-EV_Toolbar_ActionSet::EV_Toolbar_ActionSet(XAP_Toolbar_Id first, XAP_Toolbar_Id last)
./af/ev/xp/ev_Toolbar_Actions.cpp-83-{
./af/ev/xp/ev_Toolbar_Actions.cpp:84:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Toolbar_Actions.cpp:85:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Toolbar_Actions.cpp-86-	m_actionTable = (EV_Toolbar_Action **)calloc((last-first+1),sizeof(EV_Toolbar_Action *));
./af/ev/xp/ev_Toolbar_Actions.cpp-87-	m_first = first;
./af/ev/xp/ev_Toolbar_Actions.cpp-88-	m_last = last;
./af/ev/xp/ev_Toolbar_Actions.cpp-89-}
./af/ev/xp/ev_Toolbar_Actions.cpp-90-

./af/ev/xp/ev_Toolbar_Labels.cpp-78-/*****************************************************************/
./af/ev/xp/ev_Toolbar_Labels.cpp-79-
./af/ev/xp/ev_Toolbar_Labels.cpp-80-EV_Toolbar_LabelSet::EV_Toolbar_LabelSet(const char * szLanguage,
./af/ev/xp/ev_Toolbar_Labels.cpp-81-										 XAP_Toolbar_Id first, XAP_Toolbar_Id last)
./af/ev/xp/ev_Toolbar_Labels.cpp-82-{
./af/ev/xp/ev_Toolbar_Labels.cpp:83:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Toolbar_Labels.cpp:84:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Toolbar_Labels.cpp-85-	UT_cloneString(m_szLanguage,szLanguage);
./af/ev/xp/ev_Toolbar_Labels.cpp-86-	m_labelTable = (EV_Toolbar_Label **)calloc((last-first+1),sizeof(EV_Toolbar_Label *));
./af/ev/xp/ev_Toolbar_Labels.cpp-87-	m_first = first;
./af/ev/xp/ev_Toolbar_Labels.cpp-88-	m_last = last;

./af/ev/xp/ev_Toolbar_Labels.cpp-89-}
./af/ev/xp/ev_Toolbar_Labels.cpp-125-	
./af/ev/xp/ev_Toolbar_Labels.cpp-126-	EV_Toolbar_Label * pLabel = m_labelTable[index];
./af/ev/xp/ev_Toolbar_Labels.cpp-127-
./af/ev/xp/ev_Toolbar_Labels.cpp-128-	// IDEA: some labelsets are sparse because their translation is behind
./af/ev/xp/ev_Toolbar_Labels.cpp-129-	// HACK: if no label, create a fallback JIT so we don't fail downstream
./af/ev/xp/ev_Toolbar_Labels.cpp:130:	// TODO: fall back to English instead like strings do (but not here)
./af/ev/xp/ev_Toolbar_Labels.cpp-131-	if (!pLabel)
./af/ev/xp/ev_Toolbar_Labels.cpp-132-	{
./af/ev/xp/ev_Toolbar_Labels.cpp-133-		UT_DEBUGMSG(("WARNING: %s translation for Toolbar id [%d] not found.\n",m_szLanguage,id));
./af/ev/xp/ev_Toolbar_Labels.cpp-134-		// NOTE: only translators should see the following strings
./af/ev/xp/ev_Toolbar_Labels.cpp-135-		// NOTE: do *not* translate them

./af/ev/xp/ev_Toolbar_Layouts.cpp-50-
./af/ev/xp/ev_Toolbar_Layouts.cpp-51-EV_Toolbar_Layout::EV_Toolbar_Layout(const char * szName, UT_uint32 nrLayoutItems)
./af/ev/xp/ev_Toolbar_Layouts.cpp-52-{
./af/ev/xp/ev_Toolbar_Layouts.cpp-53-	UT_ASSERT(nrLayoutItems > 0);
./af/ev/xp/ev_Toolbar_Layouts.cpp-54-	m_nrLayoutItems = nrLayoutItems;
./af/ev/xp/ev_Toolbar_Layouts.cpp:55:	// TODO tis bad to call malloc/calloc from a constructor, since we cannot report failure.
./af/ev/xp/ev_Toolbar_Layouts.cpp:56:	// TODO move this allocation to somewhere else.
./af/ev/xp/ev_Toolbar_Layouts.cpp-57-	m_layoutTable = (EV_Toolbar_LayoutItem **)calloc(nrLayoutItems,sizeof(EV_Toolbar_LayoutItem *));
./af/ev/xp/ev_Toolbar_Layouts.cpp-58-	UT_ASSERT(m_layoutTable);
./af/ev/xp/ev_Toolbar_Layouts.cpp-59-	UT_cloneString(m_szName,szName);
./af/ev/xp/ev_Toolbar_Layouts.cpp-60-}
./af/ev/xp/ev_Toolbar_Layouts.cpp-61-

./af/gr/xp/gr_VectorImage.cpp-118-   m_iDisplayHeight = iDisplayHeight;
./af/gr/xp/gr_VectorImage.cpp-119-}
./af/gr/xp/gr_VectorImage.cpp-120-
./af/gr/xp/gr_VectorImage.cpp-121-UT_Bool GR_VectorImage::convertToBuffer(UT_ByteBuf** ppBB) const
./af/gr/xp/gr_VectorImage.cpp-122-{
./af/gr/xp/gr_VectorImage.cpp:123:   UT_DEBUGMSG(("writing vector image data (TODO)\n"));
./af/gr/xp/gr_VectorImage.cpp-124-   return UT_FALSE;
./af/gr/xp/gr_VectorImage.cpp-125-}
./af/gr/xp/gr_VectorImage.cpp-126-
./af/gr/xp/gr_VectorImage.cpp-127-UT_Bool GR_VectorImage::convertFromBuffer(const UT_ByteBuf* pBB, UT_sint32 iDisplayWidth, UT_sint32 iDisplayHeight)
./af/gr/xp/gr_VectorImage.cpp-128-{
./af/gr/xp/gr_VectorImage.cpp-129-   m_iDisplayWidth = iDisplayWidth;
./af/gr/xp/gr_VectorImage.cpp-130-   m_iDisplayHeight = iDisplayHeight;
./af/gr/xp/gr_VectorImage.cpp-131-
./af/gr/xp/gr_VectorImage.cpp:132:   UT_DEBUGMSG(("reading vector image data (TODO)\n"));
./af/gr/xp/gr_VectorImage.cpp-133-   return UT_FALSE;
./af/gr/xp/gr_VectorImage.cpp-134-/*
./af/gr/xp/gr_VectorImage.cpp-135-   XML_Parser parser = XML_CreateParser(NULL);
./af/gr/xp/gr_VectorImage.cpp-136-   XML_SetUserData(parser, this);
./af/gr/xp/gr_VectorImage.cpp-137-   XML_SetElementHandler(parser, startElement, endElement);

./af/util/xp/ut_hash.cpp-80-
./af/util/xp/ut_hash.cpp-81-UT_sint32 UT_HashTable::addEntry(const char* pszLeft, const char* pszRight, void* pData)
./af/util/xp/ut_hash.cpp-82-{
./af/util/xp/ut_hash.cpp-83-	UT_ASSERT(pszLeft);
./af/util/xp/ut_hash.cpp-84-
./af/util/xp/ut_hash.cpp:85:	// TODO check to see if the entry is already there.
./af/util/xp/ut_hash.cpp-86-
./af/util/xp/ut_hash.cpp-87-	if (0 != verifySpaceToAddOneEntry())
./af/util/xp/ut_hash.cpp-88-	{
./af/util/xp/ut_hash.cpp-89-		return -1;
./af/util/xp/ut_hash.cpp-90-	}
./af/util/xp/ut_hash.cpp-91-
./af/util/xp/ut_hash.cpp:92:	// TODO the following are essentially memory allocations which can fail.  check them
./af/util/xp/ut_hash.cpp-93-	m_pEntries[m_iEntryCount].pszLeft = m_pool.addString(pszLeft);
./af/util/xp/ut_hash.cpp-94-
./af/util/xp/ut_hash.cpp-95-	if (pszRight)
./af/util/xp/ut_hash.cpp-96-		m_pEntries[m_iEntryCount].pszRight = m_pool.addString(pszRight);
./af/util/xp/ut_hash.cpp-97-

./af/util/xp/ut_hash.cpp-109-}
./af/util/xp/ut_hash.cpp-110-
./af/util/xp/ut_hash.cpp-111-UT_sint32 UT_HashTable::setEntry(UT_HashEntry* pEntry, const char* pszRight, void* pData)
./af/util/xp/ut_hash.cpp-112-{
./af/util/xp/ut_hash.cpp-113-	if (pszRight)
./af/util/xp/ut_hash.cpp:114:		pEntry->pszRight = m_pool.addString(pszRight);	// TODO this can fail, right?
./af/util/xp/ut_hash.cpp-115-
./af/util/xp/ut_hash.cpp-116-	pEntry->pData = pData;
./af/util/xp/ut_hash.cpp-117-
./af/util/xp/ut_hash.cpp-118-	return 0;
./af/util/xp/ut_hash.cpp-119-}

./af/util/xp/ut_misc.cpp-152-	{
./af/util/xp/ut_misc.cpp-153-		p++;
./af/util/xp/ut_misc.cpp-154-		goto ParseHex;
./af/util/xp/ut_misc.cpp-155-	}
./af/util/xp/ut_misc.cpp-156-
./af/util/xp/ut_misc.cpp:157:	// TODO consider accepting stock names (vga) colors, too?
./af/util/xp/ut_misc.cpp-158-
./af/util/xp/ut_misc.cpp-159-	UT_ASSERT(UT_NOT_IMPLEMENTED);
./af/util/xp/ut_misc.cpp-160-
./af/util/xp/ut_misc.cpp-161-	return;
./af/util/xp/ut_misc.cpp-162-

./af/util/xp/ut_misc.cpp-174-#define ut_PATHSEP '/'
./af/util/xp/ut_misc.cpp-175-#endif
./af/util/xp/ut_misc.cpp-176-
./af/util/xp/ut_misc.cpp-177-const char * UT_pathSuffix(const char * path)
./af/util/xp/ut_misc.cpp-178-{
./af/util/xp/ut_misc.cpp:179:	// TODO This needs to be moved to platform code.
./af/util/xp/ut_misc.cpp-180-	
./af/util/xp/ut_misc.cpp-181-	if (!path)
./af/util/xp/ut_misc.cpp-182-		return NULL;
./af/util/xp/ut_misc.cpp-183-
./af/util/xp/ut_misc.cpp-184-	// This algorithm is pretty simple.  We search backwards for

./af/util/xp/ut_misc.cpp-229-	if ((currentChar == '\''  ||  currentChar == UCS_RQUOTE)  &&  UT_UCS_isalnum(followChar)) return UT_FALSE;
./af/util/xp/ut_misc.cpp-230-	return UT_TRUE;
./af/util/xp/ut_misc.cpp-231-
./af/util/xp/ut_misc.cpp-232-#else
./af/util/xp/ut_misc.cpp-233-	/*
./af/util/xp/ut_misc.cpp:234:		TODO we need a more systematic way to handle this, instead 
./af/util/xp/ut_misc.cpp:235:		TODO of just randomly adding more whitespace & punctuation
./af/util/xp/ut_misc.cpp:236:		TODO on an as-discovered basis
./af/util/xp/ut_misc.cpp-237-	*/
./af/util/xp/ut_misc.cpp-238-	switch (currentChar)
./af/util/xp/ut_misc.cpp-239-	{
./af/util/xp/ut_misc.cpp-240-	case ' ':
./af/util/xp/ut_misc.cpp-241-	case ',':

./af/util/xp/ut_pool.cpp-43-}
./af/util/xp/ut_pool.cpp-44-
./af/util/xp/ut_pool.cpp-45-
./af/util/xp/ut_pool.cpp-46-UT_StringPool::UT_PoolBucket::UT_PoolBucket(int iSize)
./af/util/xp/ut_pool.cpp-47-{
./af/util/xp/ut_pool.cpp:48:	// TODO how do we handle constructor failure here?
./af/util/xp/ut_pool.cpp-49-	pChars = new char[iSize];
./af/util/xp/ut_pool.cpp-50-	iSpace = iSize;
./af/util/xp/ut_pool.cpp-51-	iCurLen = 0;
./af/util/xp/ut_pool.cpp-52-	pNext = NULL;
./af/util/xp/ut_pool.cpp-53-}
./af/util/xp/ut_pool.cpp-61-{
./af/util/xp/ut_pool.cpp-62-	UT_PoolBucket* pBuck = new UT_PoolBucket(n);
./af/util/xp/ut_pool.cpp-63-	pBuck->pNext = m_pFirstBucket;
./af/util/xp/ut_pool.cpp-64-	m_pFirstBucket = pBuck;
./af/util/xp/ut_pool.cpp-65-
./af/util/xp/ut_pool.cpp:66:	return 0; // TODO return code
./af/util/xp/ut_pool.cpp-67-}
./af/util/xp/ut_pool.cpp-68-
./af/util/xp/ut_pool.cpp-69-char* UT_StringPool::addString(const char* p)
./af/util/xp/ut_pool.cpp-70-{
./af/util/xp/ut_pool.cpp-71-	int len = strlen(p);

./af/util/xp/ut_string.cpp-316-
./af/util/xp/ut_string.cpp-317-	return rszDestBuffer;
./af/util/xp/ut_string.cpp-318-}
./af/util/xp/ut_string.cpp-319-
./af/util/xp/ut_string.cpp-320-
./af/util/xp/ut_string.cpp:321:// TODO : put a better strncpy here; resolve to platform version if available
./af/util/xp/ut_string.cpp-322-
./af/util/xp/ut_string.cpp-323-UT_uint32 UT_XML_strncpy(XML_Char * szDest, UT_uint32 nLen, const XML_Char * szSource)
./af/util/xp/ut_string.cpp-324-{
./af/util/xp/ut_string.cpp-325-	if (!szSource)
./af/util/xp/ut_string.cpp-326-		return 0;

./af/util/xp/ut_string.cpp-658-	*d = 0;
./af/util/xp/ut_string.cpp-659-
./af/util/xp/ut_string.cpp-660-	return dest;
./af/util/xp/ut_string.cpp-661-}
./af/util/xp/ut_string.cpp-662-
./af/util/xp/ut_string.cpp:663:// TODO shouldn't all of the 'char *' strings be 'unsigned char *' strings ??
./af/util/xp/ut_string.cpp-664-
./af/util/xp/ut_string.cpp-665-UT_UCSChar * UT_UCS_strcpy_char(UT_UCSChar * dest, const char * src)
./af/util/xp/ut_string.cpp-666-{
./af/util/xp/ut_string.cpp-667-	UT_ASSERT(dest);
./af/util/xp/ut_string.cpp-668-	UT_ASSERT(src);

./af/util/xp/ut_string.cpp-955-	{
./af/util/xp/ut_string.cpp-956-		UT_DEBUGMSG(("XML parsing error %s; %s:%d\n",
./af/util/xp/ut_string.cpp-957-			     XML_ErrorString(XML_GetErrorCode(parser)),
./af/util/xp/ut_string.cpp-958-			     __FILE__, __LINE__));
./af/util/xp/ut_string.cpp-959-	}
./af/util/xp/ut_string.cpp:960:	// TODO: who owns the storage for this?
./af/util/xp/ut_string.cpp-961-	// TMN: The caller of this function.
./af/util/xp/ut_string.cpp-962-	out = UT_strdup(out);
./af/util/xp/ut_string.cpp-963-	if (parser) XML_ParserFree(parser);
./af/util/xp/ut_string.cpp-964-	return out;
./af/util/xp/ut_string.cpp-965-#endif
./af/util/xp/ut_string.cpp-966-}
./af/util/xp/ut_string.cpp-967-
./af/util/xp/ut_string.cpp-968-UT_Bool UT_isSmartQuotableCharacter(UT_UCSChar c)
./af/util/xp/ut_string.cpp-969-{
./af/util/xp/ut_string.cpp:970:	// TODO:  this is anglo-centric; really need a locale argument or
./af/util/xp/ut_string.cpp:971:	// TODO:  something to get smart quote rules for the rest of the world
./af/util/xp/ut_string.cpp-972-	UT_Bool result;
./af/util/xp/ut_string.cpp-973-	switch (c)
./af/util/xp/ut_string.cpp-974-	{
./af/util/xp/ut_string.cpp-975-	case '"':
./af/util/xp/ut_string.cpp-976-	case '`':
./af/util/xp/ut_string.cpp-984-	return (result);
./af/util/xp/ut_string.cpp-985-}
./af/util/xp/ut_string.cpp-986-
./af/util/xp/ut_string.cpp-987-UT_Bool UT_isSmartQuotedCharacter(UT_UCSChar c)
./af/util/xp/ut_string.cpp-988-{
./af/util/xp/ut_string.cpp:989:	// TODO:  this is anglo-centric; really need a locale argument or
./af/util/xp/ut_string.cpp:990:	// TODO:  something to get smart quote rules for the rest of the world
./af/util/xp/ut_string.cpp-991-	UT_Bool result;
./af/util/xp/ut_string.cpp-992-	switch (c)
./af/util/xp/ut_string.cpp-993-	{
./af/util/xp/ut_string.cpp-994-	case UCS_LQUOTE:
./af/util/xp/ut_string.cpp-995-	case UCS_RQUOTE:

./af/util/xp/ut_units.cpp-17- * 02111-1307, USA.
./af/util/xp/ut_units.cpp-18- */
./af/util/xp/ut_units.cpp-19- 
./af/util/xp/ut_units.cpp-20-
./af/util/xp/ut_units.cpp-21-
./af/util/xp/ut_units.cpp:22:// TODO change this file to not reference GR_Graphics.
./af/util/xp/ut_units.cpp-23-
./af/util/xp/ut_units.cpp-24-#include <stdio.h>
./af/util/xp/ut_units.cpp-25-#include <string.h>
./af/util/xp/ut_units.cpp-26-#include <stdlib.h>
./af/util/xp/ut_units.cpp-27-#include <math.h>

./af/util/xp/ut_units.cpp-134-	// return pointer to static buffer -- use it quickly.
./af/util/xp/ut_units.cpp-135-	//
./af/util/xp/ut_units.cpp-136-	// We temporarily force the locale back to english so that
./af/util/xp/ut_units.cpp-137-	// we get a period as the decimal point.
./af/util/xp/ut_units.cpp-138-
./af/util/xp/ut_units.cpp:139:	// TODO what should the decimal precision of each different
./af/util/xp/ut_units.cpp:140:	// TODO unit of measurement be ??
./af/util/xp/ut_units.cpp-141-	
./af/util/xp/ut_units.cpp-142-	static char buf[100];
./af/util/xp/ut_units.cpp-143-	char bufFormat[100];
./af/util/xp/ut_units.cpp-144-	double valueScaled;
./af/util/xp/ut_units.cpp-145-	
./af/util/xp/ut_units.cpp-147-	{
./af/util/xp/ut_units.cpp-148-	case DIM_IN:
./af/util/xp/ut_units.cpp-149-		// (1/16th (0.0625) is smallest unit the ui will
./af/util/xp/ut_units.cpp-150-		// let them enter (via the TopRuler), so let's
./af/util/xp/ut_units.cpp-151-		// set the precision so that we get nice roundoff.
./af/util/xp/ut_units.cpp:152:		// TODO we may need to improve this later.
./af/util/xp/ut_units.cpp-153-		valueScaled = valueInInches;
./af/util/xp/ut_units.cpp-154-		sprintf(bufFormat,"%%%sfin",((szPrecision && *szPrecision) ? szPrecision : ".4"));
./af/util/xp/ut_units.cpp-155-		break;
./af/util/xp/ut_units.cpp-156-
./af/util/xp/ut_units.cpp-157-	case DIM_CM:

./af/util/xp/ut_units.cpp-204-	// return pointer to static buffer -- use it quickly.
./af/util/xp/ut_units.cpp-205-	//
./af/util/xp/ut_units.cpp-206-	// We temporarily force the locale back to english so that
./af/util/xp/ut_units.cpp-207-	// we get a period as the decimal point.
./af/util/xp/ut_units.cpp-208-
./af/util/xp/ut_units.cpp:209:	// TODO what should the decimal precision of each different
./af/util/xp/ut_units.cpp:210:	// TODO unit of measurement be ??
./af/util/xp/ut_units.cpp-211-	
./af/util/xp/ut_units.cpp-212-	static char buf[100];
./af/util/xp/ut_units.cpp-213-	char bufFormat[100];
./af/util/xp/ut_units.cpp-214-	
./af/util/xp/ut_units.cpp-215-	switch (dim)
./af/util/xp/ut_units.cpp-216-	{
./af/util/xp/ut_units.cpp-217-	case DIM_IN:
./af/util/xp/ut_units.cpp-218-		// (1/16th (0.0625) is smallest unit the ui will
./af/util/xp/ut_units.cpp-219-		// let them enter (via the TopRuler), so let's
./af/util/xp/ut_units.cpp-220-		// set the precision so that we get nice roundoff.
./af/util/xp/ut_units.cpp:221:		// TODO we may need to improve this later.
./af/util/xp/ut_units.cpp-222-		sprintf(bufFormat,"%%%sfin",((szPrecision && *szPrecision) ? szPrecision : ".4"));
./af/util/xp/ut_units.cpp-223-		break;
./af/util/xp/ut_units.cpp-224-
./af/util/xp/ut_units.cpp-225-	case DIM_CM:
./af/util/xp/ut_units.cpp-226-		sprintf(bufFormat,"%%%sfcm",((szPrecision && *szPrecision) ? szPrecision : ".2"));

./af/util/xp/ut_units.cpp-406-	return buf;
./af/util/xp/ut_units.cpp-407-}
./af/util/xp/ut_units.cpp-408-
./af/util/xp/ut_units.cpp-409-UT_Bool UT_hasDimensionComponent(const char * sz)
./af/util/xp/ut_units.cpp-410-{
./af/util/xp/ut_units.cpp:411:	// TODO : check against known units instead of taking any
./af/util/xp/ut_units.cpp:412:	// TODO : ASCII chars after a number as a sign of units.
./af/util/xp/ut_units.cpp-413-	
./af/util/xp/ut_units.cpp-414-	if (!sz)
./af/util/xp/ut_units.cpp-415-		return UT_FALSE;
./af/util/xp/ut_units.cpp-416-	
./af/util/xp/ut_units.cpp-417-	const char *p = sz;

./af/xap/xp/xad_Document.cpp-27-AD_Document::AD_Document()
./af/xap/xp/xad_Document.cpp-28-{
./af/xap/xp/xad_Document.cpp-29-	m_iRefCount = 1;
./af/xap/xp/xad_Document.cpp-30-	m_szFilename = NULL;
./af/xap/xp/xad_Document.cpp-31-
./af/xap/xp/xad_Document.cpp:32:	// TODO do we need to auto-increase the bucket count,
./af/xap/xp/xad_Document.cpp:33:   	// TODO if the ignore list gets long?
./af/xap/xp/xad_Document.cpp-34-	m_pIgnoreList = new UT_AlphaHashTable(11);
./af/xap/xp/xad_Document.cpp-35-}
./af/xap/xp/xad_Document.cpp-36-
./af/xap/xp/xad_Document.cpp-37-AD_Document::~AD_Document()
./af/xap/xp/xad_Document.cpp-38-{

./af/xap/xp/xap_App.cpp-71-}
./af/xap/xp/xap_App.cpp-72-
./af/xap/xp/xap_App.cpp-73-XAP_App::~XAP_App(void)
./af/xap/xp/xap_App.cpp-74-{
./af/xap/xp/xap_App.cpp-75-	// HACK: for now, this works from XAP code
./af/xap/xp/xap_App.cpp:76:	// TODO: where should this really go?
./af/xap/xp/xap_App.cpp-77-	if (m_pDict)
./af/xap/xp/xap_App.cpp-78-		m_pDict->save();
./af/xap/xp/xap_App.cpp-79-
./af/xap/xp/xap_App.cpp-80-	// run thru and destroy all frames on our window list.
./af/xap/xp/xap_App.cpp-81-	UT_VECTOR_PURGEALL(XAP_Frame *, m_vecFrames);

./af/xap/xp/xap_App.cpp-113-	m_pToolbarActionSet = AP_CreateToolbarActionSet();
./af/xap/xp/xap_App.cpp-114-	UT_ASSERT(m_pToolbarActionSet);
./af/xap/xp/xap_App.cpp-115-#endif
./af/xap/xp/xap_App.cpp-116-
./af/xap/xp/xap_App.cpp-117-	// HACK: for now, this works from XAP code
./af/xap/xp/xap_App.cpp:118:	// TODO: where should this really go?
./af/xap/xp/xap_App.cpp-119-	char * szPathname = UT_catPathname(getUserPrivateDirectory(),"custom.dic");
./af/xap/xp/xap_App.cpp-120-	UT_ASSERT(szPathname);
./af/xap/xp/xap_App.cpp-121-	m_pDict = new XAP_Dictionary(szPathname);
./af/xap/xp/xap_App.cpp-122-	FREEP(szPathname);
./af/xap/xp/xap_App.cpp-123-	UT_ASSERT(m_pDict);
./af/xap/xp/xap_App.cpp-124-	m_pDict->load();
./af/xap/xp/xap_App.cpp-125-        clearIdTable();
./af/xap/xp/xap_App.cpp-126-
./af/xap/xp/xap_App.cpp:127:	// TODO use m_pArgs->{argc,argv} to process any command-line
./af/xap/xp/xap_App.cpp:128:	// TODO options that we need.
./af/xap/xp/xap_App.cpp-129-	//
./af/xap/xp/xap_App.cpp-130-	// Need to initialize the random number generator. 
./af/xap/xp/xap_App.cpp-131-	//
./af/xap/xp/xap_App.cpp-132-	UT_uint32 t = (UT_uint32) time( NULL);
./af/xap/xp/xap_App.cpp-133-	srand(t);

./af/xap/xp/xap_App.cpp-181-	UT_ASSERT(pFrame);
./af/xap/xp/xap_App.cpp-182-
./af/xap/xp/xap_App.cpp-183-	// add this frame to our window list
./af/xap/xp/xap_App.cpp-184-	m_vecFrames.addItem(pFrame);
./af/xap/xp/xap_App.cpp-185-
./af/xap/xp/xap_App.cpp:186:	// TODO: error-check the following for mem failures
./af/xap/xp/xap_App.cpp-187-	if (pCloneOf)
./af/xap/xp/xap_App.cpp-188-	{
./af/xap/xp/xap_App.cpp-189-		// locate vector of this frame's clones
./af/xap/xp/xap_App.cpp-190-		UT_HashEntry* pEntry = m_hashClones.findEntry(pCloneOf->getViewKey());
./af/xap/xp/xap_App.cpp-191-

./af/xap/xp/xap_App.cpp-233-			if (f != pFrame)
./af/xap/xp/xap_App.cpp-234-				f->updateTitle();
./af/xap/xp/xap_App.cpp-235-		}
./af/xap/xp/xap_App.cpp-236-	}
./af/xap/xp/xap_App.cpp-237-	
./af/xap/xp/xap_App.cpp:238:	// TODO do something here...
./af/xap/xp/xap_App.cpp-239-	return UT_TRUE;
./af/xap/xp/xap_App.cpp-240-}
./af/xap/xp/xap_App.cpp-241-
./af/xap/xp/xap_App.cpp-242-UT_Bool XAP_App::forgetFrame(XAP_Frame * pFrame)
./af/xap/xp/xap_App.cpp-243-{

./af/xap/xp/xap_App.cpp-314-		m_vecFrames.deleteNthItem(ndx);
./af/xap/xp/xap_App.cpp-315-	}
./af/xap/xp/xap_App.cpp-316-
./af/xap/xp/xap_App.cpp-317-	notifyModelessDlgsCloseFrame(pFrame);
./af/xap/xp/xap_App.cpp-318-
./af/xap/xp/xap_App.cpp:319:	// TODO do something here...
./af/xap/xp/xap_App.cpp-320-
./af/xap/xp/xap_App.cpp-321-	return UT_TRUE;
./af/xap/xp/xap_App.cpp-322-}
./af/xap/xp/xap_App.cpp-323-
./af/xap/xp/xap_App.cpp-324-UT_Bool XAP_App::forgetClones(XAP_Frame * pFrame)

./af/xap/xp/xap_Dictionary.cpp-61-	UT_HASH_PURGEDATA(UT_UCSChar *, m_hashWords);
./af/xap/xp/xap_Dictionary.cpp-62-}
./af/xap/xp/xap_Dictionary.cpp-63-
./af/xap/xp/xap_Dictionary.cpp-64-const char * XAP_Dictionary::getShortName(void) const
./af/xap/xp/xap_Dictionary.cpp-65-{
./af/xap/xp/xap_Dictionary.cpp:66:	// TODO: get just the filename (no path), for use in UI
./af/xap/xp/xap_Dictionary.cpp-67-	return NULL;
./af/xap/xp/xap_Dictionary.cpp-68-}
./af/xap/xp/xap_Dictionary.cpp-69-
./af/xap/xp/xap_Dictionary.cpp-70-/*****************************************************************/
./af/xap/xp/xap_Dictionary.cpp-71-/*****************************************************************/
./af/xap/xp/xap_Dictionary.cpp-72-
./af/xap/xp/xap_Dictionary.cpp-73-UT_Bool XAP_Dictionary::_openFile(const char * mode)
./af/xap/xp/xap_Dictionary.cpp-74-{
./af/xap/xp/xap_Dictionary.cpp-75-	UT_ASSERT(!m_fp);
./af/xap/xp/xap_Dictionary.cpp-76-
./af/xap/xp/xap_Dictionary.cpp:77:	// TODO add code to make a backup of the original file, if it exists.
./af/xap/xp/xap_Dictionary.cpp-78-	
./af/xap/xp/xap_Dictionary.cpp-79-	m_fp = fopen(m_szFilename,mode);
./af/xap/xp/xap_Dictionary.cpp-80-	return (m_fp != 0);
./af/xap/xp/xap_Dictionary.cpp-81-}
./af/xap/xp/xap_Dictionary.cpp-82-

./af/xap/xp/xap_Dictionary.cpp-108-}
./af/xap/xp/xap_Dictionary.cpp-109-
./af/xap/xp/xap_Dictionary.cpp-110-void XAP_Dictionary::_abortFile(void)
./af/xap/xp/xap_Dictionary.cpp-111-{
./af/xap/xp/xap_Dictionary.cpp-112-	// abort the write.
./af/xap/xp/xap_Dictionary.cpp:113:	// TODO close the file and do any restore and/or cleanup.
./af/xap/xp/xap_Dictionary.cpp-114-
./af/xap/xp/xap_Dictionary.cpp-115-	_closeFile();
./af/xap/xp/xap_Dictionary.cpp-116-	return;
./af/xap/xp/xap_Dictionary.cpp-117-}
./af/xap/xp/xap_Dictionary.cpp-118-

./af/xap/xp/xap_Dlg_Print.cpp-229-
./af/xap/xp/xap_Dlg_Print.cpp-230-	pDialog->setCurrentPathname(szSuggestedName);
./af/xap/xp/xap_Dlg_Print.cpp-231-	pDialog->setSuggestFilename(UT_TRUE);
./af/xap/xp/xap_Dlg_Print.cpp-232-
./af/xap/xp/xap_Dlg_Print.cpp-233-	{
./af/xap/xp/xap_Dlg_Print.cpp:234:		// TODO : FIX THIS!  Make this pull dynamic types from the export
./af/xap/xp/xap_Dlg_Print.cpp:235:		// TODO : filter list (creat that while you're at it).
./af/xap/xp/xap_Dlg_Print.cpp-236-
./af/xap/xp/xap_Dlg_Print.cpp:237:		// TODO : Right now we can just feed the dialog some static filters
./af/xap/xp/xap_Dlg_Print.cpp:238:		// TODO : that will be ignored by Windows and BeOS but will be required
./af/xap/xp/xap_Dlg_Print.cpp:239:		// TODO : by Unix.
./af/xap/xp/xap_Dlg_Print.cpp-240-
./af/xap/xp/xap_Dlg_Print.cpp-241-		UT_uint32 filterCount = 1;
./af/xap/xp/xap_Dlg_Print.cpp-242-
./af/xap/xp/xap_Dlg_Print.cpp-243-		const char ** szDescList = (const char **) calloc(filterCount + 1,
./af/xap/xp/xap_Dlg_Print.cpp-244-														  sizeof(char *));

./af/xap/xp/xap_Draw_Symbol.cpp-142-	return m_Insert_Symbol_font;
./af/xap/xp/xap_Draw_Symbol.cpp-143-}
./af/xap/xp/xap_Draw_Symbol.cpp-144-
./af/xap/xp/xap_Draw_Symbol.cpp-145-void XAP_Draw_Symbol::setSelectedFont(char *font)
./af/xap/xp/xap_Draw_Symbol.cpp-146-{
./af/xap/xp/xap_Draw_Symbol.cpp:147:	// TODO: We need UT_UCS_strncpy_*
./af/xap/xp/xap_Draw_Symbol.cpp-148-
./af/xap/xp/xap_Draw_Symbol.cpp-149-	strcpy(m_Insert_Symbol_font, font);
./af/xap/xp/xap_Draw_Symbol.cpp-150-	setFontString ();
./af/xap/xp/xap_Draw_Symbol.cpp-151-	setFontStringarea ();
./af/xap/xp/xap_Draw_Symbol.cpp-152-

./af/xap/xp/xap_Frame.cpp-313-	return m_app;
./af/xap/xp/xap_Frame.cpp-314-}
./af/xap/xp/xap_Frame.cpp-315-
./af/xap/xp/xap_Frame.cpp-316-AV_View * XAP_Frame::getCurrentView(void) const
./af/xap/xp/xap_Frame.cpp-317-{
./af/xap/xp/xap_Frame.cpp:318:	// TODO i called this ...Current... in anticipation of having
./af/xap/xp/xap_Frame.cpp:319:	// TODO more than one view (think splitter windows) in this
./af/xap/xp/xap_Frame.cpp:320:	// TODO frame.  but i'm just guessing right now....
./af/xap/xp/xap_Frame.cpp-321-	
./af/xap/xp/xap_Frame.cpp-322-	return m_pView;
./af/xap/xp/xap_Frame.cpp-323-}
./af/xap/xp/xap_Frame.cpp-324-	
./af/xap/xp/xap_Frame.cpp-325-AD_Document * XAP_Frame::getCurrentDoc(void) const

./af/xap/xp/xap_Frame.cpp-417-		// where "244" comes from - the buffer being copied into
./af/xap/xp/xap_Frame.cpp-418-		// is currently 512 bytes. However, even 244 characters
./af/xap/xp/xap_Frame.cpp-419-		// is way too long for a title bar, so no reason to
./af/xap/xp/xap_Frame.cpp-420-		// increase the size to fit more snugly into the buffer.
./af/xap/xp/xap_Frame.cpp-421-		// Here's that previous assertion:
./af/xap/xp/xap_Frame.cpp:422:		// UT_ASSERT(strlen(szName) < 245); // TODO need #define for this number
./af/xap/xp/xap_Frame.cpp-423-
./af/xap/xp/xap_Frame.cpp-424-		// Check that the buffer (with generous room for
./af/xap/xp/xap_Frame.cpp-425-		// later decorations) is big enough.
./af/xap/xp/xap_Frame.cpp-426-		UT_ASSERT(sizeof(m_szTitle) > 245 + 30); 
./af/xap/xp/xap_Frame.cpp-427-

./af/xap/xp/xap_Frame.cpp-569-	return ans;
./af/xap/xp/xap_Frame.cpp-570-}
./af/xap/xp/xap_Frame.cpp-571-
./af/xap/xp/xap_Frame.cpp-572-UT_Error XAP_Frame::backup()
./af/xap/xp/xap_Frame.cpp-573-{
./af/xap/xp/xap_Frame.cpp:574:	char * ext = ".bak"; // TODO: Make this a preference
./af/xap/xp/xap_Frame.cpp-575-	char * oldName = (char *) m_pDoc->getFilename();
./af/xap/xp/xap_Frame.cpp-576-	char * backupName;
./af/xap/xp/xap_Frame.cpp-577-	if (!oldName || !(*oldName))
./af/xap/xp/xap_Frame.cpp-578-	{
./af/xap/xp/xap_Frame.cpp-579-		const XAP_StringSet * pSS = m_app->getStringSet();

./af/xap/xp/xap_Prefs.cpp-15- * along with this program; if not, write to the Free Software
./af/xap/xp/xap_Prefs.cpp-16- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
./af/xap/xp/xap_Prefs.cpp-17- * 02111-1307, USA.
./af/xap/xp/xap_Prefs.cpp-18- */
./af/xap/xp/xap_Prefs.cpp-19-
./af/xap/xp/xap_Prefs.cpp:20:// TODO add code to do an auto save anytime anything is changed.
./af/xap/xp/xap_Prefs.cpp-21-
./af/xap/xp/xap_Prefs.cpp-22-#include <stdlib.h>
./af/xap/xp/xap_Prefs.cpp-23-#include <stdio.h>
./af/xap/xp/xap_Prefs.cpp-24-#include <string.h>
./af/xap/xp/xap_Prefs.cpp-25-

./af/xap/xp/xap_Prefs.cpp-123-	}
./af/xap/xp/xap_Prefs.cpp-124-}
./af/xap/xp/xap_Prefs.cpp-125-
./af/xap/xp/xap_Prefs.cpp-126-UT_Bool XAP_PrefsScheme::getNthValue(UT_uint32 k, const XML_Char ** pszKey, const XML_Char ** pszValue) const
./af/xap/xp/xap_Prefs.cpp-127-{
./af/xap/xp/xap_Prefs.cpp:128:	// TODO we should fix hash to use ut_uint32 rather than int
./af/xap/xp/xap_Prefs.cpp-129-	
./af/xap/xp/xap_Prefs.cpp-130-	if (k >= (UT_uint32)m_hash.getEntryCount())
./af/xap/xp/xap_Prefs.cpp-131-		return UT_FALSE;
./af/xap/xp/xap_Prefs.cpp-132-	
./af/xap/xp/xap_Prefs.cpp-133-	UT_HashEntry * pEntry = m_hash.getNthEntryAlpha(k);

./af/xap/xp/xap_Prefs.cpp-152-
./af/xap/xp/xap_Prefs.cpp-153-void XAP_Prefs::setAutoSavePrefs(UT_Bool bAuto)
./af/xap/xp/xap_Prefs.cpp-154-{
./af/xap/xp/xap_Prefs.cpp-155-	m_bAutoSavePrefs = bAuto;
./af/xap/xp/xap_Prefs.cpp-156-
./af/xap/xp/xap_Prefs.cpp:157:	// TODO if turning autosave on, we should do a save now....
./af/xap/xp/xap_Prefs.cpp:158:	// TODO if was on and turning off, should we save it now ??
./af/xap/xp/xap_Prefs.cpp-159-}
./af/xap/xp/xap_Prefs.cpp-160-
./af/xap/xp/xap_Prefs.cpp-161-/*****************************************************************/
./af/xap/xp/xap_Prefs.cpp-162-
./af/xap/xp/xap_Prefs.cpp-163-UT_Bool XAP_Prefs::getUseEnvLocale(void) const

./af/xap/xp/xap_Prefs.cpp-356-			const XML_Char new_name[] = "_custom_";
./af/xap/xp/xap_Prefs.cpp-357-
./af/xap/xp/xap_Prefs.cpp-358-			if (setCurrentScheme(new_name))
./af/xap/xp/xap_Prefs.cpp-359-			{
./af/xap/xp/xap_Prefs.cpp-360-				// unused _custom_ scheme is lying around, so recycle it
./af/xap/xp/xap_Prefs.cpp:361:				UT_ASSERT(UT_TODO);
./af/xap/xp/xap_Prefs.cpp-362-
./af/xap/xp/xap_Prefs.cpp-363-				// HYP: reset the current scheme's hash table contents?
./af/xap/xp/xap_Prefs.cpp-364-				// ALT: replace the existing scheme with new empty one
./af/xap/xp/xap_Prefs.cpp-365-			}
./af/xap/xp/xap_Prefs.cpp-366-			else

./af/xap/xp/xap_Prefs.cpp-379-
./af/xap/xp/xap_Prefs.cpp-380-UT_Bool XAP_Prefs::setCurrentScheme(const XML_Char * szSchemeName)
./af/xap/xp/xap_Prefs.cpp-381-{
./af/xap/xp/xap_Prefs.cpp-382-	// set the current scheme.
./af/xap/xp/xap_Prefs.cpp-383-
./af/xap/xp/xap_Prefs.cpp:384:	// TODO notify the application that the scheme has changed
./af/xap/xp/xap_Prefs.cpp-385-
./af/xap/xp/xap_Prefs.cpp-386-	XAP_PrefsScheme * p = getScheme(szSchemeName);
./af/xap/xp/xap_Prefs.cpp-387-	if (!p)
./af/xap/xp/xap_Prefs.cpp-388-		return UT_FALSE;
./af/xap/xp/xap_Prefs.cpp-389-

./af/xap/xp/xap_Prefs.cpp-495-		{
./af/xap/xp/xap_Prefs.cpp-496-			UT_ASSERT(a[1] && *a[1]);	// require a value for each attribute keyword
./af/xap/xp/xap_Prefs.cpp-497-
./af/xap/xp/xap_Prefs.cpp-498-			if (UT_strcmp(a[0], "app") == 0)
./af/xap/xp/xap_Prefs.cpp-499-			{
./af/xap/xp/xap_Prefs.cpp:500:				// TODO the following test will fail if you are running
./af/xap/xp/xap_Prefs.cpp:501:				// TODO both an AbiWord (release) build and an AbiWord
./af/xap/xp/xap_Prefs.cpp:502:				// TODO Personal (development/personal) build.  That is,
./af/xap/xp/xap_Prefs.cpp:503:				// TODO you'll lose your MRU list if you alternate between
./af/xap/xp/xap_Prefs.cpp:504:				// TODO the two types of executables.
./af/xap/xp/xap_Prefs.cpp-505-				
./af/xap/xp/xap_Prefs.cpp-506-				const char * szThisApp = m_pApp->getApplicationName();
./af/xap/xp/xap_Prefs.cpp-507-				UT_DEBUGMSG(("Found preferences for application [%s] (this is [%s]).\n",
./af/xap/xp/xap_Prefs.cpp-508-							a[1],szThisApp));
./af/xap/xp/xap_Prefs.cpp-509-				if (UT_strcmp(a[1],szThisApp) != 0)

./af/xap/xp/xap_Prefs.cpp-512-					goto InvalidFileError;
./af/xap/xp/xap_Prefs.cpp-513-				}
./af/xap/xp/xap_Prefs.cpp-514-			}
./af/xap/xp/xap_Prefs.cpp-515-			else if (UT_strcmp(a[0], "ver") == 0)
./af/xap/xp/xap_Prefs.cpp-516-			{
./af/xap/xp/xap_Prefs.cpp:517:				// TODO test version number
./af/xap/xp/xap_Prefs.cpp-518-			}
./af/xap/xp/xap_Prefs.cpp-519-
./af/xap/xp/xap_Prefs.cpp-520-			a += 2;
./af/xap/xp/xap_Prefs.cpp-521-		}
./af/xap/xp/xap_Prefs.cpp-522-	}

./af/xap/xp/xap_Preview_Zoom.cpp-129-void XAP_Preview_Zoom::draw(void)
./af/xap/xp/xap_Preview_Zoom.cpp-130-{
./af/xap/xp/xap_Preview_Zoom.cpp-131-	UT_ASSERT(m_gc);
./af/xap/xp/xap_Preview_Zoom.cpp-132-	UT_ASSERT(m_string);
./af/xap/xp/xap_Preview_Zoom.cpp-133-	
./af/xap/xp/xap_Preview_Zoom.cpp:134:	// TODO : replace 5,5 with real coordinates
./af/xap/xp/xap_Preview_Zoom.cpp-135-	m_gc->clearArea(0, 0, getWindowWidth(), getWindowHeight());
./af/xap/xp/xap_Preview_Zoom.cpp-136-	m_gc->drawChars(m_string, 0, UT_UCS_strlen(m_string), 5, 5);
./af/xap/xp/xap_Preview_Zoom.cpp-137-}

./af/xap/xp/xap_Strings.cpp-144-	if (szString && *szString)
./af/xap/xp/xap_Strings.cpp-145-	{
./af/xap/xp/xap_Strings.cpp-146-		UT_GrowBuf gb;
./af/xap/xp/xap_Strings.cpp-147-		UT_decodeUTF8string(szString,UT_XML_strlen(szString),&gb);
./af/xap/xp/xap_Strings.cpp-148-
./af/xap/xp/xap_Strings.cpp:149:		// TODO The strings that we use (for dialogs and etc) are currently
./af/xap/xp/xap_Strings.cpp:150:		// TODO limited to single-byte encodings by the code below.  
./af/xap/xp/xap_Strings.cpp-151-
./af/xap/xp/xap_Strings.cpp-152-		int kLimit=gb.getLength();
./af/xap/xp/xap_Strings.cpp-153-		UT_uint16 * p=gb.getPointer(0);
./af/xap/xp/xap_Strings.cpp-154-		UT_ByteBuf str;		
./af/xap/xp/xap_Strings.cpp-155-		UT_Wctomb wctomb_conv;

./af/xap/xp/xap_Strings.cpp-223-
./af/xap/xp/xap_Strings.cpp-224-	for (k=0; k<kLimit; k++)
./af/xap/xp/xap_Strings.cpp-225-		if (UT_XML_stricmp(s_map[k].szName,szId) == 0)
./af/xap/xp/xap_Strings.cpp-226-			return XAP_DiskStringSet::setValue(s_map[k].id,szString);
./af/xap/xp/xap_Strings.cpp-227-
./af/xap/xp/xap_Strings.cpp:228:	// TODO should we promote this message to a message box ??
./af/xap/xp/xap_Strings.cpp-229-	UT_DEBUGMSG(("Unknown ID in string file [%s=\"%s\"]\n",szId,szString));
./af/xap/xp/xap_Strings.cpp-230-	return UT_FALSE;
./af/xap/xp/xap_Strings.cpp-231-}
./af/xap/xp/xap_Strings.cpp-232-
./af/xap/xp/xap_Strings.cpp-233-/*****************************************************************

./af/xap/xp/xap_Strings.cpp-284-					goto InvalidFileError;
./af/xap/xp/xap_Strings.cpp-285-				}
./af/xap/xp/xap_Strings.cpp-286-			}
./af/xap/xp/xap_Strings.cpp-287-			else if (UT_XML_stricmp(a[0], "ver") == 0)
./af/xap/xp/xap_Strings.cpp-288-			{
./af/xap/xp/xap_Strings.cpp:289:				// TODO test version number
./af/xap/xp/xap_Strings.cpp-290-			}
./af/xap/xp/xap_Strings.cpp-291-			else if (UT_XML_stricmp(a[0], "language") == 0)
./af/xap/xp/xap_Strings.cpp-292-			{
./af/xap/xp/xap_Strings.cpp-293-				UT_DEBUGMSG(("Found strings for language [%s].\n",a[1]));
./af/xap/xp/xap_Strings.cpp-294-				if (!setLanguage(a[1]))

./af/xap/xp/xap_Strings.cpp-430-	// we succeeded in parsing the file,
./af/xap/xp/xap_Strings.cpp-431-	// now check for higher-level consistency.
./af/xap/xp/xap_Strings.cpp-432-
./af/xap/xp/xap_Strings.cpp-433-#ifdef DEBUG	
./af/xap/xp/xap_Strings.cpp-434-	{
./af/xap/xp/xap_Strings.cpp:435:		// TODO should we promote this test to be production code
./af/xap/xp/xap_Strings.cpp:436:		// TODO and maybe raise a message box ??
./af/xap/xp/xap_Strings.cpp-437-		UT_uint32 kLimit = NrElements(s_map);
./af/xap/xp/xap_Strings.cpp-438-		UT_uint32 k;
./af/xap/xp/xap_Strings.cpp-439-
./af/xap/xp/xap_Strings.cpp-440-		for (k=0; k<kLimit; k++)
./af/xap/xp/xap_Strings.cpp-441-		{

./text/fmt/xp/fb_ColumnBreaker.cpp-75-					/*
./text/fmt/xp/fb_ColumnBreaker.cpp-76-					  Wow!  The very first line in this column won't fit.
./text/fmt/xp/fb_ColumnBreaker.cpp-77-					  
./text/fmt/xp/fb_ColumnBreaker.cpp-78-					  Big line.  (or maybe a small column)
./text/fmt/xp/fb_ColumnBreaker.cpp-79-					  
./text/fmt/xp/fb_ColumnBreaker.cpp:80:					  TODO what should we do here?  For now, we force it.
./text/fmt/xp/fb_ColumnBreaker.cpp-81-					*/
./text/fmt/xp/fb_ColumnBreaker.cpp-82-					pLastLineToKeep = pFirstLineToKeep;
./text/fmt/xp/fb_ColumnBreaker.cpp-83-				}
./text/fmt/xp/fb_ColumnBreaker.cpp-84-				else
./text/fmt/xp/fb_ColumnBreaker.cpp-85-				{

./text/fmt/xp/fb_ColumnBreaker.cpp-273-		pCurColumn->layout();
./text/fmt/xp/fb_ColumnBreaker.cpp-274-
./text/fmt/xp/fb_ColumnBreaker.cpp-275-		pCurColumn = pCurColumn->getNext();
./text/fmt/xp/fb_ColumnBreaker.cpp-276-	}
./text/fmt/xp/fb_ColumnBreaker.cpp-277-
./text/fmt/xp/fb_ColumnBreaker.cpp:278:	return 0; // TODO return code
./text/fmt/xp/fb_ColumnBreaker.cpp-279-}

./text/fmt/xp/fb_LineBreaker.cpp-272-					{
./text/fmt/xp/fb_LineBreaker.cpp-273-						// tab won't fit.  bump it to the next line
./text/fmt/xp/fb_LineBreaker.cpp-274-						UT_ASSERT(pCurrentRun->getPrev());
./text/fmt/xp/fb_LineBreaker.cpp-275-						UT_ASSERT(pCurrentRun != m_pFirstRunToKeep);
./text/fmt/xp/fb_LineBreaker.cpp-276-					
./text/fmt/xp/fb_LineBreaker.cpp:277:						// TODO - FIXIT - HACK - white space should be wrapped	???
./text/fmt/xp/fb_LineBreaker.cpp-278-						// shouldn't the end of the line eat up the last of the white space?
./text/fmt/xp/fb_LineBreaker.cpp-279-						m_pLastRunToKeep = pCurrentRun->getPrev();
./text/fmt/xp/fb_LineBreaker.cpp-280-						goto done_with_run_loop;
./text/fmt/xp/fb_LineBreaker.cpp-281-					}
./text/fmt/xp/fb_LineBreaker.cpp-282-					break;

./text/fmt/xp/fb_LineBreaker.cpp-340-		} /* if countruns > 0 */
./text/fmt/xp/fb_LineBreaker.cpp-341-		
./text/fmt/xp/fb_LineBreaker.cpp-342-		pLine = pLine->getNext();
./text/fmt/xp/fb_LineBreaker.cpp-343-	}
./text/fmt/xp/fb_LineBreaker.cpp-344-
./text/fmt/xp/fb_LineBreaker.cpp:345:	return 0; // TODO return code
./text/fmt/xp/fb_LineBreaker.cpp-346-}
./text/fmt/xp/fb_LineBreaker.cpp-347-
./text/fmt/xp/fb_LineBreaker.cpp-348-UT_sint32 fb_LineBreaker::_moveBackToFirstNonBlankData(fp_Run *pCurrentRun, fp_Run **pOffendingRun)
./text/fmt/xp/fb_LineBreaker.cpp-349-{
./text/fmt/xp/fb_LineBreaker.cpp-350-	// need to move back untill we find the first non blank character and

./text/fmt/xp/fb_LineBreaker.cpp-528-void fb_LineBreaker::_splitRunAt(fp_Run *pCurrentRun, fp_RunSplitInfo &splitInfo)
./text/fmt/xp/fb_LineBreaker.cpp-529-{
./text/fmt/xp/fb_LineBreaker.cpp-530-	UT_ASSERT(pCurrentRun->getType() == FPRUN_TEXT);
./text/fmt/xp/fb_LineBreaker.cpp-531-	fp_TextRun *pRunToSplit = (fp_TextRun*) pCurrentRun;
./text/fmt/xp/fb_LineBreaker.cpp-532-
./text/fmt/xp/fb_LineBreaker.cpp:533:	pRunToSplit->split(splitInfo.iOffset + 1);	// TODO err check this
./text/fmt/xp/fb_LineBreaker.cpp-534-	UT_ASSERT(pRunToSplit->getNext());
./text/fmt/xp/fb_LineBreaker.cpp-535-	UT_ASSERT(pRunToSplit->getNext()->getType() == FPRUN_TEXT);
./text/fmt/xp/fb_LineBreaker.cpp-536-	
./text/fmt/xp/fb_LineBreaker.cpp-537-	fp_TextRun *pOtherHalfOfSplitRun;
./text/fmt/xp/fb_LineBreaker.cpp-538-	pOtherHalfOfSplitRun = (fp_TextRun*) pRunToSplit->getNext();

./text/fmt/xp/fb_LineBreaker.cpp-591-		// make sure there is a next line
./text/fmt/xp/fb_LineBreaker.cpp-592-		pNextLine = pLine->getNext();
./text/fmt/xp/fb_LineBreaker.cpp-593-		if (!pNextLine)
./text/fmt/xp/fb_LineBreaker.cpp-594-		{
./text/fmt/xp/fb_LineBreaker.cpp-595-			fp_Line* pNewLine  = pBlock->getNewLine();
./text/fmt/xp/fb_LineBreaker.cpp:596:			UT_ASSERT(pNewLine);	// TODO check for outofmem
./text/fmt/xp/fb_LineBreaker.cpp-597-					
./text/fmt/xp/fb_LineBreaker.cpp-598-			pNextLine = pNewLine;
./text/fmt/xp/fb_LineBreaker.cpp-599-		}
./text/fmt/xp/fb_LineBreaker.cpp-600-
./text/fmt/xp/fb_LineBreaker.cpp-601-		fp_Run* pRunToBump = pLine->getLastRun();

./text/fmt/xp/fg_GraphicRaster.cpp-198-	   	NULL, NULL
./text/fmt/xp/fg_GraphicRaster.cpp-199-	};
./text/fmt/xp/fg_GraphicRaster.cpp-200-
./text/fmt/xp/fg_GraphicRaster.cpp-201-	pDoc->insertObject(iPos, PTO_Image, attributes, NULL);
./text/fmt/xp/fg_GraphicRaster.cpp-202-
./text/fmt/xp/fg_GraphicRaster.cpp:203:	// TODO: better error checking in this function
./text/fmt/xp/fg_GraphicRaster.cpp-204-	return UT_OK;
./text/fmt/xp/fg_GraphicRaster.cpp-205-}
./text/fmt/xp/fg_GraphicRaster.cpp-206-
./text/fmt/xp/fg_GraphicRaster.cpp-207-UT_Bool FG_GraphicRaster::setRaster_PNG(UT_ByteBuf* pBB)
./text/fmt/xp/fg_GraphicRaster.cpp-208-{

./text/fmt/xp/fg_GraphicVector.cpp-215-		NULL, NULL
./text/fmt/xp/fg_GraphicVector.cpp-216-	};
./text/fmt/xp/fg_GraphicVector.cpp-217-
./text/fmt/xp/fg_GraphicVector.cpp-218-	pDoc->insertObject(iPos, PTO_Image, attributes, NULL);
./text/fmt/xp/fg_GraphicVector.cpp-219-
./text/fmt/xp/fg_GraphicVector.cpp:220:	// TODO: better error checking in this function
./text/fmt/xp/fg_GraphicVector.cpp-221-	return UT_OK;
./text/fmt/xp/fg_GraphicVector.cpp-222-}
./text/fmt/xp/fg_GraphicVector.cpp-223-
./text/fmt/xp/fg_GraphicVector.cpp-224-UT_Bool FG_GraphicVector::setVector_SVG(UT_ByteBuf* pBB)
./text/fmt/xp/fg_GraphicVector.cpp-225-{

./text/fmt/xp/fl_AutoNum.cpp-110-{
./text/fmt/xp/fl_AutoNum.cpp-111-	fl_AutoNum * pParent;
./text/fmt/xp/fl_AutoNum.cpp-112-	
./text/fmt/xp/fl_AutoNum.cpp-113-	if (m_iParentID != 0)
./text/fmt/xp/fl_AutoNum.cpp-114-		pParent = pDoc->getListByID(m_iParentID);
./text/fmt/xp/fl_AutoNum.cpp:115:		// TODO Add error checking?
./text/fmt/xp/fl_AutoNum.cpp-116-	else
./text/fmt/xp/fl_AutoNum.cpp-117-		pParent = NULL;
./text/fmt/xp/fl_AutoNum.cpp-118-
./text/fmt/xp/fl_AutoNum.cpp-119-	m_pParent = pParent;
./text/fmt/xp/fl_AutoNum.cpp-120-

./text/fmt/xp/fl_AutoNum.cpp-263-	{
./text/fmt/xp/fl_AutoNum.cpp-264-	       *insPoint = 0;
./text/fmt/xp/fl_AutoNum.cpp-265-	       return;
./text/fmt/xp/fl_AutoNum.cpp-266-	}
./text/fmt/xp/fl_AutoNum.cpp-267-
./text/fmt/xp/fl_AutoNum.cpp:268:	// TODO This is a bit of a hack to split the delim string. It would be 
./text/fmt/xp/fl_AutoNum.cpp:269:	// TODO nice to clear it up.
./text/fmt/xp/fl_AutoNum.cpp-270-
./text/fmt/xp/fl_AutoNum.cpp-271-	sprintf(p, "%s", m_pszDelim);
./text/fmt/xp/fl_AutoNum.cpp-272-	UT_uint32 rTmp;
./text/fmt/xp/fl_AutoNum.cpp-273-	
./text/fmt/xp/fl_AutoNum.cpp-274-	i = 0;

./text/fmt/xp/fl_BlockLayout.cpp-742-{
./text/fmt/xp/fl_BlockLayout.cpp-743-	fp_Line* pLine = m_pFirstLine;
./text/fmt/xp/fl_BlockLayout.cpp-744- //         if(getSectionLayout() && (getSectionLayout()->getType()== FL_SECTION_HDRFTR))
./text/fmt/xp/fl_BlockLayout.cpp-745-//  	{
./text/fmt/xp/fl_BlockLayout.cpp-746-//  	  // Sevior.
./text/fmt/xp/fl_BlockLayout.cpp:747://  	  // TODO. Investigate whether this causes a memory leak.
./text/fmt/xp/fl_BlockLayout.cpp-748-//            // This delete appears to clash with the line delete from the shadows
./text/fmt/xp/fl_BlockLayout.cpp-749-//            // Apparently the fact that both the first page shadow and this overall
./text/fmt/xp/fl_BlockLayout.cpp-750-//  	  // hdrftrSection are attached to the same container causes conflicts.
./text/fmt/xp/fl_BlockLayout.cpp-751-//  	  // Maybe we should implement a virtual header/footer container for the
./text/fmt/xp/fl_BlockLayout.cpp-752-//  	  // overall hdrftrSectionLayout. Anyway right now doing this prsvents

./text/fmt/xp/fl_BlockLayout.cpp-873-
./text/fmt/xp/fl_BlockLayout.cpp-874-	GR_Graphics* pG = m_pLayout->getGraphics();
./text/fmt/xp/fl_BlockLayout.cpp-875-	UT_ASSERT(pG);
./text/fmt/xp/fl_BlockLayout.cpp-876-
./text/fmt/xp/fl_BlockLayout.cpp-877-	fp_TextRun* pNewRun = new fp_TextRun(this, pG, m_pFirstRun->getBlockOffset(), 0);
./text/fmt/xp/fl_BlockLayout.cpp:878:	// TODO: Check for out-of-memory. Only assert for now
./text/fmt/xp/fl_BlockLayout.cpp-879-	UT_ASSERT(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-880-
./text/fmt/xp/fl_BlockLayout.cpp-881-	m_pFirstRun->insertIntoRunListBeforeThis(*pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-882-	pFirstLine->insertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-883-	m_pFirstRun = pNewRun;

./text/fmt/xp/fl_BlockLayout.cpp-1117-	{
./text/fmt/xp/fl_BlockLayout.cpp-1118-	        pView->drawInsertionPoint();
./text/fmt/xp/fl_BlockLayout.cpp-1119-		m_bCursorErased = UT_FALSE;
./text/fmt/xp/fl_BlockLayout.cpp-1120-	}
./text/fmt/xp/fl_BlockLayout.cpp-1121-
./text/fmt/xp/fl_BlockLayout.cpp:1122:	return 0;	// TODO return code
./text/fmt/xp/fl_BlockLayout.cpp-1123-}
./text/fmt/xp/fl_BlockLayout.cpp-1124-
./text/fmt/xp/fl_BlockLayout.cpp-1125-void fl_BlockLayout::redrawUpdate()
./text/fmt/xp/fl_BlockLayout.cpp-1126-{
./text/fmt/xp/fl_BlockLayout.cpp-1127-        m_bCursorErased = UT_FALSE;

./text/fmt/xp/fl_BlockLayout.cpp-1164-	  {
./text/fmt/xp/fl_BlockLayout.cpp-1165-	    UT_ASSERT(0);
./text/fmt/xp/fl_BlockLayout.cpp-1166-	    return NULL;
./text/fmt/xp/fl_BlockLayout.cpp-1167-	  }
./text/fmt/xp/fl_BlockLayout.cpp-1168-	fp_Line* pLine = new fp_Line();
./text/fmt/xp/fl_BlockLayout.cpp:1169:	// TODO: Handle out-of-memory
./text/fmt/xp/fl_BlockLayout.cpp-1170-	UT_ASSERT(pLine);
./text/fmt/xp/fl_BlockLayout.cpp-1171-	
./text/fmt/xp/fl_BlockLayout.cpp-1172-	pLine->setBlock(this);
./text/fmt/xp/fl_BlockLayout.cpp-1173-	pLine->setNext(NULL);
./text/fmt/xp/fl_BlockLayout.cpp-1174-	

./text/fmt/xp/fl_BlockLayout.cpp-1198-		if(m_pPrev)
./text/fmt/xp/fl_BlockLayout.cpp-1199-		{
./text/fmt/xp/fl_BlockLayout.cpp-1200-		        if(m_pPrev->getLastLine() == NULL)
./text/fmt/xp/fl_BlockLayout.cpp-1201-		        {
./text/fmt/xp/fl_BlockLayout.cpp-1202-			         // Previous block exists but doesn't have a last line.
./text/fmt/xp/fl_BlockLayout.cpp:1203:			         // This is a BUG. Try a work around for now. TODO Fix this elsewhere
./text/fmt/xp/fl_BlockLayout.cpp-1204-			         UT_DEBUGMSG(("BUG!!! Previous block exists with no last line. This should not happen \n"));
./text/fmt/xp/fl_BlockLayout.cpp-1205-			         //  m_pPrev->format();
./text/fmt/xp/fl_BlockLayout.cpp-1206-			}
./text/fmt/xp/fl_BlockLayout.cpp-1207-		}
./text/fmt/xp/fl_BlockLayout.cpp-1208-		if (m_pPrev && m_pPrev->getLastLine())

./text/fmt/xp/fl_BlockLayout.cpp-1214-		{
./text/fmt/xp/fl_BlockLayout.cpp-1215-			pContainer = m_pNext->getFirstLine()->getContainer();
./text/fmt/xp/fl_BlockLayout.cpp-1216-		}
./text/fmt/xp/fl_BlockLayout.cpp-1217-		else if (m_pSectionLayout->getFirstContainer())
./text/fmt/xp/fl_BlockLayout.cpp-1218-		{
./text/fmt/xp/fl_BlockLayout.cpp:1219:			// TODO assert something here about what's in that container
./text/fmt/xp/fl_BlockLayout.cpp-1220-			pContainer = m_pSectionLayout->getFirstContainer();
./text/fmt/xp/fl_BlockLayout.cpp-1221-		}
./text/fmt/xp/fl_BlockLayout.cpp-1222-		else
./text/fmt/xp/fl_BlockLayout.cpp-1223-		{
./text/fmt/xp/fl_BlockLayout.cpp-1224-			pContainer = m_pSectionLayout->getNewContainer();

./text/fmt/xp/fl_BlockLayout.cpp-1231-	}
./text/fmt/xp/fl_BlockLayout.cpp-1232-
./text/fmt/xp/fl_BlockLayout.cpp-1233-	return pLine;
./text/fmt/xp/fl_BlockLayout.cpp-1234-}
./text/fmt/xp/fl_BlockLayout.cpp-1235-
./text/fmt/xp/fl_BlockLayout.cpp:1236:// TODO: What I want to test is XML_Char != char
./text/fmt/xp/fl_BlockLayout.cpp-1237-#ifdef HAVE_LIBXML2
./text/fmt/xp/fl_BlockLayout.cpp-1238-const char*	fl_BlockLayout::getProperty(const char * pszName, UT_Bool bExpandStyles) const
./text/fmt/xp/fl_BlockLayout.cpp-1239-{
./text/fmt/xp/fl_BlockLayout.cpp-1240-	return getProperty((const XML_Char *) (pszName), bExpandStyles);
./text/fmt/xp/fl_BlockLayout.cpp-1241-}

./text/fmt/xp/fl_BlockLayout.cpp-1694-void fl_BlockLayout::_addSquiggle(UT_uint32 iOffset, UT_uint32 iLen, UT_Bool bIsIgnored /* = UT_FALSE */)
./text/fmt/xp/fl_BlockLayout.cpp-1695-{
./text/fmt/xp/fl_BlockLayout.cpp-1696-	fl_PartOfBlock*	pPOB = new fl_PartOfBlock();
./text/fmt/xp/fl_BlockLayout.cpp-1697-	if (!pPOB)
./text/fmt/xp/fl_BlockLayout.cpp-1698-	{
./text/fmt/xp/fl_BlockLayout.cpp:1699:		// TODO handle outofmem
./text/fmt/xp/fl_BlockLayout.cpp-1700-	}
./text/fmt/xp/fl_BlockLayout.cpp-1701-	
./text/fmt/xp/fl_BlockLayout.cpp-1702-	pPOB->iOffset = iOffset;
./text/fmt/xp/fl_BlockLayout.cpp-1703-	pPOB->iLength = iLen;
./text/fmt/xp/fl_BlockLayout.cpp-1704-	pPOB->bIsIgnored = bIsIgnored;

./text/fmt/xp/fl_BlockLayout.cpp-1804-
./text/fmt/xp/fl_BlockLayout.cpp-1805-			m_pLayout->checkPendingWordForSpell();
./text/fmt/xp/fl_BlockLayout.cpp-1806-		}
./text/fmt/xp/fl_BlockLayout.cpp-1807-	}
./text/fmt/xp/fl_BlockLayout.cpp-1808-
./text/fmt/xp/fl_BlockLayout.cpp:1809:	// TODO: check last word remaining in this block
./text/fmt/xp/fl_BlockLayout.cpp:1810:	// TODO: pending word is at beginning of next block
./text/fmt/xp/fl_BlockLayout.cpp-1811-
./text/fmt/xp/fl_BlockLayout.cpp-1812-	// recheck at boundary
./text/fmt/xp/fl_BlockLayout.cpp-1813-//	_recalcPendingWord(iOffset, 0);
./text/fmt/xp/fl_BlockLayout.cpp-1814-}
./text/fmt/xp/fl_BlockLayout.cpp-1815-

./text/fmt/xp/fl_BlockLayout.cpp-1883-
./text/fmt/xp/fl_BlockLayout.cpp-1884-			m_pLayout->checkPendingWordForSpell();
./text/fmt/xp/fl_BlockLayout.cpp-1885-		}
./text/fmt/xp/fl_BlockLayout.cpp-1886-	}
./text/fmt/xp/fl_BlockLayout.cpp-1887-
./text/fmt/xp/fl_BlockLayout.cpp:1888:	// TODO: may need to move pending word to this block
./text/fmt/xp/fl_BlockLayout.cpp-1889-
./text/fmt/xp/fl_BlockLayout.cpp-1890-	// we're in the middle of the pending word
./text/fmt/xp/fl_BlockLayout.cpp-1891-//	_recalcPendingWord(iOffset, 0);
./text/fmt/xp/fl_BlockLayout.cpp-1892-#else
./text/fmt/xp/fl_BlockLayout.cpp-1893-	m_pLayout->queueBlockForSpell(pPrevBL);

./text/fmt/xp/fl_BlockLayout.cpp-2396-{
./text/fmt/xp/fl_BlockLayout.cpp-2397-	FV_View* pView = m_pLayout->getView();
./text/fmt/xp/fl_BlockLayout.cpp-2398-	if(pView)
./text/fmt/xp/fl_BlockLayout.cpp-2399-		pView->eraseInsertionPoint();
./text/fmt/xp/fl_BlockLayout.cpp-2400-	fp_TextRun* pNewRun = new fp_TextRun(this, m_pLayout->getGraphics(), blockOffset, len);
./text/fmt/xp/fl_BlockLayout.cpp:2401:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2402-
./text/fmt/xp/fl_BlockLayout.cpp-2403-	if (_doInsertRun(pNewRun))
./text/fmt/xp/fl_BlockLayout.cpp-2404-	{
./text/fmt/xp/fl_BlockLayout.cpp-2405-#if 0
./text/fmt/xp/fl_BlockLayout.cpp-2406-		/*

./text/fmt/xp/fl_BlockLayout.cpp-2441-}
./text/fmt/xp/fl_BlockLayout.cpp-2442-
./text/fmt/xp/fl_BlockLayout.cpp-2443-UT_Bool	fl_BlockLayout::_doInsertForcedLineBreakRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2444-{
./text/fmt/xp/fl_BlockLayout.cpp-2445-	fp_Run* pNewRun = new fp_ForcedLineBreakRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2446:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2447-
./text/fmt/xp/fl_BlockLayout.cpp-2448-	UT_Bool bResult = _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2449-	if (bResult)
./text/fmt/xp/fl_BlockLayout.cpp-2450-	    _breakLineAfterRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2451-

./text/fmt/xp/fl_BlockLayout.cpp-2453-}
./text/fmt/xp/fl_BlockLayout.cpp-2454-
./text/fmt/xp/fl_BlockLayout.cpp-2455-UT_Bool	fl_BlockLayout::_doInsertFieldStartRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2456-{
./text/fmt/xp/fl_BlockLayout.cpp-2457-	fp_Run* pNewRun = new fp_FieldStartRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2458:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2459-
./text/fmt/xp/fl_BlockLayout.cpp-2460-	UT_Bool bResult = _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2461-	if (bResult)
./text/fmt/xp/fl_BlockLayout.cpp-2462-	    _breakLineAfterRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2463-

./text/fmt/xp/fl_BlockLayout.cpp-2465-}
./text/fmt/xp/fl_BlockLayout.cpp-2466-
./text/fmt/xp/fl_BlockLayout.cpp-2467-UT_Bool	fl_BlockLayout::_doInsertFieldEndRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2468-{
./text/fmt/xp/fl_BlockLayout.cpp-2469-	fp_Run* pNewRun = new fp_FieldEndRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2470:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2471-
./text/fmt/xp/fl_BlockLayout.cpp-2472-	UT_Bool bResult = _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2473-	if (bResult)
./text/fmt/xp/fl_BlockLayout.cpp-2474-	    _breakLineAfterRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2475-

./text/fmt/xp/fl_BlockLayout.cpp-2477-}
./text/fmt/xp/fl_BlockLayout.cpp-2478-
./text/fmt/xp/fl_BlockLayout.cpp-2479-UT_Bool	fl_BlockLayout::_doInsertForcedPageBreakRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2480-{
./text/fmt/xp/fl_BlockLayout.cpp-2481-	fp_Run* pNewRun = new fp_ForcedPageBreakRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2482:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2483-        if(getPrev()!= NULL && getPrev()->getLastLine()==NULL)
./text/fmt/xp/fl_BlockLayout.cpp-2484-        {
./text/fmt/xp/fl_BlockLayout.cpp-2485-	        UT_DEBUGMSG(("In fl_BlockLayout::_doInsertForcedPageBreakRun  no LastLine \n"));
./text/fmt/xp/fl_BlockLayout.cpp-2486-	        UT_DEBUGMSG(("getPrev = %d this = %d \n",getPrev(),this));
./text/fmt/xp/fl_BlockLayout.cpp-2487-	        //UT_ASSERT(UT_SHOULD_NOT_HAPPEN);

./text/fmt/xp/fl_BlockLayout.cpp-2495-}
./text/fmt/xp/fl_BlockLayout.cpp-2496-
./text/fmt/xp/fl_BlockLayout.cpp-2497-UT_Bool	fl_BlockLayout::_doInsertForcedColumnBreakRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2498-{
./text/fmt/xp/fl_BlockLayout.cpp-2499-	fp_Run* pNewRun = new fp_ForcedColumnBreakRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2500:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2501-
./text/fmt/xp/fl_BlockLayout.cpp-2502-	UT_Bool bResult = _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2503-	if (bResult)
./text/fmt/xp/fl_BlockLayout.cpp-2504-	    _breakLineAfterRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2505-

./text/fmt/xp/fl_BlockLayout.cpp-2507-}
./text/fmt/xp/fl_BlockLayout.cpp-2508-
./text/fmt/xp/fl_BlockLayout.cpp-2509-UT_Bool	fl_BlockLayout::_doInsertTabRun(PT_BlockOffset blockOffset)
./text/fmt/xp/fl_BlockLayout.cpp-2510-{
./text/fmt/xp/fl_BlockLayout.cpp-2511-	fp_Run* pNewRun = new fp_TabRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp:2512:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2513-
./text/fmt/xp/fl_BlockLayout.cpp-2514-	return _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2515-}
./text/fmt/xp/fl_BlockLayout.cpp-2516-
./text/fmt/xp/fl_BlockLayout.cpp-2517-UT_Bool	fl_BlockLayout::_doInsertImageRun(PT_BlockOffset blockOffset, FG_Graphic* pFG)
./text/fmt/xp/fl_BlockLayout.cpp-2518-{
./text/fmt/xp/fl_BlockLayout.cpp-2519-	GR_Image* pImage = pFG->generateImage(m_pLayout->getGraphics());
./text/fmt/xp/fl_BlockLayout.cpp-2520-
./text/fmt/xp/fl_BlockLayout.cpp-2521-	fp_ImageRun* pNewRun = new fp_ImageRun(this, m_pLayout->getGraphics(), blockOffset, 1, pImage);
./text/fmt/xp/fl_BlockLayout.cpp:2522:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2523-
./text/fmt/xp/fl_BlockLayout.cpp-2524-	return _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2525-}
./text/fmt/xp/fl_BlockLayout.cpp-2526-
./text/fmt/xp/fl_BlockLayout.cpp-2527-UT_Bool	fl_BlockLayout::_doInsertFieldRun(PT_BlockOffset blockOffset, const PX_ChangeRecord_Object * pcro /* pcro */)

./text/fmt/xp/fl_BlockLayout.cpp-2565-	  //
./text/fmt/xp/fl_BlockLayout.cpp-2566-	         pNewRun = new fp_FieldRun(this, m_pLayout->getGraphics(), blockOffset, 1);
./text/fmt/xp/fl_BlockLayout.cpp-2567-		//		return _doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-2568-	}
./text/fmt/xp/fl_BlockLayout.cpp-2569-
./text/fmt/xp/fl_BlockLayout.cpp:2570:	UT_ASSERT(pNewRun);	// TODO check for outofmem
./text/fmt/xp/fl_BlockLayout.cpp-2571-	
./text/fmt/xp/fl_BlockLayout.cpp-2572-	pNewRun->lookupProperties();
./text/fmt/xp/fl_BlockLayout.cpp-2573-	pNewRun->calculateValue();
./text/fmt/xp/fl_BlockLayout.cpp-2574-        
./text/fmt/xp/fl_BlockLayout.cpp-2575-	_doInsertRun(pNewRun);

./text/fmt/xp/fl_BlockLayout.cpp-2855-
./text/fmt/xp/fl_BlockLayout.cpp-2856-	FV_View* pView = m_pLayout->getView();
./text/fmt/xp/fl_BlockLayout.cpp-2857-	if (pView && pView->isActive())
./text/fmt/xp/fl_BlockLayout.cpp-2858-	{
./text/fmt/xp/fl_BlockLayout.cpp-2859-		pView->_setPoint(pcrs->getPosition() + len);
./text/fmt/xp/fl_BlockLayout.cpp:2860:		pView->notifyListeners(AV_CHG_FMTCHAR); // TODO verify that this is necessary.
./text/fmt/xp/fl_BlockLayout.cpp-2861-	}
./text/fmt/xp/fl_BlockLayout.cpp-2862-	else if(pView && pView->getPoint() > pcrs->getPosition())
./text/fmt/xp/fl_BlockLayout.cpp-2863-		pView->_setPoint(pView->getPoint() + len);
./text/fmt/xp/fl_BlockLayout.cpp-2864-
./text/fmt/xp/fl_BlockLayout.cpp-2865-	if (m_pLayout->hasBackgroundCheckReason(FL_DocLayout::bgcrSmartQuotes))

./text/fmt/xp/fl_BlockLayout.cpp-2920-{
./text/fmt/xp/fl_BlockLayout.cpp-2921-#ifndef NDEBUG	
./text/fmt/xp/fl_BlockLayout.cpp-2922-	_assertRunListIntegrity();
./text/fmt/xp/fl_BlockLayout.cpp-2923-#endif
./text/fmt/xp/fl_BlockLayout.cpp-2924-
./text/fmt/xp/fl_BlockLayout.cpp:2925:	/* TODO the attempts herein to do fetchCharWidths will fail. */
./text/fmt/xp/fl_BlockLayout.cpp-2926-	
./text/fmt/xp/fl_BlockLayout.cpp-2927-	m_gbCharWidths.del(blockOffset, len);
./text/fmt/xp/fl_BlockLayout.cpp-2928-
./text/fmt/xp/fl_BlockLayout.cpp-2929-	fp_Run* pRun = m_pFirstRun;
./text/fmt/xp/fl_BlockLayout.cpp-2930-	while (pRun)

./text/fmt/xp/fl_BlockLayout.cpp-3129-		}
./text/fmt/xp/fl_BlockLayout.cpp-3130-		else if (pRun->getType() == FPRUN_TAB)
./text/fmt/xp/fl_BlockLayout.cpp-3131-		{
./text/fmt/xp/fl_BlockLayout.cpp-3132-			pRun->lookupProperties();
./text/fmt/xp/fl_BlockLayout.cpp-3133-		}
./text/fmt/xp/fl_BlockLayout.cpp:3134:		// TODO: do we need to call lookupProperties for other run types.
./text/fmt/xp/fl_BlockLayout.cpp-3135-
./text/fmt/xp/fl_BlockLayout.cpp-3136-		pRun = pRun->getNext();
./text/fmt/xp/fl_BlockLayout.cpp-3137-	}
./text/fmt/xp/fl_BlockLayout.cpp-3138-
./text/fmt/xp/fl_BlockLayout.cpp-3139-	setNeedsReformat();

./text/fmt/xp/fl_BlockLayout.cpp-3328-	{	
./text/fmt/xp/fl_BlockLayout.cpp-3329-		// move all squiggles to previous block
./text/fmt/xp/fl_BlockLayout.cpp-3330-		_mergeSquiggles(offset, pPrevBL);
./text/fmt/xp/fl_BlockLayout.cpp-3331-
./text/fmt/xp/fl_BlockLayout.cpp-3332-		// update the display
./text/fmt/xp/fl_BlockLayout.cpp:3333://		pPrevBL->_lookupProperties();	// TODO: this may be needed
./text/fmt/xp/fl_BlockLayout.cpp-3334-		pPrevBL->setNeedsReformat();
./text/fmt/xp/fl_BlockLayout.cpp-3335-	}
./text/fmt/xp/fl_BlockLayout.cpp-3336-
./text/fmt/xp/fl_BlockLayout.cpp-3337-	// in case we've never checked this one
./text/fmt/xp/fl_BlockLayout.cpp-3338-	m_pLayout->dequeueBlockForBackgroundCheck(this);

./text/fmt/xp/fl_BlockLayout.cpp-3341-	if (pView && pView->isActive())
./text/fmt/xp/fl_BlockLayout.cpp-3342-		pView->_setPoint(pcrx->getPosition());
./text/fmt/xp/fl_BlockLayout.cpp-3343-	else if(pView && pView->getPoint() > pcrx->getPosition())
./text/fmt/xp/fl_BlockLayout.cpp-3344-		pView->_setPoint(pView->getPoint() - 1);
./text/fmt/xp/fl_BlockLayout.cpp-3345-
./text/fmt/xp/fl_BlockLayout.cpp:3346:	delete this;			// TODO whoa!  this construct is VERY dangerous.
./text/fmt/xp/fl_BlockLayout.cpp-3347-	
./text/fmt/xp/fl_BlockLayout.cpp-3348-	return UT_TRUE;
./text/fmt/xp/fl_BlockLayout.cpp-3349-}
./text/fmt/xp/fl_BlockLayout.cpp-3350-
./text/fmt/xp/fl_BlockLayout.cpp-3351-UT_Bool fl_BlockLayout::doclistener_changeStrux(const PX_ChangeRecord_StruxChange * pcrxc)

./text/fmt/xp/fl_BlockLayout.cpp-3464-	  fine, although the last run should be redrawn.
./text/fmt/xp/fl_BlockLayout.cpp-3465-	  
./text/fmt/xp/fl_BlockLayout.cpp-3466-	  All runs in the new block need their offsets fixed, and 
./text/fmt/xp/fl_BlockLayout.cpp-3467-	  that entire block needs to be formatted from scratch.
./text/fmt/xp/fl_BlockLayout.cpp-3468-
./text/fmt/xp/fl_BlockLayout.cpp:3469:	  TODO is the above commentary still correct ??
./text/fmt/xp/fl_BlockLayout.cpp-3470-	*/
./text/fmt/xp/fl_BlockLayout.cpp-3471-
./text/fmt/xp/fl_BlockLayout.cpp-3472-	// figure out where the breakpoint is
./text/fmt/xp/fl_BlockLayout.cpp-3473-	PT_BlockOffset blockOffset = (pcrx->getPosition() - getPosition());
./text/fmt/xp/fl_BlockLayout.cpp-3474-

./text/fmt/xp/fl_BlockLayout.cpp-3541-	// Split charwidths across the two blocks
./text/fmt/xp/fl_BlockLayout.cpp-3542-	UT_uint32 lenNew = m_gbCharWidths.getLength() - blockOffset;
./text/fmt/xp/fl_BlockLayout.cpp-3543-	if (lenNew > 0)
./text/fmt/xp/fl_BlockLayout.cpp-3544-	{
./text/fmt/xp/fl_BlockLayout.cpp-3545-		// NOTE: We do the length check on the outside for speed
./text/fmt/xp/fl_BlockLayout.cpp:3546:		// TODO [1] can we move info from the current to the new
./text/fmt/xp/fl_BlockLayout.cpp:3547:		// TODO CharWidths to keep from having to compute it in [2].
./text/fmt/xp/fl_BlockLayout.cpp-3548-		pNewBL->m_gbCharWidths.ins(0, m_gbCharWidths, blockOffset, lenNew);
./text/fmt/xp/fl_BlockLayout.cpp-3549-		m_gbCharWidths.truncate(blockOffset);
./text/fmt/xp/fl_BlockLayout.cpp-3550-	}
./text/fmt/xp/fl_BlockLayout.cpp-3551-
./text/fmt/xp/fl_BlockLayout.cpp-3552-	// Move remaining runs to new block

./text/fmt/xp/fl_BlockLayout.cpp-3554-
./text/fmt/xp/fl_BlockLayout.cpp-3555-	for (pRun=pFirstNewRun; (pRun); pRun=pRun->getNext())
./text/fmt/xp/fl_BlockLayout.cpp-3556-	{
./text/fmt/xp/fl_BlockLayout.cpp-3557-		pRun->setBlockOffset(pRun->getBlockOffset() - blockOffset);
./text/fmt/xp/fl_BlockLayout.cpp-3558-		pRun->setBlock(pNewBL);
./text/fmt/xp/fl_BlockLayout.cpp:3559:		// TODO [2] the following 2 steps seem expensive considering
./text/fmt/xp/fl_BlockLayout.cpp:3560:		// TODO we already knew width information before divided the
./text/fmt/xp/fl_BlockLayout.cpp:3561:		// TODO char widths data between the two clocks.  see [1].
./text/fmt/xp/fl_BlockLayout.cpp-3562-		pRun->fetchCharWidths(&pNewBL->m_gbCharWidths);
./text/fmt/xp/fl_BlockLayout.cpp-3563-		pRun->recalcWidth();
./text/fmt/xp/fl_BlockLayout.cpp-3564-	}
./text/fmt/xp/fl_BlockLayout.cpp-3565-
./text/fmt/xp/fl_BlockLayout.cpp-3566-	// Explicitly truncate rest of this block's layout

./text/fmt/xp/fl_BlockLayout.cpp-3794-		pView->_setPoint(pcro->getPosition() + 1);
./text/fmt/xp/fl_BlockLayout.cpp-3795-	else if(pView && pView->getPoint() > pcro->getPosition())
./text/fmt/xp/fl_BlockLayout.cpp-3796-		pView->_setPoint(pView->getPoint() + 1);
./text/fmt/xp/fl_BlockLayout.cpp-3797-
./text/fmt/xp/fl_BlockLayout.cpp-3798-	if (m_pLayout->getAutoSpellCheck())
./text/fmt/xp/fl_BlockLayout.cpp:3799:		_insertSquiggles(blockOffset, 1);	// TODO: are objects always one wide?
./text/fmt/xp/fl_BlockLayout.cpp-3800-
./text/fmt/xp/fl_BlockLayout.cpp-3801-	return UT_TRUE;
./text/fmt/xp/fl_BlockLayout.cpp-3802-}
./text/fmt/xp/fl_BlockLayout.cpp-3803-
./text/fmt/xp/fl_BlockLayout.cpp-3804-UT_Bool fl_BlockLayout::doclistener_deleteObject(const PX_ChangeRecord_Object * pcro)

./text/fmt/xp/fl_BlockLayout.cpp-3850-	}
./text/fmt/xp/fl_BlockLayout.cpp-3851-	else if(pView && pView->getPoint() > pcro->getPosition())
./text/fmt/xp/fl_BlockLayout.cpp-3852-		pView->_setPoint(pView->getPoint() - 1);
./text/fmt/xp/fl_BlockLayout.cpp-3853-
./text/fmt/xp/fl_BlockLayout.cpp-3854-	if (m_pLayout->getAutoSpellCheck())
./text/fmt/xp/fl_BlockLayout.cpp:3855:		_deleteSquiggles(blockOffset, 1);	// TODO: are objects always one wide?
./text/fmt/xp/fl_BlockLayout.cpp-3856-
./text/fmt/xp/fl_BlockLayout.cpp-3857-	return UT_TRUE;
./text/fmt/xp/fl_BlockLayout.cpp-3858-}
./text/fmt/xp/fl_BlockLayout.cpp-3859-
./text/fmt/xp/fl_BlockLayout.cpp-3860-UT_Bool fl_BlockLayout::doclistener_changeObject(const PX_ChangeRecord_ObjectChange * pcroc)

./text/fmt/xp/fl_BlockLayout.cpp-3863-	FV_View* pView = m_pLayout->getView();
./text/fmt/xp/fl_BlockLayout.cpp-3864-	switch (pcroc->getObjectType())
./text/fmt/xp/fl_BlockLayout.cpp-3865-	{
./text/fmt/xp/fl_BlockLayout.cpp-3866-	case PTO_Image:
./text/fmt/xp/fl_BlockLayout.cpp-3867-		UT_DEBUGMSG(("Edit:ChangeObject:Image:\n"));
./text/fmt/xp/fl_BlockLayout.cpp:3868:		// TODO ... deal with image object ...
./text/fmt/xp/fl_BlockLayout.cpp-3869-		return UT_TRUE;
./text/fmt/xp/fl_BlockLayout.cpp-3870-		
./text/fmt/xp/fl_BlockLayout.cpp-3871-	case PTO_Field:
./text/fmt/xp/fl_BlockLayout.cpp-3872-	{
./text/fmt/xp/fl_BlockLayout.cpp-3873-		UT_DEBUGMSG(("Edit:ChangeObject:Field:\n"));

./text/fmt/xp/fl_BlockLayout.cpp-4015-	UT_ASSERT(iStartX >= 0);
./text/fmt/xp/fl_BlockLayout.cpp-4016-
./text/fmt/xp/fl_BlockLayout.cpp-4017-	UT_uint32 iCountTabs = m_vecTabs.getItemCount();
./text/fmt/xp/fl_BlockLayout.cpp-4018-	UT_uint32 i;
./text/fmt/xp/fl_BlockLayout.cpp-4019-
./text/fmt/xp/fl_BlockLayout.cpp:4020:	UT_UNUSED(iLeader); // TODO FIXME
./text/fmt/xp/fl_BlockLayout.cpp-4021-	
./text/fmt/xp/fl_BlockLayout.cpp-4022-	for (i=0; i<iCountTabs; i++)
./text/fmt/xp/fl_BlockLayout.cpp-4023-	{
./text/fmt/xp/fl_BlockLayout.cpp-4024-		fl_TabStop* pTab = (fl_TabStop*) m_vecTabs.getNthItem(i);
./text/fmt/xp/fl_BlockLayout.cpp-4025-

./text/fmt/xp/fl_BlockLayout.cpp-4138-
./text/fmt/xp/fl_BlockLayout.cpp-4139-	fp_FmtMarkRun * pNewRun = new fp_FmtMarkRun(this,m_pLayout->getGraphics(),blockOffset);
./text/fmt/xp/fl_BlockLayout.cpp-4140-	UT_ASSERT(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-4141-	_doInsertRun(pNewRun);
./text/fmt/xp/fl_BlockLayout.cpp-4142-	
./text/fmt/xp/fl_BlockLayout.cpp:4143:	// TODO is it necessary to force a reformat when inserting a FmtMark
./text/fmt/xp/fl_BlockLayout.cpp-4144-	setNeedsReformat();
./text/fmt/xp/fl_BlockLayout.cpp-4145-
./text/fmt/xp/fl_BlockLayout.cpp-4146-	FV_View* pView = m_pLayout->getView();
./text/fmt/xp/fl_BlockLayout.cpp-4147-	if (pView && pView->isActive())
./text/fmt/xp/fl_BlockLayout.cpp-4148-		pView->_setPoint(pcrfm->getPosition());

./text/fmt/xp/fl_BlockLayout.cpp-4168-	UT_DEBUGMSG(("Edit:DeleteFmtMark: [blockOffset %ld]\n",blockOffset));
./text/fmt/xp/fl_BlockLayout.cpp-4169-
./text/fmt/xp/fl_BlockLayout.cpp-4170-	// we can't use the regular _delete() since we are of length zero
./text/fmt/xp/fl_BlockLayout.cpp-4171-	_deleteFmtMark(blockOffset);
./text/fmt/xp/fl_BlockLayout.cpp-4172-	
./text/fmt/xp/fl_BlockLayout.cpp:4173:	// TODO is it necessary to force a reformat when deleting a FmtMark
./text/fmt/xp/fl_BlockLayout.cpp-4174-	setNeedsReformat();
./text/fmt/xp/fl_BlockLayout.cpp-4175-
./text/fmt/xp/fl_BlockLayout.cpp-4176-	FV_View* pView = m_pLayout->getView();
./text/fmt/xp/fl_BlockLayout.cpp-4177-	if (pView && pView->isActive())
./text/fmt/xp/fl_BlockLayout.cpp-4178-	{

./text/fmt/xp/fl_BlockLayout.cpp-4760-
./text/fmt/xp/fl_BlockLayout.cpp-4761-
./text/fmt/xp/fl_BlockLayout.cpp-4762-	pAutoNum = new fl_AutoNum(id, iParentID, lType, start, lDelim, lDecimal, m_pDoc);
./text/fmt/xp/fl_BlockLayout.cpp-4763-	if (!pAutoNum)
./text/fmt/xp/fl_BlockLayout.cpp-4764-	{
./text/fmt/xp/fl_BlockLayout.cpp:4765:		// TODO Out of Mem.
./text/fmt/xp/fl_BlockLayout.cpp-4766-	}
./text/fmt/xp/fl_BlockLayout.cpp-4767-	m_pDoc->addList(pAutoNum);
./text/fmt/xp/fl_BlockLayout.cpp-4768-	pAutoNum->fixHierarchy(m_pDoc);
./text/fmt/xp/fl_BlockLayout.cpp-4769-
./text/fmt/xp/fl_BlockLayout.cpp-4770-	UT_uint32 counta = va.getItemCount() + 1;

./text/fmt/xp/fl_BlockLayout.cpp-5073-        return pPrev;
./text/fmt/xp/fl_BlockLayout.cpp-5074-}
./text/fmt/xp/fl_BlockLayout.cpp-5075-
./text/fmt/xp/fl_BlockLayout.cpp-5076-inline fl_BlockLayout * fl_BlockLayout::getParentItem(void)
./text/fmt/xp/fl_BlockLayout.cpp-5077-{
./text/fmt/xp/fl_BlockLayout.cpp:5078:	// TODO Again, more firendly.
./text/fmt/xp/fl_BlockLayout.cpp-5079-	UT_ASSERT(m_pAutoNum);
./text/fmt/xp/fl_BlockLayout.cpp-5080-	
./text/fmt/xp/fl_BlockLayout.cpp-5081-	fl_AutoNum * pParent = m_pAutoNum->getActiveParent();
./text/fmt/xp/fl_BlockLayout.cpp-5082-	if (pParent)
./text/fmt/xp/fl_BlockLayout.cpp-5083-		return getPreviousList(pParent->getID());

./text/fmt/xp/fl_DocLayout.cpp-70-	{
./text/fmt/xp/fl_DocLayout.cpp-71-		m_pRedrawUpdateTimer->set(REDRAW_UPDATE_MSECS);
./text/fmt/xp/fl_DocLayout.cpp-72-		m_pRedrawUpdateTimer->start();
./text/fmt/xp/fl_DocLayout.cpp-73-	}
./text/fmt/xp/fl_DocLayout.cpp-74-
./text/fmt/xp/fl_DocLayout.cpp:75:	// TODO the following (both the new() and the addListener() cause
./text/fmt/xp/fl_DocLayout.cpp:76:	// TODO malloc's to occur.  we are currently inside a constructor
./text/fmt/xp/fl_DocLayout.cpp:77:	// TODO and are not allowed to report failure.
./text/fmt/xp/fl_DocLayout.cpp-78-
./text/fmt/xp/fl_DocLayout.cpp-79-	// Turn off list updating until document is formatted
./text/fmt/xp/fl_DocLayout.cpp-80-
./text/fmt/xp/fl_DocLayout.cpp-81-	m_pDoc->disableListUpdates();
./text/fmt/xp/fl_DocLayout.cpp-82-	m_pDocListener = new fl_DocListener(doc, this);

./text/fmt/xp/fl_DocLayout.cpp-237-	{
./text/fmt/xp/fl_DocLayout.cpp-238-		double newSize = UT_convertToPoints(pszSize) * 2.0 / 3.0;
./text/fmt/xp/fl_DocLayout.cpp-239-		pszSize = UT_formatDimensionedValue(newSize,"pt",".0");
./text/fmt/xp/fl_DocLayout.cpp-240-	}
./text/fmt/xp/fl_DocLayout.cpp-241-	// NOTE: we currently favor a readable hash key to make debugging easier
./text/fmt/xp/fl_DocLayout.cpp:242:	// TODO: speed things up with a smaller key (the three AP pointers?) 
./text/fmt/xp/fl_DocLayout.cpp-243-	char key[500];
./text/fmt/xp/fl_DocLayout.cpp-244-	sprintf(key,"%s;%s;%s;%s;%s;%s,%i",pszFamily, pszStyle, pszVariant, pszWeight, pszStretch, pszSize, iUseLayoutResolution);
./text/fmt/xp/fl_DocLayout.cpp-245-	
./text/fmt/xp/fl_DocLayout.cpp-246-	UT_HashEntry* pEntry = m_hashFontCache.findEntry(key);
./text/fmt/xp/fl_DocLayout.cpp-247-	if (!pEntry)
./text/fmt/xp/fl_DocLayout.cpp-248-	{
./text/fmt/xp/fl_DocLayout.cpp:249:		// TODO -- note that we currently assume font-family to be a single name,
./text/fmt/xp/fl_DocLayout.cpp:250:		// TODO -- not a list.  This is broken.
./text/fmt/xp/fl_DocLayout.cpp-251-
./text/fmt/xp/fl_DocLayout.cpp-252-		if(iUseLayoutResolution)
./text/fmt/xp/fl_DocLayout.cpp-253-			{
./text/fmt/xp/fl_DocLayout.cpp-254-			m_pG->setLayoutResolutionMode(UT_TRUE);
./text/fmt/xp/fl_DocLayout.cpp-255-			}

./text/fmt/xp/fl_DocLayout.cpp-293-		double newSize = UT_convertToPoints(pszSize) * 2.0 / 3.0;
./text/fmt/xp/fl_DocLayout.cpp-294-		pszSize = UT_formatDimensionedValue(newSize,"pt",".0");
./text/fmt/xp/fl_DocLayout.cpp-295-	}
./text/fmt/xp/fl_DocLayout.cpp-296-
./text/fmt/xp/fl_DocLayout.cpp-297-	// NOTE: we currently favor a readable hash key to make debugging easier
./text/fmt/xp/fl_DocLayout.cpp:298:	// TODO: speed things up with a smaller key (the three AP pointers?) 
./text/fmt/xp/fl_DocLayout.cpp-299-	char key[500];
./text/fmt/xp/fl_DocLayout.cpp-300-	if(pszField!="NULL" && pszField != NULL && isField==UT_TRUE)
./text/fmt/xp/fl_DocLayout.cpp-301-	{
./text/fmt/xp/fl_DocLayout.cpp-302-	        pszFamily = pszField;
./text/fmt/xp/fl_DocLayout.cpp-303-	}
./text/fmt/xp/fl_DocLayout.cpp-304-	sprintf(key,"%s;%s;%s;%s;%s;%s,%i",pszFamily, pszStyle, pszVariant, pszWeight, pszStretch, pszSize, iUseLayoutResolution);
./text/fmt/xp/fl_DocLayout.cpp-305-	UT_HashEntry* pEntry = m_hashFontCache.findEntry(key);
./text/fmt/xp/fl_DocLayout.cpp-306-	if (!pEntry)
./text/fmt/xp/fl_DocLayout.cpp-307-	{
./text/fmt/xp/fl_DocLayout.cpp:308:		// TODO -- note that we currently assume font-family to be a single name,
./text/fmt/xp/fl_DocLayout.cpp:309:		// TODO -- not a list.  This is broken.
./text/fmt/xp/fl_DocLayout.cpp-310-
./text/fmt/xp/fl_DocLayout.cpp-311-		if(iUseLayoutResolution)
./text/fmt/xp/fl_DocLayout.cpp-312-			{
./text/fmt/xp/fl_DocLayout.cpp-313-			m_pG->setLayoutResolutionMode(UT_TRUE);
./text/fmt/xp/fl_DocLayout.cpp-314-			}

./text/fmt/xp/fl_DocLayout.cpp-530-}
./text/fmt/xp/fl_DocLayout.cpp-531-
./text/fmt/xp/fl_DocLayout.cpp-532-void FL_DocLayout::updateLayout()
./text/fmt/xp/fl_DocLayout.cpp-533-{
./text/fmt/xp/fl_DocLayout.cpp-534-	/*
./text/fmt/xp/fl_DocLayout.cpp:535:	  TODO the following routine checks every paragraph in the
./text/fmt/xp/fl_DocLayout.cpp-536-	  document to see if it needs a reformat.  How is this going
./text/fmt/xp/fl_DocLayout.cpp-537-	  to perform on a 50-page document?
./text/fmt/xp/fl_DocLayout.cpp-538-
./text/fmt/xp/fl_DocLayout.cpp-539-
./text/fmt/xp/fl_DocLayout.cpp-540-	  Very good point. We need a isOnScreen() method!!!

./text/fmt/xp/fl_DocLayout.cpp-575-		while (pSL)
./text/fmt/xp/fl_DocLayout.cpp-576-		{
./text/fmt/xp/fl_DocLayout.cpp-577-			fl_BlockLayout* b = pSL->getFirstBlock();
./text/fmt/xp/fl_DocLayout.cpp-578-			while (b)
./text/fmt/xp/fl_DocLayout.cpp-579-			{
./text/fmt/xp/fl_DocLayout.cpp:580:				// TODO: just check and remove matching squiggles
./text/fmt/xp/fl_DocLayout.cpp-581-				// for now, destructively recheck the whole thing
./text/fmt/xp/fl_DocLayout.cpp-582-				queueBlockForBackgroundCheck(bgcrSpelling, b);
./text/fmt/xp/fl_DocLayout.cpp-583-				b = b->getNext();
./text/fmt/xp/fl_DocLayout.cpp-584-			}
./text/fmt/xp/fl_DocLayout.cpp-585-			pSL = (fl_DocSectionLayout *) pSL->getNext();

./text/fmt/xp/fl_DocLayout.cpp-983-	pDocLayout->m_bSpellCheckInternet = b;
./text/fmt/xp/fl_DocLayout.cpp-984-	
./text/fmt/xp/fl_DocLayout.cpp-985-	// auto spell
./text/fmt/xp/fl_DocLayout.cpp-986-	pPrefs->getPrefsValueBool( (XML_Char *)AP_PREF_KEY_AutoSpellCheck, &b );
./text/fmt/xp/fl_DocLayout.cpp-987-	pDocLayout->_toggleAutoSpell( b );
./text/fmt/xp/fl_DocLayout.cpp:988:	// do this because it's recheck to document - TODO
./text/fmt/xp/fl_DocLayout.cpp-989-
./text/fmt/xp/fl_DocLayout.cpp-990-	if ( changed )
./text/fmt/xp/fl_DocLayout.cpp-991-	{
./text/fmt/xp/fl_DocLayout.cpp:992:		// TODO: recheck document
./text/fmt/xp/fl_DocLayout.cpp-993-		;
./text/fmt/xp/fl_DocLayout.cpp-994-	}
./text/fmt/xp/fl_DocLayout.cpp-995-
./text/fmt/xp/fl_DocLayout.cpp-996-	pPrefs->getPrefsValueBool( (XML_Char *)XAP_PREF_KEY_SmartQuotesEnable, &b );
./text/fmt/xp/fl_DocLayout.cpp-997-	pDocLayout->_toggleAutoSmartQuotes( b );

./text/fmt/xp/fl_DocLayout.cpp-1248-	sqOTHERPUNCT   =10,
./text/fmt/xp/fl_DocLayout.cpp-1249-	sqALPHA        =11,
./text/fmt/xp/fl_DocLayout.cpp-1250-	sqWHITE        =12
./text/fmt/xp/fl_DocLayout.cpp-1251-};
./text/fmt/xp/fl_DocLayout.cpp-1252-
./text/fmt/xp/fl_DocLayout.cpp:1253:// TODO:  This function probably needs tuning for non-Anglo locales.
./text/fmt/xp/fl_DocLayout.cpp-1254-static enum sqThingAt whatKindOfChar(UT_UCSChar thing)
./text/fmt/xp/fl_DocLayout.cpp-1255-{
./text/fmt/xp/fl_DocLayout.cpp-1256-	xxx_UT_DEBUGMSG(("what sort of character is %d 0x%x |%c|\n", thing, thing, thing));
./text/fmt/xp/fl_DocLayout.cpp-1257-	switch (thing)
./text/fmt/xp/fl_DocLayout.cpp-1258-	{

./text/fmt/xp/fl_DocLayout.cpp-1410-	if (UT_isSmartQuotableCharacter(c))
./text/fmt/xp/fl_DocLayout.cpp-1411-	{
./text/fmt/xp/fl_DocLayout.cpp-1412-		enum sqThingAt before = sqBREAK, after = sqBREAK;
./text/fmt/xp/fl_DocLayout.cpp-1413-		if (offset > 0)
./text/fmt/xp/fl_DocLayout.cpp-1414-		{
./text/fmt/xp/fl_DocLayout.cpp:1415:			// TODO: is there a need to see if this is on a run boundary?
./text/fmt/xp/fl_DocLayout.cpp:1416:			// TODO: Within a block, are there runs that are significant
./text/fmt/xp/fl_DocLayout.cpp:1417:			// TODO: breaks or whatever?
./text/fmt/xp/fl_DocLayout.cpp-1418-			before = whatKindOfChar(*pgb.getPointer(offset - 1));
./text/fmt/xp/fl_DocLayout.cpp-1419-		}
./text/fmt/xp/fl_DocLayout.cpp-1420-		else
./text/fmt/xp/fl_DocLayout.cpp-1421-		{
./text/fmt/xp/fl_DocLayout.cpp-1422-			// candidate was the first character in the block, so

./text/fmt/xp/fl_DocLayout.cpp-1449-			}
./text/fmt/xp/fl_DocLayout.cpp-1450-		}
./text/fmt/xp/fl_DocLayout.cpp-1451-
./text/fmt/xp/fl_DocLayout.cpp-1452-		if (offset+1 < pgb.getLength())
./text/fmt/xp/fl_DocLayout.cpp-1453-		{
./text/fmt/xp/fl_DocLayout.cpp:1454:			// TODO: is there a need to see if this is on a run boundary?
./text/fmt/xp/fl_DocLayout.cpp:1455:			// TODO: Within a block, are there runs that are significant
./text/fmt/xp/fl_DocLayout.cpp:1456:			// TODO: breaks or whatever?
./text/fmt/xp/fl_DocLayout.cpp-1457-			after = whatKindOfChar(*pgb.getPointer(offset + 1));
./text/fmt/xp/fl_DocLayout.cpp-1458-		}
./text/fmt/xp/fl_DocLayout.cpp-1459-		else
./text/fmt/xp/fl_DocLayout.cpp-1460-		{
./text/fmt/xp/fl_DocLayout.cpp-1461-			// candidate was the last character in a block, so see

./text/fmt/xp/fl_DocLayout.cpp-1479-		}
./text/fmt/xp/fl_DocLayout.cpp-1480-
./text/fmt/xp/fl_DocLayout.cpp-1481-		// we now know what the before and after things are, so 
./text/fmt/xp/fl_DocLayout.cpp-1482-		// spin through the table.
./text/fmt/xp/fl_DocLayout.cpp-1483-		UT_UCSChar replacement = UCS_UNKPUNK;  // means don't replace
./text/fmt/xp/fl_DocLayout.cpp:1484:		// TODO:  select a table based on default locale or on the locale
./text/fmt/xp/fl_DocLayout.cpp:1485:		// TODO:  of the fragment of text we're working in (locale tagging
./text/fmt/xp/fl_DocLayout.cpp:1486:		// TODO:  of text doesn't exist in Abi as of this writing)
./text/fmt/xp/fl_DocLayout.cpp-1487-		struct sqTable *table = sqTable_en;
./text/fmt/xp/fl_DocLayout.cpp-1488-		for (unsigned int tdex=0; table[tdex].thing; ++tdex)
./text/fmt/xp/fl_DocLayout.cpp-1489-		{
./text/fmt/xp/fl_DocLayout.cpp-1490-			if (c != table[tdex].thing) continue;
./text/fmt/xp/fl_DocLayout.cpp-1491-			if (table[tdex].before == sqDONTCARE  ||  table[tdex].before == before)

./text/fmt/xp/fl_DocListener.cpp-247-				}
./text/fmt/xp/fl_DocListener.cpp-248-			}
./text/fmt/xp/fl_DocListener.cpp-249-		}
./text/fmt/xp/fl_DocListener.cpp-250-		else
./text/fmt/xp/fl_DocListener.cpp-251-		{
./text/fmt/xp/fl_DocListener.cpp:252:			// TODO fail?
./text/fmt/xp/fl_DocListener.cpp-253-			return UT_FALSE;
./text/fmt/xp/fl_DocListener.cpp-254-		}
./text/fmt/xp/fl_DocListener.cpp-255-	}
./text/fmt/xp/fl_DocListener.cpp-256-	break;
./text/fmt/xp/fl_DocListener.cpp-257-

./text/fmt/xp/fl_DocListener.cpp-334-		case PX_ChangeRecord_Glob::PXF_MultiStepEnd:
./text/fmt/xp/fl_DocListener.cpp-335-			m_iGlobCounter--;
./text/fmt/xp/fl_DocListener.cpp-336-			bResult = UT_TRUE;
./text/fmt/xp/fl_DocListener.cpp-337-			goto finish_up;
./text/fmt/xp/fl_DocListener.cpp-338-				
./text/fmt/xp/fl_DocListener.cpp:339:		case PX_ChangeRecord_Glob::PXF_UserAtomicStart:	// TODO decide what (if anything) we need
./text/fmt/xp/fl_DocListener.cpp:340:		case PX_ChangeRecord_Glob::PXF_UserAtomicEnd:	// TODO to do here.
./text/fmt/xp/fl_DocListener.cpp-341-			bResult = UT_TRUE;
./text/fmt/xp/fl_DocListener.cpp-342-			goto finish_up;
./text/fmt/xp/fl_DocListener.cpp-343-		}
./text/fmt/xp/fl_DocListener.cpp-344-	}
./text/fmt/xp/fl_DocListener.cpp-345-			

./text/fmt/xp/fl_DocListener.cpp-450-	{
./text/fmt/xp/fl_DocListener.cpp-451-		const PX_ChangeRecord_StruxChange * pcrxc = static_cast<const PX_ChangeRecord_StruxChange *> (pcr);
./text/fmt/xp/fl_DocListener.cpp-452-
./text/fmt/xp/fl_DocListener.cpp-453-		fl_Layout * pL = (fl_Layout *)sfh;
./text/fmt/xp/fl_DocListener.cpp-454-
./text/fmt/xp/fl_DocListener.cpp:455:		// TODO getOldIndexAP() is only intended for use by the document.
./text/fmt/xp/fl_DocListener.cpp:456:		// TODO this assert is probably wrong. --- BUT EVERYTIME IT HAS
./text/fmt/xp/fl_DocListener.cpp:457:		// TODO GONE OFF, I'VE FOUND A BUG, SO MAYBE WE SHOULD KEEP IT :-)
./text/fmt/xp/fl_DocListener.cpp-458-		UT_ASSERT(pL->getAttrPropIndex() == pcrxc->getOldIndexAP());
./text/fmt/xp/fl_DocListener.cpp-459-		UT_ASSERT(pL->getAttrPropIndex() != pcr->getIndexAP());
./text/fmt/xp/fl_DocListener.cpp-460-
./text/fmt/xp/fl_DocListener.cpp-461-		switch (pL->getType())
./text/fmt/xp/fl_DocListener.cpp-462-		{

./text/fmt/xp/fl_SectionLayout.cpp-49-#include "ut_debugmsg.h"
./text/fmt/xp/fl_SectionLayout.cpp-50-#include "ut_assert.h"
./text/fmt/xp/fl_SectionLayout.cpp-51-#include "ut_units.h"
./text/fmt/xp/fl_SectionLayout.cpp-52-
./text/fmt/xp/fl_SectionLayout.cpp-53-/*
./text/fmt/xp/fl_SectionLayout.cpp:54:  TODO this file is now really too long.  divide it up
./text/fmt/xp/fl_SectionLayout.cpp-55-  into smaller ones.
./text/fmt/xp/fl_SectionLayout.cpp-56-*/
./text/fmt/xp/fl_SectionLayout.cpp-57-
./text/fmt/xp/fl_SectionLayout.cpp-58-fl_SectionLayout::fl_SectionLayout(FL_DocLayout* pLayout, PL_StruxDocHandle sdh, PT_AttrPropIndex indexAP, UT_uint32 iType)
./text/fmt/xp/fl_SectionLayout.cpp-59-	: fl_Layout(PTX_Section, sdh)

./text/fmt/xp/fl_SectionLayout.cpp-399-	}
./text/fmt/xp/fl_SectionLayout.cpp-400-}
./text/fmt/xp/fl_SectionLayout.cpp-401-
./text/fmt/xp/fl_SectionLayout.cpp-402-void fl_DocSectionLayout::setHdrFtr(UT_uint32 /*iType*/, fl_HdrFtrSectionLayout* pHFSL)
./text/fmt/xp/fl_SectionLayout.cpp-403-{
./text/fmt/xp/fl_SectionLayout.cpp:404:	// TODO use the type
./text/fmt/xp/fl_SectionLayout.cpp-405-	
./text/fmt/xp/fl_SectionLayout.cpp-406-	const char* pszID = pHFSL->getAttribute("id");
./text/fmt/xp/fl_SectionLayout.cpp-407-
./text/fmt/xp/fl_SectionLayout.cpp-408-	const char* pszAtt = NULL;
./text/fmt/xp/fl_SectionLayout.cpp-409-

./text/fmt/xp/fl_SectionLayout.cpp-727-
./text/fmt/xp/fl_SectionLayout.cpp-728-	m_pFirstColumn = NULL;
./text/fmt/xp/fl_SectionLayout.cpp-729-	m_pLastColumn = NULL;
./text/fmt/xp/fl_SectionLayout.cpp-730-
./text/fmt/xp/fl_SectionLayout.cpp-731-	/*
./text/fmt/xp/fl_SectionLayout.cpp:732:	  TODO to more closely mirror the architecture we're using for BlockLayout, this code
./text/fmt/xp/fl_SectionLayout.cpp-733-	  should probably just set a flag, indicating the need to reformat this section.  Then,
./text/fmt/xp/fl_SectionLayout.cpp-734-	  when it's time to update everything, we'll actually do the format.
./text/fmt/xp/fl_SectionLayout.cpp-735-	*/
./text/fmt/xp/fl_SectionLayout.cpp-736-	
./text/fmt/xp/fl_SectionLayout.cpp-737-	format();

./text/fmt/xp/fl_SectionLayout.cpp-750-	const PP_AttrProp* pSectionAP = NULL;
./text/fmt/xp/fl_SectionLayout.cpp-751-	
./text/fmt/xp/fl_SectionLayout.cpp-752-	m_pLayout->getDocument()->getAttrProp(m_apIndex, &pSectionAP);
./text/fmt/xp/fl_SectionLayout.cpp-753-
./text/fmt/xp/fl_SectionLayout.cpp-754-	/*
./text/fmt/xp/fl_SectionLayout.cpp:755:	  TODO shouldn't we be using PP_evalProperty like
./text/fmt/xp/fl_SectionLayout.cpp-756-	  the blockLayout does?
./text/fmt/xp/fl_SectionLayout.cpp-757-
./text/fmt/xp/fl_SectionLayout.cpp-758-	  Yes, since PP_evalProperty does a fallback to the
./text/fmt/xp/fl_SectionLayout.cpp-759-	  last-chance defaults, whereas the code below is
./text/fmt/xp/fl_SectionLayout.cpp-760-	  hard-coding its own defaults.  Bad idea.

./text/fmt/xp/fl_SectionLayout.cpp-842-
./text/fmt/xp/fl_SectionLayout.cpp-843-	case DIM_PT:
./text/fmt/xp/fl_SectionLayout.cpp-844-		strcpy(defaultMargin, "72.0pt");
./text/fmt/xp/fl_SectionLayout.cpp-845-		break;
./text/fmt/xp/fl_SectionLayout.cpp-846-
./text/fmt/xp/fl_SectionLayout.cpp:847:		// TODO: MM, PX, and PERCENT
./text/fmt/xp/fl_SectionLayout.cpp-848-		// let them fall through to the default now
./text/fmt/xp/fl_SectionLayout.cpp-849-		// and we don't use them anyway
./text/fmt/xp/fl_SectionLayout.cpp-850-#if 0
./text/fmt/xp/fl_SectionLayout.cpp-851-	case DIM_MM:
./text/fmt/xp/fl_SectionLayout.cpp-852-	case DIM_PX:
./text/fmt/xp/fl_SectionLayout.cpp-853-	case DIM_PERCENT:
./text/fmt/xp/fl_SectionLayout.cpp-854-#endif
./text/fmt/xp/fl_SectionLayout.cpp-855-	case DIM_none:
./text/fmt/xp/fl_SectionLayout.cpp-856-	default:
./text/fmt/xp/fl_SectionLayout.cpp:857:		strcpy(defaultMargin, "1.0in");	// TODO: what to do with this.
./text/fmt/xp/fl_SectionLayout.cpp-858-		break;
./text/fmt/xp/fl_SectionLayout.cpp-859-
./text/fmt/xp/fl_SectionLayout.cpp-860-	}
./text/fmt/xp/fl_SectionLayout.cpp-861-
./text/fmt/xp/fl_SectionLayout.cpp-862-	if(pszLeftMargin && pszLeftMargin[0])

./text/fmt/xp/fl_SectionLayout.cpp-1024-	UT_ASSERT(pcrx->getStruxType()==PTX_Section);
./text/fmt/xp/fl_SectionLayout.cpp-1025-
./text/fmt/xp/fl_SectionLayout.cpp-1026-	fl_DocSectionLayout* pPrevSL = getPrevDocSection();
./text/fmt/xp/fl_SectionLayout.cpp-1027-	if (!pPrevSL)
./text/fmt/xp/fl_SectionLayout.cpp-1028-	{
./text/fmt/xp/fl_SectionLayout.cpp:1029:		// TODO shouldn't this just assert?
./text/fmt/xp/fl_SectionLayout.cpp-1030-		UT_DEBUGMSG(("no prior SectionLayout"));
./text/fmt/xp/fl_SectionLayout.cpp-1031-		return UT_FALSE;
./text/fmt/xp/fl_SectionLayout.cpp-1032-	}
./text/fmt/xp/fl_SectionLayout.cpp-1033-	
./text/fmt/xp/fl_SectionLayout.cpp-1034-	// clear all the columns

./text/fmt/xp/fl_SectionLayout.cpp-1097-	if (pView)
./text/fmt/xp/fl_SectionLayout.cpp-1098-	{
./text/fmt/xp/fl_SectionLayout.cpp-1099-		pView->_setPoint(pcrx->getPosition());
./text/fmt/xp/fl_SectionLayout.cpp-1100-	}
./text/fmt/xp/fl_SectionLayout.cpp-1101-
./text/fmt/xp/fl_SectionLayout.cpp:1102:	delete this;			// TODO whoa!  this construct is VERY dangerous.
./text/fmt/xp/fl_SectionLayout.cpp-1103-	
./text/fmt/xp/fl_SectionLayout.cpp-1104-	return UT_TRUE;
./text/fmt/xp/fl_SectionLayout.cpp-1105-}
./text/fmt/xp/fl_SectionLayout.cpp-1106-
./text/fmt/xp/fl_SectionLayout.cpp-1107-void fl_DocSectionLayout::addOwnedPage(fp_Page* pPage)
./text/fmt/xp/fl_SectionLayout.cpp-1108-{
./text/fmt/xp/fl_SectionLayout.cpp:1109:	// TODO do we really need the vecOwnedPages member? YES!!!
./text/fmt/xp/fl_SectionLayout.cpp-1110-
./text/fmt/xp/fl_SectionLayout.cpp-1111-        if(m_pFirstOwnedPage == NULL)
./text/fmt/xp/fl_SectionLayout.cpp-1112-	        m_pFirstOwnedPage = pPage;
./text/fmt/xp/fl_SectionLayout.cpp-1113-	fp_Page * pPrev = m_pFirstOwnedPage;
./text/fmt/xp/fl_SectionLayout.cpp-1114-

./text/fmt/xp/fl_SectionLayout.cpp-1152-}
./text/fmt/xp/fl_SectionLayout.cpp-1153-
./text/fmt/xp/fl_SectionLayout.cpp-1154-	
./text/fmt/xp/fl_SectionLayout.cpp-1155-void fl_DocSectionLayout::deleteOwnedPage(fp_Page* pPage)
./text/fmt/xp/fl_SectionLayout.cpp-1156-{
./text/fmt/xp/fl_SectionLayout.cpp:1157:	// TODO do we really need the vecOwnedPages member?
./text/fmt/xp/fl_SectionLayout.cpp-1158-	
./text/fmt/xp/fl_SectionLayout.cpp-1159-	if (m_pHeaderSL)
./text/fmt/xp/fl_SectionLayout.cpp-1160-	{
./text/fmt/xp/fl_SectionLayout.cpp-1161-		m_pHeaderSL->deletePage(pPage);
./text/fmt/xp/fl_SectionLayout.cpp-1162-	}

./text/fmt/xp/fl_SectionLayout.cpp-1210-					/*
./text/fmt/xp/fl_SectionLayout.cpp-1211-					  Wow!  The very first line in this column won't fit.
./text/fmt/xp/fl_SectionLayout.cpp-1212-					  
./text/fmt/xp/fl_SectionLayout.cpp-1213-					  Big line.  (or maybe a small column)
./text/fmt/xp/fl_SectionLayout.cpp-1214-					  
./text/fmt/xp/fl_SectionLayout.cpp:1215:					  TODO what should we do here?  For now, we force it.
./text/fmt/xp/fl_SectionLayout.cpp-1216-					*/
./text/fmt/xp/fl_SectionLayout.cpp-1217-					pLastLineToKeep = pFirstLineToKeep;
./text/fmt/xp/fl_SectionLayout.cpp-1218-				}
./text/fmt/xp/fl_SectionLayout.cpp-1219-				else
./text/fmt/xp/fl_SectionLayout.cpp-1220-				{

./text/fmt/xp/fl_SectionLayout.cpp-1408-		pCurColumn->layout();
./text/fmt/xp/fl_SectionLayout.cpp-1409-
./text/fmt/xp/fl_SectionLayout.cpp-1410-		pCurColumn = pCurColumn->getNext();
./text/fmt/xp/fl_SectionLayout.cpp-1411-	}
./text/fmt/xp/fl_SectionLayout.cpp-1412-
./text/fmt/xp/fl_SectionLayout.cpp:1413:	return 0; // TODO return code
./text/fmt/xp/fl_SectionLayout.cpp-1414-}
./text/fmt/xp/fl_SectionLayout.cpp-1415-
./text/fmt/xp/fl_SectionLayout.cpp-1416-void fl_DocSectionLayout::checkAndAdjustColumnGap(UT_sint32 iLayoutWidth)
./text/fmt/xp/fl_SectionLayout.cpp-1417-{
./text/fmt/xp/fl_SectionLayout.cpp-1418-	// Check to make sure column gap is not to wide to fit on the page with the
./text/fmt/xp/fl_SectionLayout.cpp-1419-	// given number of columns.
./text/fmt/xp/fl_SectionLayout.cpp-1420-
./text/fmt/xp/fl_SectionLayout.cpp-1421-	if(m_iNumColumns > 1)
./text/fmt/xp/fl_SectionLayout.cpp-1422-	{
./text/fmt/xp/fl_SectionLayout.cpp:1423:		UT_sint32 minColumnWidth = m_pLayout->getGraphics()->convertDimension("0.5in");	//TODO should this dimension be hard coded.
./text/fmt/xp/fl_SectionLayout.cpp-1424-		UT_sint32 iColWidth = (iLayoutWidth - (UT_sint32)(((m_iNumColumns - 1) * m_iColumnGap))) / (UT_sint32)m_iNumColumns;
./text/fmt/xp/fl_SectionLayout.cpp-1425-
./text/fmt/xp/fl_SectionLayout.cpp-1426-		if(iColWidth < minColumnWidth)
./text/fmt/xp/fl_SectionLayout.cpp-1427-		{
./text/fmt/xp/fl_SectionLayout.cpp-1428-			m_iColumnGap = (iLayoutWidth - minColumnWidth * m_iNumColumns) / (m_iNumColumns - 1);

./text/fmt/xp/fl_SectionLayout.cpp-1634-{
./text/fmt/xp/fl_SectionLayout.cpp-1635-	UT_ASSERT(0 > _findShadow(pPage));
./text/fmt/xp/fl_SectionLayout.cpp-1636-	if(_findShadow(pPage) > 0)
./text/fmt/xp/fl_SectionLayout.cpp-1637-	       return;
./text/fmt/xp/fl_SectionLayout.cpp-1638-	struct _PageHdrFtrShadowPair* pPair = new _PageHdrFtrShadowPair;
./text/fmt/xp/fl_SectionLayout.cpp:1639:	// TODO outofmem
./text/fmt/xp/fl_SectionLayout.cpp-1640-
./text/fmt/xp/fl_SectionLayout.cpp-1641-	pPair->pPage = pPage;
./text/fmt/xp/fl_SectionLayout.cpp-1642-	pPair->pShadow = new fl_HdrFtrShadow(m_pLayout, pPage, this, m_sdh, m_apIndex);
./text/fmt/xp/fl_SectionLayout.cpp-1643-	
./text/fmt/xp/fl_SectionLayout.cpp-1644-	fl_ShadowListener* pShadowListener = new fl_ShadowListener(this, pPair->pShadow);

./text/fmt/xp/fl_SectionLayout.cpp-1719-{
./text/fmt/xp/fl_SectionLayout.cpp-1720-	UT_ASSERT(pcrxc->getType()==PX_ChangeRecord::PXT_ChangeStrux);
./text/fmt/xp/fl_SectionLayout.cpp-1721-
./text/fmt/xp/fl_SectionLayout.cpp-1722-	setAttrPropIndex(pcrxc->getIndexAP());
./text/fmt/xp/fl_SectionLayout.cpp-1723-
./text/fmt/xp/fl_SectionLayout.cpp:1724:	// TODO what happens here?
./text/fmt/xp/fl_SectionLayout.cpp-1725-
./text/fmt/xp/fl_SectionLayout.cpp-1726-	UT_ASSERT(UT_SHOULD_NOT_HAPPEN);
./text/fmt/xp/fl_SectionLayout.cpp-1727-
./text/fmt/xp/fl_SectionLayout.cpp-1728-	return UT_FALSE;
./text/fmt/xp/fl_SectionLayout.cpp-1729-}

./text/fmt/xp/fl_SectionLayout.cpp-1894-									  PL_ListenerId lid,
./text/fmt/xp/fl_SectionLayout.cpp-1895-									  void (* pfnBindHandles)(PL_StruxDocHandle sdhNew,
./text/fmt/xp/fl_SectionLayout.cpp-1896-															  PL_ListenerId lid,
./text/fmt/xp/fl_SectionLayout.cpp-1897-															  PL_StruxFmtHandle sfhNew))
./text/fmt/xp/fl_SectionLayout.cpp-1898-{
./text/fmt/xp/fl_SectionLayout.cpp:1899:	// TODO this should NEVER happen, right?
./text/fmt/xp/fl_SectionLayout.cpp-1900-	
./text/fmt/xp/fl_SectionLayout.cpp-1901-	UT_Bool bResult = UT_TRUE;
./text/fmt/xp/fl_SectionLayout.cpp-1902-	UT_uint32 iCount = m_vecPages.getItemCount();
./text/fmt/xp/fl_SectionLayout.cpp-1903-	for (UT_uint32 i=0; i<iCount; i++)
./text/fmt/xp/fl_SectionLayout.cpp-1904-	{

./text/fmt/xp/fl_SectionLayout.cpp-2122-{
./text/fmt/xp/fl_SectionLayout.cpp-2123-	UT_ASSERT(pcrxc->getType()==PX_ChangeRecord::PXT_ChangeStrux);
./text/fmt/xp/fl_SectionLayout.cpp-2124-
./text/fmt/xp/fl_SectionLayout.cpp-2125-	setAttrPropIndex(pcrxc->getIndexAP());
./text/fmt/xp/fl_SectionLayout.cpp-2126-
./text/fmt/xp/fl_SectionLayout.cpp:2127:	// TODO
./text/fmt/xp/fl_SectionLayout.cpp-2128-
./text/fmt/xp/fl_SectionLayout.cpp-2129-	UT_ASSERT(UT_SHOULD_NOT_HAPPEN);
./text/fmt/xp/fl_SectionLayout.cpp-2130-
./text/fmt/xp/fl_SectionLayout.cpp-2131-	return UT_FALSE;
./text/fmt/xp/fl_SectionLayout.cpp-2132-}

./text/fmt/xp/fl_SectionLayout.cpp-2263-				if (
./text/fmt/xp/fl_SectionLayout.cpp-2264-					(0 == UT_strcmp(pszSectionType, "header"))
./text/fmt/xp/fl_SectionLayout.cpp-2265-					|| (0 == UT_strcmp(pszSectionType, "footer"))
./text/fmt/xp/fl_SectionLayout.cpp-2266-					)
./text/fmt/xp/fl_SectionLayout.cpp-2267-				{
./text/fmt/xp/fl_SectionLayout.cpp:2268:					// TODO verify id match
./text/fmt/xp/fl_SectionLayout.cpp-2269-					
./text/fmt/xp/fl_SectionLayout.cpp-2270-					m_bListening = UT_TRUE;
./text/fmt/xp/fl_SectionLayout.cpp-2271-				}
./text/fmt/xp/fl_SectionLayout.cpp-2272-				else
./text/fmt/xp/fl_SectionLayout.cpp-2273-				{

./text/fmt/xp/fl_SectionLayout.cpp-2275-				}
./text/fmt/xp/fl_SectionLayout.cpp-2276-			}
./text/fmt/xp/fl_SectionLayout.cpp-2277-		}
./text/fmt/xp/fl_SectionLayout.cpp-2278-		else
./text/fmt/xp/fl_SectionLayout.cpp-2279-		{
./text/fmt/xp/fl_SectionLayout.cpp:2280:			// TODO fail?
./text/fmt/xp/fl_SectionLayout.cpp-2281-			return UT_FALSE;
./text/fmt/xp/fl_SectionLayout.cpp-2282-		}
./text/fmt/xp/fl_SectionLayout.cpp-2283-	}
./text/fmt/xp/fl_SectionLayout.cpp-2284-	break;
./text/fmt/xp/fl_SectionLayout.cpp-2285-

./text/fmt/xp/fl_SectionLayout.cpp-2297-
./text/fmt/xp/fl_SectionLayout.cpp-2298-			m_pCurrentBL = pBL;	
./text/fmt/xp/fl_SectionLayout.cpp-2299-			*psfh = (PL_StruxFmtHandle)pBL;
./text/fmt/xp/fl_SectionLayout.cpp-2300-		}
./text/fmt/xp/fl_SectionLayout.cpp-2301-		
./text/fmt/xp/fl_SectionLayout.cpp:2302:#if 0		// TODO are we spell-checking headers and footers?
./text/fmt/xp/fl_SectionLayout.cpp-2303-		
./text/fmt/xp/fl_SectionLayout.cpp-2304-		// BUGBUG: this is *not* thread-safe, but should work for now
./text/fmt/xp/fl_SectionLayout.cpp-2305-		if (m_bScreen)
./text/fmt/xp/fl_SectionLayout.cpp-2306-			m_pLayout->queueBlockForBackgroundCheck(bgcrSpelling, pBL);
./text/fmt/xp/fl_SectionLayout.cpp-2307-#endif

./text/fmt/xp/fp_Column.cpp-64-		return;
./text/fmt/xp/fp_Column.cpp-65-	}
./text/fmt/xp/fp_Column.cpp-66-	
./text/fmt/xp/fp_Column.cpp-67-	m_iWidth = iWidth;
./text/fmt/xp/fp_Column.cpp-68-
./text/fmt/xp/fp_Column.cpp:69:	// TODO we really need to force a re-line-break operation on every block herein
./text/fmt/xp/fp_Column.cpp-70-
./text/fmt/xp/fp_Column.cpp-71-//	UT_ASSERT(UT_NOT_IMPLEMENTED);
./text/fmt/xp/fp_Column.cpp-72-}
./text/fmt/xp/fp_Column.cpp-73-
./text/fmt/xp/fp_Column.cpp-74-void fp_Container::setWidthInLayoutUnits(UT_sint32 iWidth)

./text/fmt/xp/fp_Column.cpp-171-	UT_sint32 count = m_vecLines.getItemCount();
./text/fmt/xp/fp_Column.cpp-172-	UT_sint32 ndx = m_vecLines.findItem(pAfterLine);
./text/fmt/xp/fp_Column.cpp-173-	UT_ASSERT( (count > 0) || (ndx == -1) );
./text/fmt/xp/fp_Column.cpp-174-	
./text/fmt/xp/fp_Column.cpp-175-	/*
./text/fmt/xp/fp_Column.cpp:176:	  TODO this routine should not be allowing pAfterLine to be NULL.
./text/fmt/xp/fp_Column.cpp-177-	  Right now, we've fixed the symptom, but we really should fix
./text/fmt/xp/fp_Column.cpp-178-	  the problem.  */
./text/fmt/xp/fp_Column.cpp-179-	UT_ASSERT(ndx >= 0);
./text/fmt/xp/fp_Column.cpp-180-
./text/fmt/xp/fp_Column.cpp-181-	if ( (ndx+1) == count )				// append after last line in vector

./text/fmt/xp/fp_Column.cpp-182-		m_vecLines.addItem(pNewLine);
./text/fmt/xp/fp_Column.cpp-183-	else if (ndx >= 0)					// append after this item within the vector
./text/fmt/xp/fp_Column.cpp-184-		m_vecLines.insertItemAt(pNewLine, ndx+1);
./text/fmt/xp/fp_Column.cpp-185-	else
./text/fmt/xp/fp_Column.cpp-186-	{
./text/fmt/xp/fp_Column.cpp:187:		// TODO remove this....
./text/fmt/xp/fp_Column.cpp-188-		m_vecLines.insertItemAt(pNewLine, 0);
./text/fmt/xp/fp_Column.cpp-189-	}
./text/fmt/xp/fp_Column.cpp-190-
./text/fmt/xp/fp_Column.cpp-191-	pNewLine->setContainer(this);
./text/fmt/xp/fp_Column.cpp-192-	pNewLine->recalcMaxWidth();

./text/fmt/xp/fp_Column.cpp-307-					return;
./text/fmt/xp/fp_Column.cpp-308-				}
./text/fmt/xp/fp_Column.cpp-309-			}
./text/fmt/xp/fp_Column.cpp-310-		}
./text/fmt/xp/fp_Column.cpp-311-
./text/fmt/xp/fp_Column.cpp:312:		// TODO it might be better to move these special cases outside the loop
./text/fmt/xp/fp_Column.cpp-313-		if ((i == 0) && (y < pLine->getY()))
./text/fmt/xp/fp_Column.cpp-314-		{
./text/fmt/xp/fp_Column.cpp-315-			pLine->mapXYToPosition(x - pLine->getX(), y - pLine->getY(), pos, bBOL, bEOL);
./text/fmt/xp/fp_Column.cpp-316-
./text/fmt/xp/fp_Column.cpp-317-			UT_ASSERT(bEOL == UT_TRUE || bEOL == UT_FALSE);

./text/fmt/xp/fp_Column.cpp-329-			
./text/fmt/xp/fp_Column.cpp-330-			return;
./text/fmt/xp/fp_Column.cpp-331-		}
./text/fmt/xp/fp_Column.cpp-332-	}
./text/fmt/xp/fp_Column.cpp-333-
./text/fmt/xp/fp_Column.cpp:334:	// TODO pick the closest line
./text/fmt/xp/fp_Column.cpp-335-	UT_ASSERT(UT_NOT_IMPLEMENTED);
./text/fmt/xp/fp_Column.cpp-336-}
./text/fmt/xp/fp_Column.cpp-337-
./text/fmt/xp/fp_Column.cpp-338-UT_uint32 fp_Container::distanceFromPoint(UT_sint32 x, UT_sint32 y)
./text/fmt/xp/fp_Column.cpp-339-{

./text/fmt/xp/fp_Column.cpp-583-		iY += iLineHeight;
./text/fmt/xp/fp_Column.cpp-584-		iY += iLineMarginAfter;
./text/fmt/xp/fp_Column.cpp-585-	}
./text/fmt/xp/fp_Column.cpp-586-
./text/fmt/xp/fp_Column.cpp-587-	// note that the height of a HdrFtr container never changes.
./text/fmt/xp/fp_Column.cpp:588:	// TODO deal with overflow of this container.  clip.
./text/fmt/xp/fp_Column.cpp-589-}
./text/fmt/xp/fp_Column.cpp-590-
./text/fmt/xp/fp_Column.cpp-591-fl_HdrFtrSectionLayout* fp_HdrFtrContainer::getHdrFtrSectionLayout(void) const
./text/fmt/xp/fp_Column.cpp-592-{
./text/fmt/xp/fp_Column.cpp-593-	UT_ASSERT(m_pSectionLayout->getType() == FL_SECTION_HDRFTR);

./text/fmt/xp/fp_FmtMarkRun.cpp-51-
./text/fmt/xp/fp_FmtMarkRun.cpp-52-void fp_FmtMarkRun::lookupProperties(void)
./text/fmt/xp/fp_FmtMarkRun.cpp-53-{
./text/fmt/xp/fp_FmtMarkRun.cpp-54-	const PP_AttrProp * pSpanAP = NULL;
./text/fmt/xp/fp_FmtMarkRun.cpp-55-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fp_FmtMarkRun.cpp:56:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance?
./text/fmt/xp/fp_FmtMarkRun.cpp-57-	
./text/fmt/xp/fp_FmtMarkRun.cpp-58-	m_pBL->getSpanAttrProp(m_iOffsetFirst,UT_TRUE,&pSpanAP);
./text/fmt/xp/fp_FmtMarkRun.cpp-59-	m_pBL->getAttrProp(&pBlockAP);
./text/fmt/xp/fp_FmtMarkRun.cpp-60-
./text/fmt/xp/fp_FmtMarkRun.cpp-61-	// look for fonts in this DocLayout's font cache

./text/fmt/xp/fp_Line.cpp-556-
./text/fmt/xp/fp_Line.cpp-557-	UT_sint32 iX			= iStartX;
./text/fmt/xp/fp_Line.cpp-558-	UT_sint32 iXLayoutUnits	= iStartXLayoutUnits;
./text/fmt/xp/fp_Line.cpp-559-	UT_Bool bLineErased		= UT_FALSE;
./text/fmt/xp/fp_Line.cpp-560-
./text/fmt/xp/fp_Line.cpp:561:	// TODO do we need to do this if iMoveOver is zero ??
./text/fmt/xp/fp_Line.cpp-562-	for (UT_uint32 i=0; i<iCountRuns; ++i)
./text/fmt/xp/fp_Line.cpp-563-	{
./text/fmt/xp/fp_Line.cpp-564-		fp_Run* pRun = (fp_Run*) m_vecRuns.getNthItem(i);
./text/fmt/xp/fp_Line.cpp-565-		if(!bLineErased && iX != pRun->getX())
./text/fmt/xp/fp_Line.cpp-566-			{

./text/fmt/xp/fp_Line.cpp-1039-
./text/fmt/xp/fp_Line.cpp-1040-			UT_Bool bRes = findNextTabStop(iX, iPos, iTabType, iTabLeader);
./text/fmt/xp/fp_Line.cpp-1041-			UT_ASSERT(bRes);
./text/fmt/xp/fp_Line.cpp-1042-			UT_ASSERT(iTabType == FL_TAB_LEFT);
./text/fmt/xp/fp_Line.cpp-1043-
./text/fmt/xp/fp_Line.cpp:1044:			// TODO -- support all the tabs  shack@uiuc.edu
./text/fmt/xp/fp_Line.cpp-1045-
./text/fmt/xp/fp_Line.cpp-1046-			fp_TabRun* pTabRun = static_cast<fp_TabRun*>(pRun);
./text/fmt/xp/fp_Line.cpp-1047-			pTabRun->setWidth(iPos - iX);
./text/fmt/xp/fp_Line.cpp-1048-			
./text/fmt/xp/fp_Line.cpp-1049-			iX = iPos;

./text/fmt/xp/fp_Line.cpp-1179-		fp_Run* pRun = (fp_Run*) m_vecRuns.getNthItem(i);
./text/fmt/xp/fp_Line.cpp-1180-		
./text/fmt/xp/fp_Line.cpp-1181-		if (pRun->getType() == FPRUN_TAB)
./text/fmt/xp/fp_Line.cpp-1182-		{
./text/fmt/xp/fp_Line.cpp-1183-			//			UT_ASSERT(UT_FALSE);
./text/fmt/xp/fp_Line.cpp:1184:			UT_DEBUGMSG(("TODO - decide if tab is a space \n"));
./text/fmt/xp/fp_Line.cpp:1185:			// TODO: decide if a tab is a space.
./text/fmt/xp/fp_Line.cpp-1186-
./text/fmt/xp/fp_Line.cpp-1187-		}
./text/fmt/xp/fp_Line.cpp-1188-		else if (pRun->getType() == FPRUN_TEXT)
./text/fmt/xp/fp_Line.cpp-1189-		{
./text/fmt/xp/fp_Line.cpp-1190-			fp_TextRun* pTR = static_cast<fp_TextRun *>(pRun);

./text/fmt/xp/fp_Page.cpp-332-	while (i < count)
./text/fmt/xp/fp_Page.cpp-333-	{
./text/fmt/xp/fp_Page.cpp-334-		// fp_Column* pLeader = getNthColumnLeader(i);
./text/fmt/xp/fp_Page.cpp-335-		// fl_DocSectionLayout* pSL = pLeader->getDocSectionLayout();
./text/fmt/xp/fp_Page.cpp-336-
./text/fmt/xp/fp_Page.cpp:337:		UT_ASSERT(UT_TODO);
./text/fmt/xp/fp_Page.cpp-338-		
./text/fmt/xp/fp_Page.cpp-339-		i++;
./text/fmt/xp/fp_Page.cpp-340-	}
./text/fmt/xp/fp_Page.cpp-341-}
./text/fmt/xp/fp_Page.cpp-342-

./text/fmt/xp/fp_Page.cpp-524-	if (m_pHeader)
./text/fmt/xp/fp_Page.cpp-525-	{
./text/fmt/xp/fp_Page.cpp-526-		return m_pHeader;
./text/fmt/xp/fp_Page.cpp-527-	}
./text/fmt/xp/fp_Page.cpp-528-
./text/fmt/xp/fp_Page.cpp:529:	// TODO fix these coordinates
./text/fmt/xp/fp_Page.cpp-530-	m_pHeader = new fp_HdrFtrContainer(m_pOwner->getLeftMargin(),
./text/fmt/xp/fp_Page.cpp-531-									   0,
./text/fmt/xp/fp_Page.cpp-532-									   getWidth() - (m_pOwner->getLeftMargin() + m_pOwner->getRightMargin()),
./text/fmt/xp/fp_Page.cpp-533-									   m_pOwner->getTopMargin(),
./text/fmt/xp/fp_Page.cpp-534-									   getWidthInLayoutUnits() - (m_pOwner->getLeftMarginInLayoutUnits() + m_pOwner->getRightMarginInLayoutUnits()),
./text/fmt/xp/fp_Page.cpp-535-									   m_pOwner->getTopMarginInLayoutUnits(),
./text/fmt/xp/fp_Page.cpp-536-									   pHFSL);
./text/fmt/xp/fp_Page.cpp:537:	// TODO outofmem
./text/fmt/xp/fp_Page.cpp-538-
./text/fmt/xp/fp_Page.cpp-539-	m_pHeader->setPage(this);
./text/fmt/xp/fp_Page.cpp-540-
./text/fmt/xp/fp_Page.cpp-541-	return m_pHeader;
./text/fmt/xp/fp_Page.cpp-542-}

./text/fmt/xp/fp_Page.cpp-546-	if (m_pFooter)
./text/fmt/xp/fp_Page.cpp-547-	{
./text/fmt/xp/fp_Page.cpp-548-		return m_pFooter;
./text/fmt/xp/fp_Page.cpp-549-	}
./text/fmt/xp/fp_Page.cpp-550-
./text/fmt/xp/fp_Page.cpp:551:	// TODO fix these coordinates
./text/fmt/xp/fp_Page.cpp-552-	m_pFooter = new fp_HdrFtrContainer(m_pOwner->getLeftMargin(),
./text/fmt/xp/fp_Page.cpp-553-									   getHeight() - m_pOwner->getBottomMargin(),
./text/fmt/xp/fp_Page.cpp-554-									   getWidth() - (m_pOwner->getLeftMargin() + m_pOwner->getRightMargin()),
./text/fmt/xp/fp_Page.cpp-555-									   m_pOwner->getBottomMargin(),
./text/fmt/xp/fp_Page.cpp-556-									   getWidthInLayoutUnits() - (m_pOwner->getLeftMarginInLayoutUnits() + m_pOwner->getRightMarginInLayoutUnits()),
./text/fmt/xp/fp_Page.cpp-557-									   m_pOwner->getBottomMarginInLayoutUnits(),
./text/fmt/xp/fp_Page.cpp-558-									   pHFSL);
./text/fmt/xp/fp_Page.cpp:559:	// TODO outofmem
./text/fmt/xp/fp_Page.cpp-560-
./text/fmt/xp/fp_Page.cpp-561-	m_pFooter->setPage(this);
./text/fmt/xp/fp_Page.cpp-562-
./text/fmt/xp/fp_Page.cpp-563-	return m_pFooter;
./text/fmt/xp/fp_Page.cpp-564-}

./text/fmt/xp/fp_Run.cpp-39-#include "ut_debugmsg.h"
./text/fmt/xp/fp_Run.cpp-40-#include "ut_assert.h"
./text/fmt/xp/fp_Run.cpp-41-#include "ut_string.h"
./text/fmt/xp/fp_Run.cpp-42-#include "ut_growbuf.h"
./text/fmt/xp/fp_Run.cpp-43-
./text/fmt/xp/fp_Run.cpp:44:// TODO can we use the indexAP provided in the change records
./text/fmt/xp/fp_Run.cpp:45:// TODO to remember the attr/prop for each run rather than
./text/fmt/xp/fp_Run.cpp:46:// TODO looking it up each time we call lookupProperties() -- jeff 4/19/99
./text/fmt/xp/fp_Run.cpp-47-
./text/fmt/xp/fp_Run.cpp-48-
./text/fmt/xp/fp_Run.cpp-49-// findPointCoords:
./text/fmt/xp/fp_Run.cpp-50-//  Can be called to find the position and size of the point (cursor)
./text/fmt/xp/fp_Run.cpp-51-//  for an offset both before, inside and after the Run.

./text/fmt/xp/fp_Run.cpp-59-//  Run, but that would always fail for the 'After' case.
./text/fmt/xp/fp_Run.cpp-60-
./text/fmt/xp/fp_Run.cpp-61-/*****************************************************************/
./text/fmt/xp/fp_Run.cpp-62-
./text/fmt/xp/fp_Run.cpp-63-/*
./text/fmt/xp/fp_Run.cpp:64:  TODO this file is too long -- it needs to be broken
./text/fmt/xp/fp_Run.cpp-65-  up into several pieces.
./text/fmt/xp/fp_Run.cpp-66-*/
./text/fmt/xp/fp_Run.cpp-67-
./text/fmt/xp/fp_Run.cpp-68-fp_Run::fp_Run(fl_BlockLayout* pBL,
./text/fmt/xp/fp_Run.cpp-69-			   GR_Graphics* pG,

./text/fmt/xp/fp_Run.cpp-335-
./text/fmt/xp/fp_Run.cpp-336-void fp_TabRun::lookupProperties(void)
./text/fmt/xp/fp_Run.cpp-337-{
./text/fmt/xp/fp_Run.cpp-338-	const PP_AttrProp * pSpanAP = NULL;
./text/fmt/xp/fp_Run.cpp-339-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fp_Run.cpp:340:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance?
./text/fmt/xp/fp_Run.cpp-341-	
./text/fmt/xp/fp_Run.cpp-342-	m_pBL->getSpanAttrProp(m_iOffsetFirst,UT_FALSE,&pSpanAP);
./text/fmt/xp/fp_Run.cpp-343-	m_pBL->getAttrProp(&pBlockAP);
./text/fmt/xp/fp_Run.cpp-344-        m_pBL->getField(m_iOffsetFirst,m_pField);
./text/fmt/xp/fp_Run.cpp-345-

./text/fmt/xp/fp_Run.cpp-881-				pts[1].x = right;	pts[1].y = top;
./text/fmt/xp/fp_Run.cpp-882-				pts[2].x = right;	pts[2].y = bottom;
./text/fmt/xp/fp_Run.cpp-883-				pts[3].x = left; 	pts[3].y = bottom;
./text/fmt/xp/fp_Run.cpp-884-				pts[4].x = left;	pts[4].y = top;
./text/fmt/xp/fp_Run.cpp-885-				
./text/fmt/xp/fp_Run.cpp:886:				// TODO : remove the hard-coded (but pretty) blue color 
./text/fmt/xp/fp_Run.cpp-887-
./text/fmt/xp/fp_Run.cpp-888-				UT_RGBColor clr(0, 0, 255);
./text/fmt/xp/fp_Run.cpp-889-				m_pG->setColor(clr);
./text/fmt/xp/fp_Run.cpp-890-				m_pG->polyLine(pts, 5);
./text/fmt/xp/fp_Run.cpp-891-				

./text/fmt/xp/fp_Run.cpp-978-
./text/fmt/xp/fp_Run.cpp-979-void fp_FieldRun::lookupProperties(void)
./text/fmt/xp/fp_Run.cpp-980-{
./text/fmt/xp/fp_Run.cpp-981-	const PP_AttrProp * pSpanAP = NULL;
./text/fmt/xp/fp_Run.cpp-982-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fp_Run.cpp:983:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance?
./text/fmt/xp/fp_Run.cpp-984-	
./text/fmt/xp/fp_Run.cpp-985-	m_pBL->getSpanAttrProp(m_iOffsetFirst,UT_FALSE,&pSpanAP);
./text/fmt/xp/fp_Run.cpp-986-	//	UT_DEBUGMSG(("SEVIOR: Doing Lookupprops for block %x run %x  offset =%d \n ",m_pBL,this,m_iOffsetFirst));
./text/fmt/xp/fp_Run.cpp-987-	UT_ASSERT(pSpanAP);
./text/fmt/xp/fp_Run.cpp-988-	PD_Document * pDoc = m_pBL->getDocument();
./text/fmt/xp/fp_Run.cpp-1209-	//if (m_pG->queryProperties(GR_Graphics::DGP_SCREEN))

./text/fmt/xp/fp_Run.cpp-1210-	{
./text/fmt/xp/fp_Run.cpp-1211-		UT_uint32 iRunBase = m_pBL->getPosition() + m_iOffsetFirst;
./text/fmt/xp/fp_Run.cpp-1212-
./text/fmt/xp/fp_Run.cpp-1213-		/*
./text/fmt/xp/fp_Run.cpp:1214:		  TODO we might want special colors for fields.  We might also
./text/fmt/xp/fp_Run.cpp-1215-		  want the colors to be calculated on the fly instead of
./text/fmt/xp/fp_Run.cpp-1216-		  hard-coded.  See comment above in fp_TextRun::_draw*.
./text/fmt/xp/fp_Run.cpp-1217-		  For now, we are hard-coding a couple of shades of grey,
./text/fmt/xp/fp_Run.cpp-1218-		  with fields always being drawn a little darker than the
./text/fmt/xp/fp_Run.cpp-1219-		  surrounding text.

./text/fmt/xp/fp_TextRun.cpp-69-{
./text/fmt/xp/fp_TextRun.cpp-70-	clearScreen();
./text/fmt/xp/fp_TextRun.cpp-71-	
./text/fmt/xp/fp_TextRun.cpp-72-	const PP_AttrProp * pSpanAP = NULL;
./text/fmt/xp/fp_TextRun.cpp-73-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fp_TextRun.cpp:74:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance?
./text/fmt/xp/fp_TextRun.cpp-75-	m_pBL->getSpanAttrProp(m_iOffsetFirst,UT_FALSE,&pSpanAP);
./text/fmt/xp/fp_TextRun.cpp-76-	m_pBL->getAttrProp(&pBlockAP);
./text/fmt/xp/fp_TextRun.cpp-77-        static_cast<fl_Layout *>(m_pBL)->getField(m_iOffsetFirst,m_pField);
./text/fmt/xp/fp_TextRun.cpp-78-	// look for fonts in this DocLayout's font cache
./text/fmt/xp/fp_TextRun.cpp-79-	FL_DocLayout * pLayout = m_pBL->getDocLayout();

./text/fmt/xp/fp_TextRun.cpp-87-	UT_parseColor(PP_evalProperty("bgcolor",pSpanAP,pBlockAP,pSectionAP, pDoc, UT_TRUE), m_colorBG);
./text/fmt/xp/fp_TextRun.cpp-88-
./text/fmt/xp/fp_TextRun.cpp-89-	const XML_Char *pszDecor = PP_evalProperty("text-decoration",pSpanAP,pBlockAP,pSectionAP, pDoc, UT_TRUE);
./text/fmt/xp/fp_TextRun.cpp-90-
./text/fmt/xp/fp_TextRun.cpp-91-	/*
./text/fmt/xp/fp_TextRun.cpp:92:	  TODO map line width to a property, not a hard-coded value
./text/fmt/xp/fp_TextRun.cpp-93-	*/
./text/fmt/xp/fp_TextRun.cpp-94-	m_iLineWidth = m_pG->convertDimension("0.8pt");
./text/fmt/xp/fp_TextRun.cpp-95-	
./text/fmt/xp/fp_TextRun.cpp-96-	m_fDecorations = 0;
./text/fmt/xp/fp_TextRun.cpp-97-
./text/fmt/xp/fp_TextRun.cpp-98-	XML_Char* p;
./text/fmt/xp/fp_TextRun.cpp-99-	if (!UT_cloneString((char *&)p, pszDecor))
./text/fmt/xp/fp_TextRun.cpp-100-	{
./text/fmt/xp/fp_TextRun.cpp:101:		// TODO outofmem
./text/fmt/xp/fp_TextRun.cpp-102-	}
./text/fmt/xp/fp_TextRun.cpp-103-	UT_ASSERT(p || !pszDecor);
./text/fmt/xp/fp_TextRun.cpp-104-	XML_Char*	q = strtok(p, " ");
./text/fmt/xp/fp_TextRun.cpp-105-
./text/fmt/xp/fp_TextRun.cpp-106-	while (q)

./text/fmt/xp/fp_TextRun.cpp-230-UT_Bool fp_TextRun::alwaysFits(void) const
./text/fmt/xp/fp_TextRun.cpp-231-{
./text/fmt/xp/fp_TextRun.cpp-232-	const UT_UCSChar* pSpan;
./text/fmt/xp/fp_TextRun.cpp-233-	UT_uint32 lenSpan;
./text/fmt/xp/fp_TextRun.cpp-234-
./text/fmt/xp/fp_TextRun.cpp:235:	// TODO we need to fix this code to use getSpanPtr the way it is used elsewhere in this file.
./text/fmt/xp/fp_TextRun.cpp-236-	
./text/fmt/xp/fp_TextRun.cpp-237-	if (m_iLen > 0)
./text/fmt/xp/fp_TextRun.cpp-238-	{
./text/fmt/xp/fp_TextRun.cpp-239-		if (m_pBL->getSpanPtr(m_iOffsetFirst, &pSpan, &lenSpan))
./text/fmt/xp/fp_TextRun.cpp-240-		{

./text/fmt/xp/fp_TextRun.cpp-707-	else
./text/fmt/xp/fp_TextRun.cpp-708-	{
./text/fmt/xp/fp_TextRun.cpp-709-		m_pG->setFont(m_pFont);
./text/fmt/xp/fp_TextRun.cpp-710-		
./text/fmt/xp/fp_TextRun.cpp-711-		/*
./text/fmt/xp/fp_TextRun.cpp:712:		  TODO this should not be hard-coded.  We need to figure out
./text/fmt/xp/fp_TextRun.cpp-713-		  what the appropriate background color for this run is, and
./text/fmt/xp/fp_TextRun.cpp-714-		  use that.  Note that it could vary on a run-by-run basis,
./text/fmt/xp/fp_TextRun.cpp-715-		  since document facilities allow the background color to be
./text/fmt/xp/fp_TextRun.cpp-716-		  changed, for things such as table cells.
./text/fmt/xp/fp_TextRun.cpp-717-		*/

./text/fmt/xp/fp_TextRun.cpp-759-
./text/fmt/xp/fp_TextRun.cpp-760-	m_pG->setFont(m_pFont);
./text/fmt/xp/fp_TextRun.cpp-761-	m_pG->setColor(m_colorFG);
./text/fmt/xp/fp_TextRun.cpp-762-
./text/fmt/xp/fp_TextRun.cpp-763-	/*
./text/fmt/xp/fp_TextRun.cpp:764:	  TODO this should not be hard-coded.  We should calculate an
./text/fmt/xp/fp_TextRun.cpp-765-	  appropriate selection background color based on the color
./text/fmt/xp/fp_TextRun.cpp-766-	  of the foreground text, probably.
./text/fmt/xp/fp_TextRun.cpp-767-	*/
./text/fmt/xp/fp_TextRun.cpp-768-	//UT_RGBColor clrNormalBackground(255,255,255);
./text/fmt/xp/fp_TextRun.cpp-769-	UT_RGBColor clrNormalBackground(m_colorBG.m_red, m_colorBG.m_grn, m_colorBG.m_blu);

./text/fmt/xp/fp_TextRun.cpp-845-	if(pView->getShowPara())
./text/fmt/xp/fp_TextRun.cpp-846-	{
./text/fmt/xp/fp_TextRun.cpp-847-                _drawInvisibles(pDA->xoff, yTopOfRun);
./text/fmt/xp/fp_TextRun.cpp-848-	}
./text/fmt/xp/fp_TextRun.cpp-849-
./text/fmt/xp/fp_TextRun.cpp:850:	// TODO: draw this underneath (ie, before) the text and decorations
./text/fmt/xp/fp_TextRun.cpp-851-	m_bSquiggled = UT_FALSE;
./text/fmt/xp/fp_TextRun.cpp-852-	m_pBL->findSquigglesForRun(this);
./text/fmt/xp/fp_TextRun.cpp-853-}
./text/fmt/xp/fp_TextRun.cpp-854-
./text/fmt/xp/fp_TextRun.cpp-855-void fp_TextRun::_fillRect(UT_RGBColor& clr,

./text/fmt/xp/fp_TextRun.cpp-905-
./text/fmt/xp/fp_TextRun.cpp-906-	//Should this be an error condition? I treat it as a zero length run, but other might not	
./text/fmt/xp/fp_TextRun.cpp-907-	const UT_uint16 * pCharWidths = pgbCharWidths->getPointer(0);
./text/fmt/xp/fp_TextRun.cpp-908-	UT_ASSERT(pCharWidths);
./text/fmt/xp/fp_TextRun.cpp-909-	if (!pCharWidths) {
./text/fmt/xp/fp_TextRun.cpp:910:		UT_DEBUGMSG(("TODO: Investigate why pCharWidths is NULL?"));
./text/fmt/xp/fp_TextRun.cpp-911-		return;
./text/fmt/xp/fp_TextRun.cpp-912-	}
./text/fmt/xp/fp_TextRun.cpp-913-
./text/fmt/xp/fp_TextRun.cpp-914-	UT_uint32 i;
./text/fmt/xp/fp_TextRun.cpp-915-	if (iStart > m_iOffsetFirst)

./text/fmt/xp/fp_TextRun.cpp-954-
./text/fmt/xp/fp_TextRun.cpp-955-	UT_uint32 iLeftWidth = 0;
./text/fmt/xp/fp_TextRun.cpp-956-	const UT_uint16 * pCharWidths = pgbCharWidths->getPointer(0);
./text/fmt/xp/fp_TextRun.cpp-957-	UT_ASSERT(pCharWidths);
./text/fmt/xp/fp_TextRun.cpp-958-	if (!pCharWidths) {
./text/fmt/xp/fp_TextRun.cpp:959:		UT_DEBUGMSG(("TODO: Investigate why pCharWidths is NULL?"));
./text/fmt/xp/fp_TextRun.cpp-960-		return;
./text/fmt/xp/fp_TextRun.cpp-961-	}
./text/fmt/xp/fp_TextRun.cpp-962-	
./text/fmt/xp/fp_TextRun.cpp-963-	UT_uint32 i;
./text/fmt/xp/fp_TextRun.cpp-964-	for (i=m_iOffsetFirst; i<iStart; i++)

./text/fmt/xp/fp_TextRun.cpp-1282-void fp_TextRun::drawSquiggle(UT_uint32 iOffset, UT_uint32 iLen)
./text/fmt/xp/fp_TextRun.cpp-1283-{
./text/fmt/xp/fp_TextRun.cpp-1284-//	UT_ASSERT(iLen > 0);
./text/fmt/xp/fp_TextRun.cpp-1285-	if (iLen == 0)
./text/fmt/xp/fp_TextRun.cpp-1286-	{
./text/fmt/xp/fp_TextRun.cpp:1287:		// I think this is safe, although it begs the question, why did we get called if iLen is zero?  TODO
./text/fmt/xp/fp_TextRun.cpp-1288-		return;
./text/fmt/xp/fp_TextRun.cpp-1289-	}
./text/fmt/xp/fp_TextRun.cpp-1290-
./text/fmt/xp/fp_TextRun.cpp-1291-	UT_sint32 xoff = 0, yoff = 0;
./text/fmt/xp/fp_TextRun.cpp-1292-	UT_sint32 iAscent = m_pLine->getAscent();

./text/fmt/xp/fv_View.cpp-303-	{
./text/fmt/xp/fv_View.cpp-304-		/*
./text/fmt/xp/fv_View.cpp-305-			The following brute-force solution works, but is atrociously 
./text/fmt/xp/fv_View.cpp-306-			expensive, so we should avoid using it whenever feasible.  
./text/fmt/xp/fv_View.cpp-307-
./text/fmt/xp/fv_View.cpp:308:			TODO: devise special case logic for (at minimum) char motion
./text/fmt/xp/fv_View.cpp-309-		*/
./text/fmt/xp/fv_View.cpp-310-		const XML_Char ** propsChar = NULL;
./text/fmt/xp/fv_View.cpp-311-		getCharFormat(&propsChar);
./text/fmt/xp/fv_View.cpp-312-
./text/fmt/xp/fv_View.cpp-313-		UT_Bool bMatch = UT_FALSE;

./text/fmt/xp/fv_View.cpp-396-	}
./text/fmt/xp/fv_View.cpp-397-
./text/fmt/xp/fv_View.cpp-398-	if (mask & AV_CHG_FMTSTYLE)
./text/fmt/xp/fv_View.cpp-399-	{
./text/fmt/xp/fv_View.cpp-400-		// NOTE: we don't attempt to filter this
./text/fmt/xp/fv_View.cpp:401:		// TODO: we probably should
./text/fmt/xp/fv_View.cpp-402-	}
./text/fmt/xp/fv_View.cpp-403-
./text/fmt/xp/fv_View.cpp-404-	if (mask & AV_CHG_PAGECOUNT)
./text/fmt/xp/fv_View.cpp-405-	{
./text/fmt/xp/fv_View.cpp-406-		// NOTE: we don't attempt to filter this

./text/fmt/xp/fv_View.cpp-641-		UT_ASSERT(bRes);
./text/fmt/xp/fv_View.cpp-642-
./text/fmt/xp/fv_View.cpp-643-		return iPos;
./text/fmt/xp/fv_View.cpp-644-	}
./text/fmt/xp/fv_View.cpp-645-
./text/fmt/xp/fv_View.cpp:646:	// TODO: could cache these to save a lookup if point doesn't change
./text/fmt/xp/fv_View.cpp-647-	fl_BlockLayout* pBlock = _findBlockAtPosition(iPoint);
./text/fmt/xp/fv_View.cpp-648-	fp_Run* pRun = pBlock->findPointCoords(iPoint, m_bPointEOL,
./text/fmt/xp/fv_View.cpp-649-										   xPoint, yPoint, iPointHeight);
./text/fmt/xp/fv_View.cpp-650-	fp_Line* pLine = pRun->getLine();
./text/fmt/xp/fv_View.cpp-651-

./text/fmt/xp/fv_View.cpp-697-// DOM: because after enabling this code, I can no
./text/fmt/xp/fv_View.cpp-698-// DOM: longer reproduce bug 403 (the bug caused by this
./text/fmt/xp/fv_View.cpp-699-// DOM: code being if 0'd) or bug 92 (the bug that if 0'ing
./text/fmt/xp/fv_View.cpp-700-// DOM: this code supposedly fixes)
./text/fmt/xp/fv_View.cpp-701-
./text/fmt/xp/fv_View.cpp:702:// TODO this piece of code attempts to go back
./text/fmt/xp/fv_View.cpp:703:// TODO to the previous block if we are on the
./text/fmt/xp/fv_View.cpp:704:// TODO edge.  this causes bug #92 (double clicking
./text/fmt/xp/fv_View.cpp:705:// TODO on the first line of a paragraph selects
./text/fmt/xp/fv_View.cpp:706:// TODO current paragraph and the previous paragraph).
./text/fmt/xp/fv_View.cpp:707:// TODO i'm not sure why it is here.
./text/fmt/xp/fv_View.cpp:708:// TODO
./text/fmt/xp/fv_View.cpp:709:// TODO it's here because it makes control-up-arrow
./text/fmt/xp/fv_View.cpp:710:// TODO when at the beginning of paragraph work. this
./text/fmt/xp/fv_View.cpp:711:// TODO problem is logged as bug #403.
./text/fmt/xp/fv_View.cpp:712:// TODO
./text/fmt/xp/fv_View.cpp-713-			// are we already there?
./text/fmt/xp/fv_View.cpp-714-			if (iPos == pBlock->getPosition())
./text/fmt/xp/fv_View.cpp-715-			{
./text/fmt/xp/fv_View.cpp-716-				// yep.  is there a prior block?
./text/fmt/xp/fv_View.cpp-717-				if (!pBlock->getPrevBlockInDocument())

./text/fmt/xp/fv_View.cpp-1621-		if (isSelectionEmpty())
./text/fmt/xp/fv_View.cpp-1622-		{
./text/fmt/xp/fv_View.cpp-1623-			_eraseInsertionPoint();
./text/fmt/xp/fv_View.cpp-1624-		}
./text/fmt/xp/fv_View.cpp-1625-
./text/fmt/xp/fv_View.cpp:1626:		_clearIfAtFmtMark(getPoint());	// TODO is this correct ??
./text/fmt/xp/fv_View.cpp-1627-		_eraseSelection();
./text/fmt/xp/fv_View.cpp-1628-
./text/fmt/xp/fv_View.cpp-1629-		bRet = m_pDoc->changeSpanFmt(PTC_AddStyle,posStart,posEnd,attribs,NULL);
./text/fmt/xp/fv_View.cpp-1630-	}
./text/fmt/xp/fv_View.cpp-1631-	else
./text/fmt/xp/fv_View.cpp-1632-	{
./text/fmt/xp/fv_View.cpp-1633-		// set block-level style
./text/fmt/xp/fv_View.cpp-1634-		_eraseInsertionPoint();
./text/fmt/xp/fv_View.cpp-1635-
./text/fmt/xp/fv_View.cpp:1636:		_clearIfAtFmtMark(getPoint());	// TODO is this correct ??
./text/fmt/xp/fv_View.cpp-1637-
./text/fmt/xp/fv_View.cpp-1638-		// NB: clear explicit props at both block and char levels
./text/fmt/xp/fv_View.cpp-1639-		bRet = m_pDoc->changeStruxFmt(PTC_AddStyle,posStart,posEnd,attribs,NULL,PTX_Block);
./text/fmt/xp/fv_View.cpp-1640-	}
./text/fmt/xp/fv_View.cpp-1641-

./text/fmt/xp/fv_View.cpp-1664-	UT_ASSERT(pAP);
./text/fmt/xp/fv_View.cpp-1665-	const XML_Char* sz = NULL;
./text/fmt/xp/fv_View.cpp-1666-
./text/fmt/xp/fv_View.cpp-1667-	pAP->getAttribute(PT_STYLE_ATTRIBUTE_NAME, sz);
./text/fmt/xp/fv_View.cpp-1668-
./text/fmt/xp/fv_View.cpp:1669:	// TODO: should we have an explicit default for char styles? 
./text/fmt/xp/fv_View.cpp-1670-	if (!sz && bBlock)
./text/fmt/xp/fv_View.cpp-1671-		sz = "Normal";
./text/fmt/xp/fv_View.cpp-1672-
./text/fmt/xp/fv_View.cpp-1673-	return sz;
./text/fmt/xp/fv_View.cpp-1674-}

./text/fmt/xp/fv_View.cpp-1760-		UT_uint32 blockPosition = pBlock->getPosition();
./text/fmt/xp/fv_View.cpp-1761-		fp_Run* pRun = pBlock->findPointCoords(posStart, UT_FALSE,
./text/fmt/xp/fv_View.cpp-1762-											   xPoint, yPoint, iPointHeight);
./text/fmt/xp/fv_View.cpp-1763-		UT_Bool bLeftSide = UT_TRUE;
./text/fmt/xp/fv_View.cpp-1764-
./text/fmt/xp/fv_View.cpp:1765:		// TODO consider adding indexAP from change record to the
./text/fmt/xp/fv_View.cpp:1766:		// TODO runs so that we can just use it here.
./text/fmt/xp/fv_View.cpp-1767-
./text/fmt/xp/fv_View.cpp-1768-		if (!bSelEmpty)
./text/fmt/xp/fv_View.cpp-1769-		{
./text/fmt/xp/fv_View.cpp-1770-			// we want the interior of the selection -- and not the
./text/fmt/xp/fv_View.cpp-1771-			// format to the left of the start of the selection.

./text/fmt/xp/fv_View.cpp-1888-
./text/fmt/xp/fv_View.cpp-1889-UT_Bool FV_View::getCharFormat(const XML_Char *** pProps, UT_Bool bExpandStyles)
./text/fmt/xp/fv_View.cpp-1890-{
./text/fmt/xp/fv_View.cpp-1891-	const PP_AttrProp * pSpanAP = NULL;
./text/fmt/xp/fv_View.cpp-1892-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fv_View.cpp:1893:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance
./text/fmt/xp/fv_View.cpp-1894-	UT_Vector v;
./text/fmt/xp/fv_View.cpp-1895-	UT_uint32 i;
./text/fmt/xp/fv_View.cpp-1896-	_fmtPair * f;
./text/fmt/xp/fv_View.cpp-1897-
./text/fmt/xp/fv_View.cpp-1898-	/*

./text/fmt/xp/fv_View.cpp-1922-	UT_uint32 blockPosition = pBlock->getPosition();
./text/fmt/xp/fv_View.cpp-1923-	fp_Run* pRun = pBlock->findPointCoords(posStart, UT_FALSE,
./text/fmt/xp/fv_View.cpp-1924-										   xPoint, yPoint, iPointHeight);
./text/fmt/xp/fv_View.cpp-1925-	UT_Bool bLeftSide = UT_TRUE;
./text/fmt/xp/fv_View.cpp-1926-
./text/fmt/xp/fv_View.cpp:1927:	// TODO consider adding indexAP from change record to the
./text/fmt/xp/fv_View.cpp:1928:	// TODO runs so that we can just use it here.
./text/fmt/xp/fv_View.cpp-1929-
./text/fmt/xp/fv_View.cpp-1930-	if (!bSelEmpty)
./text/fmt/xp/fv_View.cpp-1931-	{
./text/fmt/xp/fv_View.cpp-1932-		// we want the interior of the selection -- and not the
./text/fmt/xp/fv_View.cpp-1933-		// format to the left of the start of the selection.

./text/fmt/xp/fv_View.cpp-2456-}
./text/fmt/xp/fv_View.cpp-2457-
./text/fmt/xp/fv_View.cpp-2458-UT_Bool FV_View::getBlockFormat(const XML_Char *** pProps,UT_Bool bExpandStyles)
./text/fmt/xp/fv_View.cpp-2459-{
./text/fmt/xp/fv_View.cpp-2460-	const PP_AttrProp * pBlockAP = NULL;
./text/fmt/xp/fv_View.cpp:2461:	const PP_AttrProp * pSectionAP = NULL; // TODO do we care about section-level inheritance?
./text/fmt/xp/fv_View.cpp-2462-	UT_Vector v;
./text/fmt/xp/fv_View.cpp-2463-	UT_uint32 i;
./text/fmt/xp/fv_View.cpp-2464-	_fmtPair * f;
./text/fmt/xp/fv_View.cpp-2465-
./text/fmt/xp/fv_View.cpp-2466-	/*

./text/fmt/xp/fv_View.cpp-2820-				bisList = UT_TRUE;
./text/fmt/xp/fv_View.cpp-2821-			}
./text/fmt/xp/fv_View.cpp-2822-
./text/fmt/xp/fv_View.cpp-2823-		}
./text/fmt/xp/fv_View.cpp-2824-	// Code to deal with font boundary problem.
./text/fmt/xp/fv_View.cpp:2825:	// TODO: This should really be fixed by someone who understands
./text/fmt/xp/fv_View.cpp-2826-	// how this code works! In the meantime save current font to be
./text/fmt/xp/fv_View.cpp-2827-	// restored after character is deleted.
./text/fmt/xp/fv_View.cpp-2828-
./text/fmt/xp/fv_View.cpp-2829-		getCharFormat(&props_in);
./text/fmt/xp/fv_View.cpp-2830-		currentfont = UT_getAttribute((XML_Char*)"font-family",props_in);

./text/fmt/xp/fv_View.cpp-2955-	if (bNext)
./text/fmt/xp/fv_View.cpp-2956-	{
./text/fmt/xp/fv_View.cpp-2957-		if (pOldLine != pOldContainer->getLastLine())
./text/fmt/xp/fv_View.cpp-2958-		{
./text/fmt/xp/fv_View.cpp-2959-			// just move off this line
./text/fmt/xp/fv_View.cpp:2960:	// Sevior TODO the +2 is a work around. The problem is somewhere else
./text/fmt/xp/fv_View.cpp-2961-			yPoint += (iLineHeight + pOldLine->getMarginAfter()+2);
./text/fmt/xp/fv_View.cpp-2962-		}
./text/fmt/xp/fv_View.cpp-2963-		else if (bDocSection && (((fp_Column*) (pOldSL->getLastContainer()))->getLeader() == pOldLeader))
./text/fmt/xp/fv_View.cpp-2964-		{
./text/fmt/xp/fv_View.cpp-2965-			// move to next section

./text/fmt/xp/fv_View.cpp-2991-	else
./text/fmt/xp/fv_View.cpp-2992-	{
./text/fmt/xp/fv_View.cpp-2993-		if (pOldLine != pOldContainer->getFirstLine())
./text/fmt/xp/fv_View.cpp-2994-		{
./text/fmt/xp/fv_View.cpp-2995-			// just move off this line
./text/fmt/xp/fv_View.cpp:2996:	// Sevior TODO the +2 is a work around. The problem is somewhere else
./text/fmt/xp/fv_View.cpp-2997-			yPoint -= (pOldLine->getMarginBefore() + 2);
./text/fmt/xp/fv_View.cpp-2998-		}
./text/fmt/xp/fv_View.cpp-2999-		else if (bDocSection && (pOldSL->getFirstContainer() == pOldLeader))
./text/fmt/xp/fv_View.cpp-3000-		{
./text/fmt/xp/fv_View.cpp-3001-			// move to prev section

./text/fmt/xp/fv_View.cpp-3097-		cmdScroll(AV_SCROLLCMD_LINEDOWN, (UT_uint32)(m_yPoint + m_iPointHeight - m_iWindowHeight));
./text/fmt/xp/fv_View.cpp-3098-		bRet = UT_TRUE;
./text/fmt/xp/fv_View.cpp-3099-	}
./text/fmt/xp/fv_View.cpp-3100-
./text/fmt/xp/fv_View.cpp-3101-	/*
./text/fmt/xp/fv_View.cpp:3102:		TODO: we really ought to try to do better than this.
./text/fmt/xp/fv_View.cpp-3103-	*/
./text/fmt/xp/fv_View.cpp-3104-	if (m_xPoint < 0)
./text/fmt/xp/fv_View.cpp-3105-	{
./text/fmt/xp/fv_View.cpp-3106-		cmdScroll(AV_SCROLLCMD_LINELEFT, (UT_uint32) (-(m_xPoint) + fl_PAGEVIEW_MARGIN_X/2));
./text/fmt/xp/fv_View.cpp-3107-		bRet = UT_TRUE;

./text/fmt/xp/fv_View.cpp-3375-	{
./text/fmt/xp/fv_View.cpp-3376-		// not far enough to change the selection ... do we still need to scroll?
./text/fmt/xp/fv_View.cpp-3377-		UT_sint32 xPos = pView->m_xLastMouse;
./text/fmt/xp/fv_View.cpp-3378-		UT_sint32 yPos = pView->m_yLastMouse;
./text/fmt/xp/fv_View.cpp-3379-
./text/fmt/xp/fv_View.cpp:3380:		// TODO: clamp xPos, yPos to viewable area??
./text/fmt/xp/fv_View.cpp-3381-
./text/fmt/xp/fv_View.cpp-3382-		UT_Bool bOnScreen = UT_TRUE;
./text/fmt/xp/fv_View.cpp-3383-
./text/fmt/xp/fv_View.cpp-3384-		if ((xPos < 0 || xPos > pView->m_iWindowWidth) || 
./text/fmt/xp/fv_View.cpp-3385-			(yPos < 0 || yPos > pView->m_iWindowHeight))

./text/fmt/xp/fv_View.cpp-3387-		
./text/fmt/xp/fv_View.cpp-3388-		if (!bOnScreen) 
./text/fmt/xp/fv_View.cpp-3389-		{
./text/fmt/xp/fv_View.cpp-3390-			// yep, do it manually 
./text/fmt/xp/fv_View.cpp-3391- 
./text/fmt/xp/fv_View.cpp:3392:			// TODO currently we blindly send these auto scroll events without regard
./text/fmt/xp/fv_View.cpp:3393:			// TODO to whether the window can scroll any further in that direction.
./text/fmt/xp/fv_View.cpp:3394:			// TODO we could optimize this a bit and check the scroll range before we
./text/fmt/xp/fv_View.cpp:3395:			// TODO fire them, but that knowledge is only stored in the frame and we
./text/fmt/xp/fv_View.cpp:3396:			// TODO don't have a backpointer to it.
./text/fmt/xp/fv_View.cpp-3397-			// UT_DEBUGMSG(("_auto: [xp %ld][yp %ld] [w %ld][h %ld]\n",
./text/fmt/xp/fv_View.cpp-3398-			//			 xPos,yPos,pView->m_iWindowWidth,pView->m_iWindowHeight));
./text/fmt/xp/fv_View.cpp-3399- 
./text/fmt/xp/fv_View.cpp-3400-			if (yPos < 0)
./text/fmt/xp/fv_View.cpp-3401-			{

./text/fmt/xp/fv_View.cpp-3679-		{
./text/fmt/xp/fv_View.cpp-3680-			fp_Page* pOldPage = _getCurrentPage();
./text/fmt/xp/fv_View.cpp-3681-			fp_Page* pPage = pOldPage;
./text/fmt/xp/fv_View.cpp-3682-			fp_Page* pTmpPage = pOldPage;
./text/fmt/xp/fv_View.cpp-3683-
./text/fmt/xp/fv_View.cpp:3684:			if (inc) // TODO:  What if number passes the number of pages?
./text/fmt/xp/fv_View.cpp-3685-				for (UT_uint32 i = 0; i < number; i++)
./text/fmt/xp/fv_View.cpp-3686-				{
./text/fmt/xp/fv_View.cpp-3687-					if ((pTmpPage = pPage->getNext ()) != NULL)
./text/fmt/xp/fv_View.cpp-3688-						pPage = pTmpPage;
./text/fmt/xp/fv_View.cpp-3689-					else
./text/fmt/xp/fv_View.cpp-3757-	
./text/fmt/xp/fv_View.cpp-3758-		notifyListeners(AV_CHG_MOTION);
./text/fmt/xp/fv_View.cpp-3759-		
./text/fmt/xp/fv_View.cpp-3760-		break;
./text/fmt/xp/fv_View.cpp-3761-	case AP_JUMPTARGET_PICTURE:
./text/fmt/xp/fv_View.cpp:3762:		// TODO
./text/fmt/xp/fv_View.cpp-3763-		break;
./text/fmt/xp/fv_View.cpp-3764-	default:
./text/fmt/xp/fv_View.cpp:3765:		// TODO
./text/fmt/xp/fv_View.cpp-3766-		;
./text/fmt/xp/fv_View.cpp-3767-	}
./text/fmt/xp/fv_View.cpp-3768-
./text/fmt/xp/fv_View.cpp-3769-	if (isSelectionEmpty())
./text/fmt/xp/fv_View.cpp-3770-	{
./text/fmt/xp/fv_View.cpp-3809-	{
./text/fmt/xp/fv_View.cpp-3810-		_ensureThatInsertionPointIsOnScreen();
./text/fmt/xp/fv_View.cpp-3811-		_drawSelection();
./text/fmt/xp/fv_View.cpp-3812-	}
./text/fmt/xp/fv_View.cpp-3813-
./text/fmt/xp/fv_View.cpp:3814:	// TODO do we need to do a notifyListeners(AV_CHG_MOTION) ??
./text/fmt/xp/fv_View.cpp-3815-	return bRes;
./text/fmt/xp/fv_View.cpp-3816-}
./text/fmt/xp/fv_View.cpp-3817-
./text/fmt/xp/fv_View.cpp-3818-UT_Bool FV_View::_findNext(const UT_UCSChar * find, UT_Bool matchCase, UT_Bool * bDoneEntireDocument)
./text/fmt/xp/fv_View.cpp-3819-{
./text/fmt/xp/fv_View.cpp-4389-void FV_View::_generalUpdate(void)
./text/fmt/xp/fv_View.cpp-4390-{
./text/fmt/xp/fv_View.cpp-4391-	m_pDoc->signalListeners(PD_SIGNAL_UPDATE_LAYOUT);
./text/fmt/xp/fv_View.cpp-4392-
./text/fmt/xp/fv_View.cpp-4393-	/*
./text/fmt/xp/fv_View.cpp:4394:	  TODO note that we are far too heavy handed with the mask we
./text/fmt/xp/fv_View.cpp-4395-	  send here.  I ripped out all the individual calls to notifyListeners
./text/fmt/xp/fv_View.cpp-4396-	  which appeared within fl_BlockLayout, and they all now go through
./text/fmt/xp/fv_View.cpp-4397-	  here.  For that reason, I made the following mask into the union
./text/fmt/xp/fv_View.cpp-4398-	  of all the masks I found.  I assume that this is inefficient, but
./text/fmt/xp/fv_View.cpp-4399-	  functionally correct.
./text/fmt/xp/fv_View.cpp-4400-
./text/fmt/xp/fv_View.cpp:4401:	  TODO WRONG! WRONG! WRONG! notifyListener() must be called in
./text/fmt/xp/fv_View.cpp:4402:	  TODO WRONG! WRONG! WRONG! fl_BlockLayout in response to a change
./text/fmt/xp/fv_View.cpp:4403:	  TODO WRONG! WRONG! WRONG! notification and not here.  this call
./text/fmt/xp/fv_View.cpp:4404:	  TODO WRONG! WRONG! WRONG! will only update the current window.
./text/fmt/xp/fv_View.cpp:4405:	  TODO WRONG! WRONG! WRONG! having the notification in fl_BlockLayout
./text/fmt/xp/fv_View.cpp:4406:	  TODO WRONG! WRONG! WRONG! will get each view on the document.
./text/fmt/xp/fv_View.cpp-4407-	*/
./text/fmt/xp/fv_View.cpp-4408-	notifyListeners(AV_CHG_TYPING | AV_CHG_FMTCHAR | AV_CHG_FMTBLOCK);
./text/fmt/xp/fv_View.cpp-4409-}
./text/fmt/xp/fv_View.cpp-4410-
./text/fmt/xp/fv_View.cpp-4411-UT_uint32 FV_View::findReplaceAll(const UT_UCSChar * find, const UT_UCSChar * replace,
./text/fmt/xp/fv_View.cpp-5307-
./text/fmt/xp/fv_View.cpp-5308-		m_pG->setClipRect(&r);
./text/fmt/xp/fv_View.cpp-5309-	}
./text/fmt/xp/fv_View.cpp-5310-
./text/fmt/xp/fv_View.cpp-5311-	// figure out where pages go, based on current window dimensions
./text/fmt/xp/fv_View.cpp:5312:	// TODO: don't calc for every draw
./text/fmt/xp/fv_View.cpp-5313-	// HYP:  cache calc results at scroll/size time
./text/fmt/xp/fv_View.cpp-5314-	UT_sint32 iDocHeight = m_pLayout->getHeight();
./text/fmt/xp/fv_View.cpp-5315-
./text/fmt/xp/fv_View.cpp:5316:	// TODO: handle positioning within oversized viewport
./text/fmt/xp/fv_View.cpp:5317:	// TODO: handle variable-size pages (envelope, landscape, etc.)
./text/fmt/xp/fv_View.cpp-5318-
./text/fmt/xp/fv_View.cpp-5319-	/*
./text/fmt/xp/fv_View.cpp-5320-	  In page view mode, so draw outside decorations first, then each 
./text/fmt/xp/fv_View.cpp-5321-	  page with its decorations.  
./text/fmt/xp/fv_View.cpp-5322-	*/
./text/fmt/xp/fv_View.cpp-5495-
./text/fmt/xp/fv_View.cpp-5496-}
./text/fmt/xp/fv_View.cpp-5497-
./text/fmt/xp/fv_View.cpp-5498-void FV_View::cmdScroll(AV_ScrollCmd cmd, UT_uint32 iPos)
./text/fmt/xp/fv_View.cpp-5499-{
./text/fmt/xp/fv_View.cpp:5500:#define HACK_LINE_HEIGHT				20 // TODO Fix this!!
./text/fmt/xp/fv_View.cpp-5501-	
./text/fmt/xp/fv_View.cpp-5502-	UT_sint32 lineHeight = iPos;
./text/fmt/xp/fv_View.cpp-5503-	UT_sint32 docHeight = 0;
./text/fmt/xp/fv_View.cpp-5504-	UT_Bool bVertical = UT_FALSE;
./text/fmt/xp/fv_View.cpp-5505-	UT_Bool bHorizontal = UT_FALSE;
./text/fmt/xp/fv_View.cpp-6071-	// Signal PieceTable Change 
./text/fmt/xp/fv_View.cpp-6072-	m_pDoc->notifyPieceTableChangeStart();
./text/fmt/xp/fv_View.cpp-6073-
./text/fmt/xp/fv_View.cpp-6074-	_eraseInsertionPoint();
./text/fmt/xp/fv_View.cpp-6075-
./text/fmt/xp/fv_View.cpp:6076:	//	_clearIfAtFmtMark(getPoint()); TODO:	This was giving problems 
./text/fmt/xp/fv_View.cpp-6077-	//											caused bug 431 when changing
./text/fmt/xp/fv_View.cpp-6078-	//											columns.
./text/fmt/xp/fv_View.cpp-6079-	
./text/fmt/xp/fv_View.cpp-6080-	PT_DocPosition posStart = getPoint();
./text/fmt/xp/fv_View.cpp-6081-	PT_DocPosition posEnd = posStart;
./text/fmt/xp/fv_View.cpp-6109-
./text/fmt/xp/fv_View.cpp-6110-void FV_View::getTopRulerInfo(AP_TopRulerInfo * pInfo)
./text/fmt/xp/fv_View.cpp-6111-{
./text/fmt/xp/fv_View.cpp-6112-	memset(pInfo,0,sizeof(*pInfo));
./text/fmt/xp/fv_View.cpp-6113-
./text/fmt/xp/fv_View.cpp:6114:	if (1)		// TODO support tables
./text/fmt/xp/fv_View.cpp-6115-	{
./text/fmt/xp/fv_View.cpp-6116-		// we are in a column context
./text/fmt/xp/fv_View.cpp-6117-
./text/fmt/xp/fv_View.cpp-6118-		fl_BlockLayout * pBlock = NULL;
./text/fmt/xp/fv_View.cpp-6119-		fp_Run * pRun = NULL;
./text/fmt/xp/fv_View.cpp-6144-			pInfo->u.c.m_xColumnGap = pDSL->getColumnGap();
./text/fmt/xp/fv_View.cpp-6145-			pInfo->u.c.m_xColumnWidth = pColumn->getWidth();
./text/fmt/xp/fv_View.cpp-6146-		}
./text/fmt/xp/fv_View.cpp-6147-		else
./text/fmt/xp/fv_View.cpp-6148-		{
./text/fmt/xp/fv_View.cpp:6149:			// TODO fill in the same info as above, with whatever is appropriate
./text/fmt/xp/fv_View.cpp-6150-		}
./text/fmt/xp/fv_View.cpp-6151-		
./text/fmt/xp/fv_View.cpp-6152-		// fill in the details
./text/fmt/xp/fv_View.cpp-6153-		
./text/fmt/xp/fv_View.cpp-6154-		pInfo->m_mode = AP_TopRulerInfo::TRI_MODE_COLUMNS;
./text/fmt/xp/fv_View.cpp:6155:		pInfo->m_xPaperSize = m_pG->convertDimension("8.5in"); // TODO eliminate this constant
./text/fmt/xp/fv_View.cpp-6156-		pInfo->m_xPageViewMargin = fl_PAGEVIEW_MARGIN_X;
./text/fmt/xp/fv_View.cpp-6157-
./text/fmt/xp/fv_View.cpp-6158-		pInfo->m_xrPoint = xCaret - pContainer->getX();
./text/fmt/xp/fv_View.cpp-6159-		pInfo->m_xrLeftIndent = m_pG->convertDimension(pBlock->getProperty((XML_Char*)"margin-left"));
./text/fmt/xp/fv_View.cpp-6160-		pInfo->m_xrRightIndent = m_pG->convertDimension(pBlock->getProperty((XML_Char*)"margin-right"));
./text/fmt/xp/fv_View.cpp-6167-		pInfo->m_pszTabStops = pBlock->getProperty((XML_Char*)"tabstops");
./text/fmt/xp/fv_View.cpp-6168-
./text/fmt/xp/fv_View.cpp-6169-	}
./text/fmt/xp/fv_View.cpp-6170-	else
./text/fmt/xp/fv_View.cpp-6171-	{
./text/fmt/xp/fv_View.cpp:6172:		// TODO support tables
./text/fmt/xp/fv_View.cpp-6173-	}
./text/fmt/xp/fv_View.cpp-6174-
./text/fmt/xp/fv_View.cpp-6175-	return;
./text/fmt/xp/fv_View.cpp-6176-}
./text/fmt/xp/fv_View.cpp-6177-
./text/fmt/xp/fv_View.cpp-6178-void FV_View::getLeftRulerInfo(AP_LeftRulerInfo * pInfo)
./text/fmt/xp/fv_View.cpp-6179-{
./text/fmt/xp/fv_View.cpp-6180-	memset(pInfo,0,sizeof(*pInfo));
./text/fmt/xp/fv_View.cpp-6181-
./text/fmt/xp/fv_View.cpp:6182:	if (1)								// TODO support tables
./text/fmt/xp/fv_View.cpp-6183-	{
./text/fmt/xp/fv_View.cpp-6184-		// we assume that we are in a column context (rather than a table)
./text/fmt/xp/fv_View.cpp-6185-
./text/fmt/xp/fv_View.cpp-6186-		pInfo->m_mode = AP_LeftRulerInfo::TRI_MODE_COLUMNS;
./text/fmt/xp/fv_View.cpp-6187-
./text/fmt/xp/fv_View.cpp-6214-			pInfo->m_yTopMargin = pDSL->getTopMargin();
./text/fmt/xp/fv_View.cpp-6215-			pInfo->m_yBottomMargin = pDSL->getBottomMargin();
./text/fmt/xp/fv_View.cpp-6216-		}
./text/fmt/xp/fv_View.cpp-6217-		else
./text/fmt/xp/fv_View.cpp-6218-		{
./text/fmt/xp/fv_View.cpp:6219:			// TODO fill in the same info as above, with whatever is appropriate
./text/fmt/xp/fv_View.cpp-6220-		}
./text/fmt/xp/fv_View.cpp-6221-	}
./text/fmt/xp/fv_View.cpp-6222-	else
./text/fmt/xp/fv_View.cpp-6223-	{
./text/fmt/xp/fv_View.cpp:6224:		// TODO support tables
./text/fmt/xp/fv_View.cpp-6225-	}
./text/fmt/xp/fv_View.cpp-6226-
./text/fmt/xp/fv_View.cpp-6227-	return;
./text/fmt/xp/fv_View.cpp-6228-}
./text/fmt/xp/fv_View.cpp-6229-
./text/fmt/xp/fv_View.cpp-6420-				return EV_EMC_MISSPELLEDTEXT;
./text/fmt/xp/fv_View.cpp-6421-
./text/fmt/xp/fv_View.cpp-6422-		return EV_EMC_TEXT;
./text/fmt/xp/fv_View.cpp-6423-		
./text/fmt/xp/fv_View.cpp-6424-	case FPRUN_IMAGE:
./text/fmt/xp/fv_View.cpp:6425:		// TODO see if the image is selected and current x,y
./text/fmt/xp/fv_View.cpp:6426:		// TODO is over the image border or the border handles.
./text/fmt/xp/fv_View.cpp:6427:		// TODO if so, return EV_EMC_IMAGESIZE
./text/fmt/xp/fv_View.cpp-6428-		return EV_EMC_IMAGE;
./text/fmt/xp/fv_View.cpp-6429-		
./text/fmt/xp/fv_View.cpp-6430-	case FPRUN_TAB:
./text/fmt/xp/fv_View.cpp-6431-	case FPRUN_FORCEDLINEBREAK:
./text/fmt/xp/fv_View.cpp-6432-	case FPRUN_FORCEDCOLUMNBREAK:
./text/fmt/xp/fv_View.cpp-6455-	// this is to allow a keyboard binding to raise
./text/fmt/xp/fv_View.cpp-6456-	// a context menu.
./text/fmt/xp/fv_View.cpp-6457-
./text/fmt/xp/fv_View.cpp-6458-	EV_EditMouseContext emc = EV_EMC_TEXT;
./text/fmt/xp/fv_View.cpp-6459-
./text/fmt/xp/fv_View.cpp:6460:	// TODO compute the correct context based upon the
./text/fmt/xp/fv_View.cpp:6461:	// TODO current insertion point and/or the current
./text/fmt/xp/fv_View.cpp:6462:	// TODO selection region.
./text/fmt/xp/fv_View.cpp-6463-	
./text/fmt/xp/fv_View.cpp-6464-	if (pxPos)
./text/fmt/xp/fv_View.cpp-6465-		*pxPos = m_xPoint;
./text/fmt/xp/fv_View.cpp-6466-	if (pyPos)
./text/fmt/xp/fv_View.cpp-6467-		*pyPos = m_yPoint + m_iPointHeight;
./text/fmt/xp/fv_View.cpp-6561-	}
./text/fmt/xp/fv_View.cpp-6562-				
./text/fmt/xp/fv_View.cpp-6563-	SpellCheckSuggestNWord16(theWord, pPOB->iLength, &sg);
./text/fmt/xp/fv_View.cpp-6564-
./text/fmt/xp/fv_View.cpp-6565-	// we currently return all requested suggestions
./text/fmt/xp/fv_View.cpp:6566:	// TODO: prune lower-weighted ones??
./text/fmt/xp/fv_View.cpp-6567-	if ((sg.count) && 
./text/fmt/xp/fv_View.cpp-6568-		((int) ndx <= sg.count)) 
./text/fmt/xp/fv_View.cpp-6569-	{
./text/fmt/xp/fv_View.cpp-6570-		UT_UCS_cloneString(&szSuggest, (UT_UCSChar *) sg.word[ndx-1]);
./text/fmt/xp/fv_View.cpp-6571-	}
./text/fmt/xp/fv_View.cpp-6625-		while (pSL)
./text/fmt/xp/fv_View.cpp-6626-		{
./text/fmt/xp/fv_View.cpp-6627-			fl_BlockLayout* b = pSL->getFirstBlock();
./text/fmt/xp/fv_View.cpp-6628-			while (b)
./text/fmt/xp/fv_View.cpp-6629-			{
./text/fmt/xp/fv_View.cpp:6630:				// TODO: just check and remove matching squiggles
./text/fmt/xp/fv_View.cpp-6631-				// for now, destructively recheck the whole thing
./text/fmt/xp/fv_View.cpp-6632-				m_pLayout->queueBlockForBackgroundCheck(FL_DocLayout::bgcrSpelling, b);
./text/fmt/xp/fv_View.cpp-6633-				b = b->getNext();
./text/fmt/xp/fv_View.cpp-6634-			}
./text/fmt/xp/fv_View.cpp-6635-			pSL = (fl_DocSectionLayout *) pSL->getNext();
./text/fmt/xp/fv_View.cpp-6661-		while (pSL)
./text/fmt/xp/fv_View.cpp-6662-		{
./text/fmt/xp/fv_View.cpp-6663-			fl_BlockLayout* b = pSL->getFirstBlock();
./text/fmt/xp/fv_View.cpp-6664-			while (b)
./text/fmt/xp/fv_View.cpp-6665-			{
./text/fmt/xp/fv_View.cpp:6666:				// TODO: just check and remove matching squiggles
./text/fmt/xp/fv_View.cpp-6667-				// for now, destructively recheck the whole thing
./text/fmt/xp/fv_View.cpp-6668-				m_pLayout->queueBlockForBackgroundCheck(FL_DocLayout::bgcrSpelling, b);
./text/fmt/xp/fv_View.cpp-6669-				b = b->getNext();
./text/fmt/xp/fv_View.cpp-6670-			}
./text/fmt/xp/fv_View.cpp-6671-			pSL = (fl_DocSectionLayout *) pSL->getNext();
./text/fmt/xp/fv_View.cpp-6823-		This provides NO undo stuff.  Do it yourself.
./text/fmt/xp/fv_View.cpp-6824-	*/
./text/fmt/xp/fv_View.cpp-6825-
./text/fmt/xp/fv_View.cpp-6826-	const XML_Char* szString = ftr ? "footer" : "header";
./text/fmt/xp/fv_View.cpp-6827-
./text/fmt/xp/fv_View.cpp:6828:	// TODO: This stuff shouldn't be hardcoded
./text/fmt/xp/fv_View.cpp:6829:	// TODO: The fact that it is hardcoded means that only 
./text/fmt/xp/fv_View.cpp:6830:	// TODO: one section can have footers at one time, currently
./text/fmt/xp/fv_View.cpp-6831-
./text/fmt/xp/fv_View.cpp-6832-	const XML_Char*	sec_attributes1[] = {
./text/fmt/xp/fv_View.cpp-6833-		"type", szString,
./text/fmt/xp/fv_View.cpp-6834-		"id", "page_num",
./text/fmt/xp/fv_View.cpp-6835-		NULL, NULL
./text/ptbl/xp/pd_Style.cpp-35-
./text/ptbl/xp/pd_Style.cpp-36-UT_Bool PD_Style::setIndexAP(PT_AttrPropIndex indexAP)
./text/ptbl/xp/pd_Style.cpp-37-{
./text/ptbl/xp/pd_Style.cpp-38-	UT_ASSERT(indexAP != m_indexAP);
./text/ptbl/xp/pd_Style.cpp-39-
./text/ptbl/xp/pd_Style.cpp:40:	// TODO: may need to rebind, handle undo, clear caches, etc.
./text/ptbl/xp/pd_Style.cpp-41-
./text/ptbl/xp/pd_Style.cpp-42-	m_indexAP = indexAP;
./text/ptbl/xp/pd_Style.cpp-43-
./text/ptbl/xp/pd_Style.cpp-44-	return UT_TRUE;
./text/ptbl/xp/pd_Style.cpp-45-}
./text/ptbl/xp/pd_Style.cpp-64-		return pAP->getAttribute(szName, szValue);
./text/ptbl/xp/pd_Style.cpp-65-}
./text/ptbl/xp/pd_Style.cpp-66-
./text/ptbl/xp/pd_Style.cpp-67-UT_Bool PD_Style::isUsed(void) const
./text/ptbl/xp/pd_Style.cpp-68-{
./text/ptbl/xp/pd_Style.cpp:69:	// TODO: we need some way of refcounting
./text/ptbl/xp/pd_Style.cpp:70:	// TODO: what if this document is a template
./text/ptbl/xp/pd_Style.cpp-71-
./text/ptbl/xp/pd_Style.cpp-72-	// for now, we cheat
./text/ptbl/xp/pd_Style.cpp-73-	return isUserDefined();
./text/ptbl/xp/pd_Style.cpp-74-}
./text/ptbl/xp/pd_Style.cpp-75-
./text/ptbl/xp/pd_Style.cpp-76-UT_Bool PD_Style::isCharStyle(void) const
./text/ptbl/xp/pd_Style.cpp-77-{
./text/ptbl/xp/pd_Style.cpp:78:	// TODO: cache this too  
./text/ptbl/xp/pd_Style.cpp-79-
./text/ptbl/xp/pd_Style.cpp-80-	const XML_Char * szValue = NULL;
./text/ptbl/xp/pd_Style.cpp-81-	if (getAttribute(PT_TYPE_ATTRIBUTE_NAME, szValue))
./text/ptbl/xp/pd_Style.cpp-82-		if (szValue && szValue[0])
./text/ptbl/xp/pd_Style.cpp-83-			return !UT_strcmp(szValue, "c");
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-90-		break;
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-91-	case PTO_Field:
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-92-		sz = "Field";
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-93-		break;
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-94-	default:
./text/ptbl/xp/pf_Frag_TestRoutines.cpp:95:		sz = "TODO";
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-96-		break;
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-97-	}
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-98-	
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-99-	fprintf(fp,"        Object %p t[%s] api[%08lx]\n",
./text/ptbl/xp/pf_Frag_TestRoutines.cpp-100-			(void*)this,sz,(long)m_indexAP);
./text/ptbl/xp/pp_AttrProp.cpp-89-	return UT_TRUE;
./text/ptbl/xp/pp_AttrProp.cpp-90-}
./text/ptbl/xp/pp_AttrProp.cpp-91-
./text/ptbl/xp/pp_AttrProp.cpp-92-UT_Bool	PP_AttrProp::setAttribute(const XML_Char * szName, const XML_Char * szValue)
./text/ptbl/xp/pp_AttrProp.cpp-93-{
./text/ptbl/xp/pp_AttrProp.cpp:94:	// TODO when this assert fails, switch this file to use UT_XML_ version of str*() functions.
./text/ptbl/xp/pp_AttrProp.cpp-95-	UT_ASSERT(sizeof(char)==sizeof(XML_Char));
./text/ptbl/xp/pp_AttrProp.cpp-96-	
./text/ptbl/xp/pp_AttrProp.cpp-97-	if (0 == UT_strcmp(szName, PT_PROPS_ATTRIBUTE_NAME))	// PROPS -- cut value up into properties
./text/ptbl/xp/pp_AttrProp.cpp-98-	{
./text/ptbl/xp/pp_AttrProp.cpp-99-		char * pOrig = NULL;
./text/ptbl/xp/pp_AttrProp.cpp-273-UT_Bool PP_AttrProp::areAlreadyPresent(const XML_Char ** attributes, const XML_Char ** properties) const
./text/ptbl/xp/pp_AttrProp.cpp-274-{
./text/ptbl/xp/pp_AttrProp.cpp-275-	// return TRUE if each attribute and property is already present
./text/ptbl/xp/pp_AttrProp.cpp-276-	// and has the same value as what we have.
./text/ptbl/xp/pp_AttrProp.cpp-277-
./text/ptbl/xp/pp_AttrProp.cpp:278:	// TODO consider using the fact that we are now (Dec 12 1998) using
./text/ptbl/xp/pp_AttrProp.cpp:279:	// TODO alpha-hash-table rather than just a hash-table to optimize
./text/ptbl/xp/pp_AttrProp.cpp:280:	// TODO these loops somewhat.
./text/ptbl/xp/pp_AttrProp.cpp-281-	
./text/ptbl/xp/pp_AttrProp.cpp-282-	if (attributes && *attributes)
./text/ptbl/xp/pp_AttrProp.cpp-283-	{
./text/ptbl/xp/pp_AttrProp.cpp-284-		const XML_Char ** p = attributes;
./text/ptbl/xp/pp_AttrProp.cpp-285-		while (*p)
./text/ptbl/xp/pp_AttrProp.cpp-321-{
./text/ptbl/xp/pp_AttrProp.cpp-322-	// return TRUE if any attribute- or property-name is present.
./text/ptbl/xp/pp_AttrProp.cpp-323-	// this is like areAlreadyPresent() but we don't care about
./text/ptbl/xp/pp_AttrProp.cpp-324-	// the values.
./text/ptbl/xp/pp_AttrProp.cpp-325-
./text/ptbl/xp/pp_AttrProp.cpp:326:	// TODO consider using the fact that we are now (Dec 12 1998) using
./text/ptbl/xp/pp_AttrProp.cpp:327:	// TODO alpha-hash-table rather than just a hash-table to optimize
./text/ptbl/xp/pp_AttrProp.cpp:328:	// TODO these loops somewhat.
./text/ptbl/xp/pp_AttrProp.cpp-329-
./text/ptbl/xp/pp_AttrProp.cpp-330-	if (attributes && *attributes)
./text/ptbl/xp/pp_AttrProp.cpp-331-	{
./text/ptbl/xp/pp_AttrProp.cpp-332-		const XML_Char ** p = attributes;
./text/ptbl/xp/pp_AttrProp.cpp-333-		while (*p)
./text/ptbl/xp/pp_AttrProp.cpp-441-	const XML_Char * vNew;
./text/ptbl/xp/pp_AttrProp.cpp-442-	
./text/ptbl/xp/pp_AttrProp.cpp-443-	k = 0;
./text/ptbl/xp/pp_AttrProp.cpp-444-	while (getNthAttribute(k++,n,v))
./text/ptbl/xp/pp_AttrProp.cpp-445-	{
./text/ptbl/xp/pp_AttrProp.cpp:446:		// TODO decide if/whether to allow PT_PROPS_ATTRIBUTE_NAME here.
./text/ptbl/xp/pp_AttrProp.cpp:447:		// TODO The issue is: we use it to store the CSS properties and
./text/ptbl/xp/pp_AttrProp.cpp:448:		// TODO when we see it, we expand the value into one or more
./text/ptbl/xp/pp_AttrProp.cpp:449:		// TODO properties.  if we allow it to be given here, should
./text/ptbl/xp/pp_AttrProp.cpp:450:		// TODO we blowaway all of the existing properties and create
./text/ptbl/xp/pp_AttrProp.cpp:451:		// TODO them from this?  or should we expand it and override
./text/ptbl/xp/pp_AttrProp.cpp:452:		// TODO individual properties?  
./text/ptbl/xp/pp_AttrProp.cpp:453:		// TODO for now, we just barf on it.
./text/ptbl/xp/pp_AttrProp.cpp-454-		UT_ASSERT(UT_XML_stricmp(n,PT_PROPS_ATTRIBUTE_NAME)!=0); // cannot handle PROPS here
./text/ptbl/xp/pp_AttrProp.cpp-455-		if (!papNew->getAttribute(n,vNew))
./text/ptbl/xp/pp_AttrProp.cpp-456-			if (!papNew->setAttribute(n,v))
./text/ptbl/xp/pp_AttrProp.cpp-457-				goto Failed;
./text/ptbl/xp/pp_AttrProp.cpp-458-	}
./text/ptbl/xp/pp_Property.cpp-31-#include "pd_Style.h"
./text/ptbl/xp/pp_Property.cpp-32-
./text/ptbl/xp/pp_Property.cpp-33-/*****************************************************************/
./text/ptbl/xp/pp_Property.cpp-34-
./text/ptbl/xp/pp_Property.cpp-35-/*
./text/ptbl/xp/pp_Property.cpp:36:  TODO do we want this list of last-resort default settings to be here?
./text/ptbl/xp/pp_Property.cpp-37-  It seems out of place... --EWS
./text/ptbl/xp/pp_Property.cpp-38-*/
./text/ptbl/xp/pp_Property.cpp-39-
./text/ptbl/xp/pp_Property.cpp-40-// KEEP THIS ALPHABETICALLY ORDERED UNDER PENALTY OF DEATH!
./text/ptbl/xp/pp_Property.cpp-41-
./text/ptbl/xp/pp_Property.cpp-51-
./text/ptbl/xp/pp_Property.cpp-52-	{ "default-tab-interval",  "0.5in", 0},
./text/ptbl/xp/pp_Property.cpp-53-
./text/ptbl/xp/pp_Property.cpp-54-	{ "field-color", "dcdcdc", 1},
./text/ptbl/xp/pp_Property.cpp-55-	{ "field-font",	"NULL",	1},	
./text/ptbl/xp/pp_Property.cpp:56:	{ "font-family", "Times New Roman", 1},	// TODO this is Win32-specific.  must fix!
./text/ptbl/xp/pp_Property.cpp-57-	{ "font-size",	"12pt",	1},	// MS word defaults to 10pt, but it just seems too small
./text/ptbl/xp/pp_Property.cpp-58-	{ "font-stretch", "normal", 1},
./text/ptbl/xp/pp_Property.cpp-59-	{ "font-style",	"normal", 1},
./text/ptbl/xp/pp_Property.cpp-60-	{ "font-variant", "normal", 1},
./text/ptbl/xp/pp_Property.cpp-61-	{ "font-weight", "normal", 1},
./text/ptbl/xp/pp_Property.cpp-193-		return NULL;
./text/ptbl/xp/pp_Property.cpp-194-	}
./text/ptbl/xp/pp_Property.cpp-195-	
./text/ptbl/xp/pp_Property.cpp-196-	PD_Style * pStyle = NULL;
./text/ptbl/xp/pp_Property.cpp-197-
./text/ptbl/xp/pp_Property.cpp:198:	// TODO: make lookup more efficient by tagging each property with scope (block, char, section)
./text/ptbl/xp/pp_Property.cpp-199-		
./text/ptbl/xp/pp_Property.cpp-200-	// see if the property is on the Span item.
./text/ptbl/xp/pp_Property.cpp-201-	
./text/ptbl/xp/pp_Property.cpp-202-	if (pSpanAttrProp)
./text/ptbl/xp/pp_Property.cpp-203-	{
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-52-	UT_ASSERT(length > 0);
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-53-	UT_ASSERT(fragOffset+length <= pft->getLength());
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-54-	
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-55-	// insert a format change within this text fragment.
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-56-
./text/ptbl/xp/pt_PT_ChangeSpan.cpp:57:	// TODO for each place in this function where we apply a change
./text/ptbl/xp/pt_PT_ChangeSpan.cpp:58:	// TODO see if the new fragment could be coalesced with something
./text/ptbl/xp/pt_PT_ChangeSpan.cpp:59:	// TODO already in the fragment list.
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-60-	
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-61-	if ((fragOffset == 0) && (length == pft->getLength()))
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-62-	{
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-63-		// we have an exact match (we are changing the entire fragment).
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-64-
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-247-												pf_Frag ** ppfNewEnd,
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-248-												UT_uint32 * pfragOffsetNewEnd)
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-249-{
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-250-	// create a change record for this change and put it in the history.
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-251-
./text/ptbl/xp/pt_PT_ChangeSpan.cpp:252:	if (length == 0)					// TODO decide if this is an error.
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-253-	{
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-254-		UT_DEBUGMSG(("_fmtChangeSpanWithNotify: length==0\n"));
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-255-		SETP(ppfNewEnd, pft->getNext());
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-256-		SETP(pfragOffsetNewEnd, 0);
./text/ptbl/xp/pt_PT_ChangeSpan.cpp-257-		return UT_TRUE;
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-119-{
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-120-	// create a change record for this change and put it in the history.
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-121-
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-122-	UT_ASSERT(pfs);
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-123-	
./text/ptbl/xp/pt_PT_DeleteSpan.cpp:124:	if (length == 0)					// TODO decide if this is an error.
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-125-	{
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-126-		UT_DEBUGMSG(("_deleteSpanWithNotify: length==0\n"));
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-127-		SETP(ppfEnd, pft->getNext());
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-128-		SETP(pfragOffsetEnd, 0);
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-129-		return UT_TRUE;
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-168-{
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-169-	// create a change record for this change and put it in the history.
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-170-
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-171-	UT_ASSERT(pfs);
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-172-	
./text/ptbl/xp/pt_PT_DeleteSpan.cpp:173:	if (length == 0)					// TODO decide if this is an error.
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-174-	{
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-175-		UT_DEBUGMSG(("_deleteSpanWithNotify: length==0\n"));
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-176-		SETP(ppfEnd, pft->getNext());
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-177-		SETP(pfragOffsetEnd, 0);
./text/ptbl/xp/pt_PT_DeleteSpan.cpp-178-		return UT_TRUE;
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-96-		// content, we cannot be deleted, since there is no one to
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-97-		// inherit our content.
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-98-
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-99-		if (_struxHasContent(pfs))
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-100-		{
./text/ptbl/xp/pt_PT_DeleteStrux.cpp:101:			// TODO decide if this should assert or just fail...
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-102-			UT_DEBUGMSG(("Cannot delete first paragraph with content.\n"));
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-103-			UT_ASSERT(0);
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-104-			return UT_FALSE;
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-105-		}
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-106-
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-140-	}
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-141-
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-142-	if (!pfsPrev)
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-143-	{
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-144-		// first section in the document cannot be deleted.
./text/ptbl/xp/pt_PT_DeleteStrux.cpp:145:		// TODO decide if this should assesrt or just file...
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-146-		UT_DEBUGMSG(("Cannot delete first section in document.\n"));
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-147-		UT_ASSERT(0);
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-148-		return UT_FALSE;
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-149-	}
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-150-	
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-160-		return UT_TRUE;
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-161-
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-162-	case PTX_Section:
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-163-		// there are no blocks (paragraphs) between this section
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-164-		// and the previous section.  this is not possible.
./text/ptbl/xp/pt_PT_DeleteStrux.cpp:165:		// TODO decide if this should assert or just fail...
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-166-		UT_DEBUGMSG(("No blocks between sections ??\n"));
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-167-		UT_ASSERT(0);
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-168-		return UT_FALSE;
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-169-
./text/ptbl/xp/pt_PT_DeleteStrux.cpp-170-	default:
./text/ptbl/xp/pt_PT_Glob.cpp-48-	// single insert/delete/change.  the insert/delete/change code
./text/ptbl/xp/pt_PT_Glob.cpp-49-	// must break certain operations into multiple steps -- when they
./text/ptbl/xp/pt_PT_Glob.cpp-50-	// cross multiple fragments, for example.  these records are used
./text/ptbl/xp/pt_PT_Glob.cpp-51-	// to bracket the undo/redo.
./text/ptbl/xp/pt_PT_Glob.cpp-52-
./text/ptbl/xp/pt_PT_Glob.cpp:53:	// TODO decide if we want to have the view/formatter suppress
./text/ptbl/xp/pt_PT_Glob.cpp:54:	// TODO screen activity during a multi-step change (and only
./text/ptbl/xp/pt_PT_Glob.cpp:55:	// TODO update the screen after the last step).
./text/ptbl/xp/pt_PT_Glob.cpp-56-
./text/ptbl/xp/pt_PT_Glob.cpp-57-	PX_ChangeRecord * pcr = new PX_ChangeRecord_Glob(PX_ChangeRecord::PXT_GlobMarker,
./text/ptbl/xp/pt_PT_Glob.cpp-58-													 PX_ChangeRecord_Glob::PXF_MultiStepStart);
./text/ptbl/xp/pt_PT_Glob.cpp-59-	UT_ASSERT(pcr);
./text/ptbl/xp/pt_PT_Glob.cpp-60-
./text/ptbl/xp/pt_PT_InsertObject.cpp-41-									const XML_Char ** attributes,
./text/ptbl/xp/pt_PT_InsertObject.cpp-42-									const XML_Char ** properties,  pf_Frag_Object ** ppfo)
./text/ptbl/xp/pt_PT_InsertObject.cpp-43-{
./text/ptbl/xp/pt_PT_InsertObject.cpp-44-	UT_ASSERT(properties == NULL);
./text/ptbl/xp/pt_PT_InsertObject.cpp-45-	
./text/ptbl/xp/pt_PT_InsertObject.cpp:46:	// TODO currently we force the caller to pass in the attr/prop.
./text/ptbl/xp/pt_PT_InsertObject.cpp:47:	// TODO this is probably a good thing for Images, but might be
./text/ptbl/xp/pt_PT_InsertObject.cpp:48:	// TODO bogus for things like Fields.
./text/ptbl/xp/pt_PT_InsertObject.cpp-49-	
./text/ptbl/xp/pt_PT_InsertObject.cpp-50-	UT_ASSERT(m_pts==PTS_Editing);
./text/ptbl/xp/pt_PT_InsertObject.cpp-51-
./text/ptbl/xp/pt_PT_InsertObject.cpp-52-	// store the attributes and properties and get an index to them.
./text/ptbl/xp/pt_PT_InsertObject.cpp-53-	
./text/ptbl/xp/pt_PT_InsertObject.cpp-91-									const XML_Char ** attributes,
./text/ptbl/xp/pt_PT_InsertObject.cpp-92-									const XML_Char ** properties )
./text/ptbl/xp/pt_PT_InsertObject.cpp-93-{
./text/ptbl/xp/pt_PT_InsertObject.cpp-94-	UT_ASSERT(properties == NULL);
./text/ptbl/xp/pt_PT_InsertObject.cpp-95-	
./text/ptbl/xp/pt_PT_InsertObject.cpp:96:	// TODO currently we force the caller to pass in the attr/prop.
./text/ptbl/xp/pt_PT_InsertObject.cpp:97:	// TODO this is probably a good thing for Images, but might be
./text/ptbl/xp/pt_PT_InsertObject.cpp:98:	// TODO bogus for things like Fields.
./text/ptbl/xp/pt_PT_InsertObject.cpp-99-	
./text/ptbl/xp/pt_PT_InsertObject.cpp-100-	UT_ASSERT(m_pts==PTS_Editing);
./text/ptbl/xp/pt_PT_InsertObject.cpp-101-
./text/ptbl/xp/pt_PT_InsertObject.cpp-102-	// store the attributes and properties and get an index to them.
./text/ptbl/xp/pt_PT_InsertObject.cpp-103-	
./text/ptbl/xp/pt_PT_InsertSpan.cpp-360-				// except for the first character.  the second UNDO, will erase
./text/ptbl/xp/pt_PT_InsertSpan.cpp-361-				// the first character and restores the current FmtMark.  if the
./text/ptbl/xp/pt_PT_InsertSpan.cpp-362-				// user BACKSPACES instead of doing the second UNDO, both the
./text/ptbl/xp/pt_PT_InsertSpan.cpp-363-				// first character and the FmtMark would be gone.
./text/ptbl/xp/pt_PT_InsertSpan.cpp-364-				//
./text/ptbl/xp/pt_PT_InsertSpan.cpp:365:				// TODO decide if we like this...
./text/ptbl/xp/pt_PT_InsertSpan.cpp-366-				// NOTE this causes BUG#431.... :-)
./text/ptbl/xp/pt_PT_InsertSpan.cpp-367-
./text/ptbl/xp/pt_PT_InsertSpan.cpp-368-				bNeedGlob = UT_TRUE;
./text/ptbl/xp/pt_PT_InsertSpan.cpp-369-				beginMultiStepGlob();
./text/ptbl/xp/pt_PT_InsertSpan.cpp-370-				_deleteFmtMarkWithNotify(dpos,pfPrevFmtMark,pfs,&pf,&fragOffset);
./text/ptbl/xp/pt_PT_InsertSpan.cpp-554-				// except for the first character.  the second UNDO, will erase
./text/ptbl/xp/pt_PT_InsertSpan.cpp-555-				// the first character and restores the current FmtMark.  if the
./text/ptbl/xp/pt_PT_InsertSpan.cpp-556-				// user BACKSPACES instead of doing the second UNDO, both the
./text/ptbl/xp/pt_PT_InsertSpan.cpp-557-				// first character and the FmtMark would be gone.
./text/ptbl/xp/pt_PT_InsertSpan.cpp-558-				//
./text/ptbl/xp/pt_PT_InsertSpan.cpp:559:				// TODO decide if we like this...
./text/ptbl/xp/pt_PT_InsertSpan.cpp-560-				// NOTE this causes BUG#431.... :-)
./text/ptbl/xp/pt_PT_InsertSpan.cpp-561-
./text/ptbl/xp/pt_PT_InsertSpan.cpp-562-				bNeedGlob = UT_TRUE;
./text/ptbl/xp/pt_PT_InsertSpan.cpp-563-				beginMultiStepGlob();
./text/ptbl/xp/pt_PT_InsertSpan.cpp-564-				_deleteFmtMarkWithNotify(dpos,pfPrevFmtMark,pfs,&pf,&fragOffset);
./text/ptbl/xp/pt_PT_InsertSpan.cpp-757-			}
./text/ptbl/xp/pt_PT_InsertSpan.cpp-758-		}
./text/ptbl/xp/pt_PT_InsertSpan.cpp-759-
./text/ptbl/xp/pt_PT_InsertSpan.cpp-760-	case pf_Frag::PFT_FmtMark:
./text/ptbl/xp/pt_PT_InsertSpan.cpp-761-		{
./text/ptbl/xp/pt_PT_InsertSpan.cpp:762:			// TODO i'm not sure this is possible
./text/ptbl/xp/pt_PT_InsertSpan.cpp-763-			
./text/ptbl/xp/pt_PT_InsertSpan.cpp-764-			pf_Frag_FmtMark * pffm = static_cast<pf_Frag_FmtMark *>(pfPrev);
./text/ptbl/xp/pt_PT_InsertSpan.cpp-765-			return pffm->getIndexAP();
./text/ptbl/xp/pt_PT_InsertSpan.cpp-766-		}
./text/ptbl/xp/pt_PT_InsertSpan.cpp-767-		
./text/ptbl/xp/pt_PT_InsertStrux.cpp-91-	case pf_Frag::PFT_Object:
./text/ptbl/xp/pt_PT_InsertStrux.cpp-92-	case pf_Frag::PFT_EndOfDoc:
./text/ptbl/xp/pt_PT_InsertStrux.cpp-93-	case pf_Frag::PFT_Strux:
./text/ptbl/xp/pt_PT_InsertStrux.cpp-94-		{
./text/ptbl/xp/pt_PT_InsertStrux.cpp-95-			// insert pfsNew before pf.
./text/ptbl/xp/pt_PT_InsertStrux.cpp:96:			// TODO this may introduce some oddities due to empty paragraphs.
./text/ptbl/xp/pt_PT_InsertStrux.cpp:97:			// TODO investigate this later.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-98-			UT_ASSERT(fragOffset == 0);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-99-			m_fragments.insertFrag(pf->getPrev(),pfsNew);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-100-			return;
./text/ptbl/xp/pt_PT_InsertStrux.cpp-101-		}
./text/ptbl/xp/pt_PT_InsertStrux.cpp-102-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-103-	case pf_Frag::PFT_FmtMark:
./text/ptbl/xp/pt_PT_InsertStrux.cpp-104-		{
./text/ptbl/xp/pt_PT_InsertStrux.cpp-105-			// insert pfsNew after pf.
./text/ptbl/xp/pt_PT_InsertStrux.cpp:106:			// TODO check this.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-107-			UT_ASSERT(fragOffset == 0);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-108-			m_fragments.insertFrag(pf,pfsNew);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-109-			return;
./text/ptbl/xp/pt_PT_InsertStrux.cpp-110-		}
./text/ptbl/xp/pt_PT_InsertStrux.cpp-111-		
./text/ptbl/xp/pt_PT_InsertStrux.cpp-115-			// we have a text fragment which we must deal with.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-116-			// if we are in the middle of it, we split it.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-117-			// if we are at one of the ends of it, we just insert
./text/ptbl/xp/pt_PT_InsertStrux.cpp-118-			// the fragment.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-119-
./text/ptbl/xp/pt_PT_InsertStrux.cpp:120:			// TODO if we are at one of the ends of the fragment,
./text/ptbl/xp/pt_PT_InsertStrux.cpp:121:			// TODO should we create a zero-length fragment in one
./text/ptbl/xp/pt_PT_InsertStrux.cpp:122:			// TODO of the paragraphs so that text typed will have
./text/ptbl/xp/pt_PT_InsertStrux.cpp:123:			// TODO the right attributes.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-124-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-125-			pf_Frag_Text * pft = static_cast<pf_Frag_Text *> (pf);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-126-			UT_uint32 fragLen = pft->getLength();
./text/ptbl/xp/pt_PT_InsertStrux.cpp-127-			if (fragOffset == fragLen)
./text/ptbl/xp/pt_PT_InsertStrux.cpp-128-			{
./text/ptbl/xp/pt_PT_InsertStrux.cpp-129-				// we are at the right end of the fragment.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-130-				// insert the strux after the text fragment.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-131-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-132-				m_fragments.insertFrag(pft,pfsNew);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-133-
./text/ptbl/xp/pt_PT_InsertStrux.cpp:134:				// TODO decide if we should create a zero-length
./text/ptbl/xp/pt_PT_InsertStrux.cpp:135:				// TODO fragment in the new paragraph to retain
./text/ptbl/xp/pt_PT_InsertStrux.cpp:136:				// TODO the attr/prop of the pft.
./text/ptbl/xp/pt_PT_InsertStrux.cpp:137:				// TODO         pf_Frag_Text * pftNew = new...
./text/ptbl/xp/pt_PT_InsertStrux.cpp:138:				// TODO         m_fragments.insertFrag(pfsNew,pftNew);
./text/ptbl/xp/pt_PT_InsertStrux.cpp-139-			}
./text/ptbl/xp/pt_PT_InsertStrux.cpp-140-			else if (fragOffset == 0)
./text/ptbl/xp/pt_PT_InsertStrux.cpp-141-			{
./text/ptbl/xp/pt_PT_InsertStrux.cpp-142-				// we are at the left end of the fragment.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-143-				// insert the strux before the text fragment.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-194-	// inherit the style of the one we just broke.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-195-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-196-	PT_AttrPropIndex indexAP = 0;
./text/ptbl/xp/pt_PT_InsertStrux.cpp-197-	if (pfsContainer->getStruxType() == pts)
./text/ptbl/xp/pt_PT_InsertStrux.cpp-198-	{
./text/ptbl/xp/pt_PT_InsertStrux.cpp:199:		// TODO paul, add code here to see if this strux has a "followed-by"
./text/ptbl/xp/pt_PT_InsertStrux.cpp:200:		// TODO paul, property (or property in the style) and get the a/p
./text/ptbl/xp/pt_PT_InsertStrux.cpp:201:		// TODO paul, from there rather than just taking the attr/prop
./text/ptbl/xp/pt_PT_InsertStrux.cpp:202:		// TODO paul, of the previous strux.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-203-		indexAP = pfsContainer->getIndexAP();
./text/ptbl/xp/pt_PT_InsertStrux.cpp-204-	}
./text/ptbl/xp/pt_PT_InsertStrux.cpp-205-	
./text/ptbl/xp/pt_PT_InsertStrux.cpp-206-	pf_Frag_Strux * pfsNew = NULL;
./text/ptbl/xp/pt_PT_InsertStrux.cpp-207-	if (!_createStrux(pts,indexAP,&pfsNew))
./text/ptbl/xp/pt_PT_InsertStrux.cpp-276-	// pfsNewBlock will soon be inserted at [pfCurrent,fragOffset].
./text/ptbl/xp/pt_PT_InsertStrux.cpp-277-	// look at the attr/prop and/or style on this block and see if we should
./text/ptbl/xp/pt_PT_InsertStrux.cpp-278-	// create a FmtMark based upon it.  then look to previous blocks for
./text/ptbl/xp/pt_PT_InsertStrux.cpp-279-	// information to create one.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-280-
./text/ptbl/xp/pt_PT_InsertStrux.cpp:281:	// TODO paul, if we set a style on this block and it implies a span-level
./text/ptbl/xp/pt_PT_InsertStrux.cpp:282:	// TODO paul, format, create the proper FmtMark and return TRUE here rather
./text/ptbl/xp/pt_PT_InsertStrux.cpp:283:	// TODO paul, than looking backwards.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-284-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-285-	// next we look backwards for an active FmtMark or Text span.
./text/ptbl/xp/pt_PT_InsertStrux.cpp-286-
./text/ptbl/xp/pt_PT_InsertStrux.cpp-287-	pf_Frag * pfPrev;
./text/ptbl/xp/pt_PT_InsertStrux.cpp-288-	if (fragOffset!=0)
./text/ptbl/xp/pt_PT_Listener.cpp-144-		}
./text/ptbl/xp/pt_PT_Listener.cpp-145-
./text/ptbl/xp/pt_PT_Listener.cpp-146-		sum += pf->getLength();
./text/ptbl/xp/pt_PT_Listener.cpp-147-	}
./text/ptbl/xp/pt_PT_Listener.cpp-148-
./text/ptbl/xp/pt_PT_Listener.cpp:149:	// TODO assert that sum == our cached value.
./text/ptbl/xp/pt_PT_Listener.cpp-150-	
./text/ptbl/xp/pt_PT_Listener.cpp-151-	return UT_TRUE;
./text/ptbl/xp/pt_PT_Listener.cpp-152-}
./text/ptbl/xp/pt_PT_Listener.cpp-153-
./text/ptbl/xp/pt_PT_Listener.cpp-154-UT_Bool pt_PieceTable::tellListenerSubset(PL_Listener * pListener,
./text/ptbl/xp/pt_PT_Undo.cpp-181-			UT_Bool bFoundFrag = getFragFromPosition(pcrStrux->getPosition(),&pf,&fragOffset);
./text/ptbl/xp/pt_PT_Undo.cpp-182-			UT_ASSERT(bFoundFrag);
./text/ptbl/xp/pt_PT_Undo.cpp-183-
./text/ptbl/xp/pt_PT_Undo.cpp-184-			// get the strux containing the given position.
./text/ptbl/xp/pt_PT_Undo.cpp-185-	
./text/ptbl/xp/pt_PT_Undo.cpp:186:// TODO see if we can avoid this call to _getStruxFromPosition ??
./text/ptbl/xp/pt_PT_Undo.cpp-187-			pf_Frag_Strux * pfsContainer = NULL;
./text/ptbl/xp/pt_PT_Undo.cpp-188-			UT_Bool bFoundContainer = _getStruxFromPosition(pcrStrux->getPosition(),&pfsContainer);
./text/ptbl/xp/pt_PT_Undo.cpp-189-			UT_ASSERT(bFoundContainer);
./text/ptbl/xp/pt_PT_Undo.cpp-190-
./text/ptbl/xp/pt_PT_Undo.cpp-191-			_insertStrux(pf,fragOffset,pfsNew);
./text/ptbl/xp/pt_PT_Undo.cpp-510-{
./text/ptbl/xp/pt_PT_Undo.cpp-511-	UT_Bool bDirty = m_history.isDirty();
./text/ptbl/xp/pt_PT_Undo.cpp-512-
./text/ptbl/xp/pt_PT_Undo.cpp-513-	if (!bDirty)
./text/ptbl/xp/pt_PT_Undo.cpp-514-	{
./text/ptbl/xp/pt_PT_Undo.cpp:515:		// TODO: this is a good spot for sanity checks of the undo mechanism
./text/ptbl/xp/pt_PT_Undo.cpp:516:		// TODO: if we really *aren't* dirty, then doc should be identical to saved version
./text/ptbl/xp/pt_PT_Undo.cpp-517-	}
./text/ptbl/xp/pt_PT_Undo.cpp-518-
./text/ptbl/xp/pt_PT_Undo.cpp-519-	return bDirty;
./text/ptbl/xp/pt_PT_Undo.cpp-520-}
./text/ptbl/xp/pt_PT_Undo.cpp-521-
./text/ptbl/xp/pt_PieceTable.cpp-37-#include "px_CR_SpanChange.h"
./text/ptbl/xp/pt_PieceTable.cpp-38-#include "px_CR_Strux.h"
./text/ptbl/xp/pt_PieceTable.cpp-39-#include "pd_Style.h"
./text/ptbl/xp/pt_PieceTable.cpp-40-
./text/ptbl/xp/pt_PieceTable.cpp-41-
./text/ptbl/xp/pt_PieceTable.cpp:42:// TODO: calculate this from pf_FRAG_STRUX_*_LENGTH instead?
./text/ptbl/xp/pt_PieceTable.cpp-43-#define pt_BOD_POSITION 2
./text/ptbl/xp/pt_PieceTable.cpp-44-
./text/ptbl/xp/pt_PieceTable.cpp-45-/*****************************************************************/
./text/ptbl/xp/pt_PieceTable.cpp-46-/*****************************************************************/
./text/ptbl/xp/pt_PieceTable.cpp-47-
./text/ptbl/xp/pt_PieceTable.cpp-332-			break;
./text/ptbl/xp/pt_PieceTable.cpp-333-
./text/ptbl/xp/pt_PieceTable.cpp-334-		case pf_Frag::PFT_Object:
./text/ptbl/xp/pt_PieceTable.cpp-335-			{
./text/ptbl/xp/pt_PieceTable.cpp-336-				/*
./text/ptbl/xp/pt_PieceTable.cpp:337:				  TODO investigate this....
./text/ptbl/xp/pt_PieceTable.cpp-338-				  Now *here* is a seriously questionable fragment
./text/ptbl/xp/pt_PieceTable.cpp-339-				  of code.  :-)  We can't let getBlockBuf halt on
./text/ptbl/xp/pt_PieceTable.cpp-340-				  a block when it finds an inline object.  However,
./text/ptbl/xp/pt_PieceTable.cpp-341-				  we can't very well sensibly store an inline object
./text/ptbl/xp/pt_PieceTable.cpp-342-				  in a UNICODE character.  So, we dump spaces in
./text/ptbl/xp/pt_PieceTable.cpp-347-				  buffer in the proper location.
./text/ptbl/xp/pt_PieceTable.cpp-348-				*/
./text/ptbl/xp/pt_PieceTable.cpp-349-
./text/ptbl/xp/pt_PieceTable.cpp-350-				UT_uint32 length = pfTemp->getLength();
./text/ptbl/xp/pt_PieceTable.cpp-351-
./text/ptbl/xp/pt_PieceTable.cpp:352:				// TODO investigate appending the SPACES directly to
./text/ptbl/xp/pt_PieceTable.cpp:353:				// TODO the pgb.  **or** investigate the cost of this
./text/ptbl/xp/pt_PieceTable.cpp:354:				// TODO malloc and what happens when it fails....
./text/ptbl/xp/pt_PieceTable.cpp-355-				
./text/ptbl/xp/pt_PieceTable.cpp-356-				UT_UCSChar* pSpaces = new UT_UCSChar[length];
./text/ptbl/xp/pt_PieceTable.cpp-357-				for (UT_uint32 i=0; i<length; i++)
./text/ptbl/xp/pt_PieceTable.cpp-358-				{
./text/ptbl/xp/pt_PieceTable.cpp-359-					pSpaces[i] = UCS_SPACE;
./text/ptbl/xp/pt_PieceTable.cpp-384-		docPos = pt_BOD_POSITION;
./text/ptbl/xp/pt_PieceTable.cpp-385-	}
./text/ptbl/xp/pt_PieceTable.cpp-386-	else
./text/ptbl/xp/pt_PieceTable.cpp-387-	{
./text/ptbl/xp/pt_PieceTable.cpp-388-		// NOTE: this gets called for every cursor motion
./text/ptbl/xp/pt_PieceTable.cpp:389:		// TODO: be more efficient & cache the doc length
./text/ptbl/xp/pt_PieceTable.cpp-390-		PT_DocPosition sum = 0;
./text/ptbl/xp/pt_PieceTable.cpp-391-		pf_Frag * pfLast = NULL;
./text/ptbl/xp/pt_PieceTable.cpp-392-
./text/ptbl/xp/pt_PieceTable.cpp-393-		for (pf_Frag * pf = m_fragments.getFirst(); (pf); pf=pf->getNext())
./text/ptbl/xp/pt_PieceTable.cpp-394-		{
./text/ptbl/xp/pt_PieceTable.cpp-464-	// doc position.
./text/ptbl/xp/pt_PieceTable.cpp-465-
./text/ptbl/xp/pt_PieceTable.cpp-466-	UT_ASSERT(pfLast);
./text/ptbl/xp/pt_PieceTable.cpp-467-	UT_ASSERT(pfLast->getType() == pf_Frag::PFT_EndOfDoc);
./text/ptbl/xp/pt_PieceTable.cpp-468-
./text/ptbl/xp/pt_PieceTable.cpp:469:	// TODO if (docPos > sum) we should probably complain...
./text/ptbl/xp/pt_PieceTable.cpp-470-	
./text/ptbl/xp/pt_PieceTable.cpp-471-	*ppf = pfLast;
./text/ptbl/xp/pt_PieceTable.cpp-472-	if (pFragOffset)
./text/ptbl/xp/pt_PieceTable.cpp-473-		*pFragOffset = docPos - sum;
./text/ptbl/xp/pt_PieceTable.cpp-474-
./text/ptbl/xp/pt_PieceTable.cpp-499-	while (offset+deltaPos >= length)
./text/ptbl/xp/pt_PieceTable.cpp-500-	{
./text/ptbl/xp/pt_PieceTable.cpp-501-		deltaPos -= (length - offset);
./text/ptbl/xp/pt_PieceTable.cpp-502-		offset = 0;
./text/ptbl/xp/pt_PieceTable.cpp-503-		if (pf->getType() == pf_Frag::PFT_EndOfDoc)
./text/ptbl/xp/pt_PieceTable.cpp:504:			break;						// TODO if we haven't quite reached dPos2, we should probably complain...
./text/ptbl/xp/pt_PieceTable.cpp-505-		pf = pf->getNext();
./text/ptbl/xp/pt_PieceTable.cpp-506-		length = pf->getLength();
./text/ptbl/xp/pt_PieceTable.cpp-507-	}
./text/ptbl/xp/pt_PieceTable.cpp-508-
./text/ptbl/xp/pt_PieceTable.cpp-509-	// a FmtMark has length zero.  we don't want to find it here.
./wp/ap/beos/ap_BeOSPrefs.cpp:73:	// TODO (see .../src/wp/ap/xp/ap_*_Languages.h)
./wp/ap/qnx/ap_QNXPrefs.cpp:74:	// TODO (see .../src/wp/ap/xp/ap_*_Languages.h)
./wp/ap/unix/ap_UnixPrefs.cpp:74:	// TODO (see .../src/wp/ap/xp/ap_*_Languages.h)
./wp/ap/xp/ap_Convert.cpp-81-	case UT_IE_NOMEMORY:
./wp/ap/xp/ap_Convert.cpp-82-		if (m_iVerbose > 0)
./wp/ap/xp/ap_Convert.cpp-83-			fprintf(stderr, "AbiWord: Arrrgh... I don't have enough memory!\n");
./wp/ap/xp/ap_Convert.cpp-84-		break;
./wp/ap/xp/ap_Convert.cpp-85-	case UT_NOPIECETABLE:
./wp/ap/xp/ap_Convert.cpp:86:		// TODO
./wp/ap/xp/ap_Convert.cpp-87-	default:
./wp/ap/xp/ap_Convert.cpp-88-		if (m_iVerbose > 0)
./wp/ap/xp/ap_Convert.cpp-89-			fprintf(stderr, "AbiWord: could not open the file [%s]\n", szSourceFilename);
./wp/ap/xp/ap_Convert.cpp-90-	}
./wp/ap/xp/ap_Convert.cpp-91-
./wp/ap/xp/ap_Dialog_Goto.cpp-34-#include "fv_View.h"
./wp/ap/xp/ap_Dialog_Goto.cpp-35-
./wp/ap/xp/ap_Dialog_Goto.cpp-36-char * AP_Dialog_Goto::s_pJumpTargets[] = {
./wp/ap/xp/ap_Dialog_Goto.cpp-37-	NULL,
./wp/ap/xp/ap_Dialog_Goto.cpp-38-	NULL,
./wp/ap/xp/ap_Dialog_Goto.cpp:39://	"Picture",  TODO
./wp/ap/xp/ap_Dialog_Goto.cpp-40-	NULL
./wp/ap/xp/ap_Dialog_Goto.cpp-41-};
./wp/ap/xp/ap_Dialog_Goto.cpp-42-
./wp/ap/xp/ap_Dialog_Goto.cpp-43-
./wp/ap/xp/ap_Dialog_Goto.cpp-44-AP_Dialog_Goto::AP_Dialog_Goto(XAP_DialogFactory * pDlgFactory, XAP_Dialog_Id id)
./wp/ap/xp/ap_Dialog_Goto.cpp-58-{
./wp/ap/xp/ap_Dialog_Goto.cpp-59-    const XAP_StringSet * pSS = m_pApp->getStringSet();
./wp/ap/xp/ap_Dialog_Goto.cpp-60-
./wp/ap/xp/ap_Dialog_Goto.cpp-61-    s_pJumpTargets[0] = ::UT_strdup(pSS->getValue (AP_STRING_ID_DLG_Goto_Target_Page));
./wp/ap/xp/ap_Dialog_Goto.cpp-62-    s_pJumpTargets[1] = ::UT_strdup(pSS->getValue (AP_STRING_ID_DLG_Goto_Target_Line));
./wp/ap/xp/ap_Dialog_Goto.cpp:63:    //s_pJumpTargets[2] = ::UT_strdup(pSS->getValue (AP_STRING_ID_DLG_Goto_Target_Picture)); //TODO
./wp/ap/xp/ap_Dialog_Goto.cpp-64-}
./wp/ap/xp/ap_Dialog_Goto.cpp-65-
./wp/ap/xp/ap_Dialog_Goto.cpp-66-char ** AP_Dialog_Goto::getJumpTargets(void)
./wp/ap/xp/ap_Dialog_Goto.cpp-67-{
./wp/ap/xp/ap_Dialog_Goto.cpp-68-	return (s_pJumpTargets);
./wp/ap/xp/ap_Dialog_Lists.cpp-180-	UT_ASSERT(m_paragraphPreview);
./wp/ap/xp/ap_Dialog_Lists.cpp-181-	
./wp/ap/xp/ap_Dialog_Lists.cpp-182-	m_paragraphPreview->setWindowSize(width, height);
./wp/ap/xp/ap_Dialog_Lists.cpp-183-#endif
./wp/ap/xp/ap_Dialog_Lists.cpp-184-
./wp/ap/xp/ap_Dialog_Lists.cpp:185:	// TODO : any setup of the GC for drawing
./wp/ap/xp/ap_Dialog_Lists.cpp-186-}
./wp/ap/xp/ap_Dialog_Lists.cpp-187-
./wp/ap/xp/ap_Dialog_Lists.cpp-188-void AP_Dialog_Lists::event_PreviewAreaExposed(void)
./wp/ap/xp/ap_Dialog_Lists.cpp-189-{
./wp/ap/xp/ap_Dialog_Lists.cpp-190-
./wp/ap/xp/ap_Dialog_Options.cpp-82-	// a prefs save, then update everything else
./wp/ap/xp/ap_Dialog_Options.cpp-83-	//			shack@uiuc.edu
./wp/ap/xp/ap_Dialog_Options.cpp-84-	if ( pPrefs->getAutoSavePrefs() == UT_TRUE && _gatherPrefsAutoSave() == UT_FALSE ) {
./wp/ap/xp/ap_Dialog_Options.cpp-85-
./wp/ap/xp/ap_Dialog_Options.cpp-86-		pPrefs->setAutoSavePrefs( UT_FALSE );
./wp/ap/xp/ap_Dialog_Options.cpp:87:		pPrefs->savePrefsFile();				// TODO: check the results
./wp/ap/xp/ap_Dialog_Options.cpp-88-	}
./wp/ap/xp/ap_Dialog_Options.cpp-89-	else {	// otherwise, just set the value
./wp/ap/xp/ap_Dialog_Options.cpp-90-		pPrefs->setAutoSavePrefs( _gatherPrefsAutoSave() );
./wp/ap/xp/ap_Dialog_Options.cpp-91-	}
./wp/ap/xp/ap_Dialog_Options.cpp-92-
./wp/ap/xp/ap_Dialog_Options.cpp-118-	{
./wp/ap/xp/ap_Dialog_Options.cpp-119-		pFrameData->m_bShowRuler = _gatherViewShowRuler() ;
./wp/ap/xp/ap_Dialog_Options.cpp-120-		m_pFrame->toggleRuler( _gatherViewShowRuler() );
./wp/ap/xp/ap_Dialog_Options.cpp-121-	}
./wp/ap/xp/ap_Dialog_Options.cpp-122-
./wp/ap/xp/ap_Dialog_Options.cpp:123:	// TODO: Don't use 0, 1, 2, but AP_TOOLBAR_STANDARD, AP_TOOLBAR_FORMAT, AP_TOOLBAR_EXTRA...
./wp/ap/xp/ap_Dialog_Options.cpp-124-	if (_gatherViewShowStandardBar() != pFrameData->m_bShowBar[0])
./wp/ap/xp/ap_Dialog_Options.cpp-125-	{
./wp/ap/xp/ap_Dialog_Options.cpp-126-		pFrameData->m_bShowBar[0] = _gatherViewShowStandardBar();
./wp/ap/xp/ap_Dialog_Options.cpp-127-		m_pFrame->toggleBar(0, _gatherViewShowStandardBar());
./wp/ap/xp/ap_Dialog_Options.cpp-128-	}
./wp/ap/xp/ap_Dialog_Options.cpp-163-
./wp/ap/xp/ap_Dialog_Options.cpp-164-	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
./wp/ap/xp/ap_Dialog_Options.cpp-165-	// allow XAP_Prefs to notify all the listeners of changes
./wp/ap/xp/ap_Dialog_Options.cpp-166-
./wp/ap/xp/ap_Dialog_Options.cpp-167-	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
./wp/ap/xp/ap_Dialog_Options.cpp:168:	// TODO: change to snprintf
./wp/ap/xp/ap_Dialog_Options.cpp-169-	XML_Char szBuffer[40];
./wp/ap/xp/ap_Dialog_Options.cpp-170-	sprintf( szBuffer, "%i", _gatherNotebookPageNum() );
./wp/ap/xp/ap_Dialog_Options.cpp-171-	pPrefsScheme->setValue((XML_Char*)AP_PREF_KEY_OptionsTabNumber,
./wp/ap/xp/ap_Dialog_Options.cpp-172-			       (XML_Char*)szBuffer );
./wp/ap/xp/ap_Dialog_Options.cpp-173-
./wp/ap/xp/ap_Dialog_Options.cpp-174-	// allow the prefListeners to receive their calls
./wp/ap/xp/ap_Dialog_Options.cpp-175-	pPrefs->endBlockChange();
./wp/ap/xp/ap_Dialog_Options.cpp-176-
./wp/ap/xp/ap_Dialog_Options.cpp-177-	// if we hit the Save button, then force a save after the gather
./wp/ap/xp/ap_Dialog_Options.cpp-178-	if ( m_answer == a_SAVE ) {
./wp/ap/xp/ap_Dialog_Options.cpp:179:		pPrefs->savePrefsFile();				// TODO: check the results
./wp/ap/xp/ap_Dialog_Options.cpp-180-	}
./wp/ap/xp/ap_Dialog_Options.cpp-181-
./wp/ap/xp/ap_Dialog_Options.cpp-182-}
./wp/ap/xp/ap_Dialog_Options.cpp-183-
./wp/ap/xp/ap_Dialog_Options.cpp-184-void AP_Dialog_Options::_eventSave(void)
./wp/ap/xp/ap_Dialog_Options.cpp-194-{
./wp/ap/xp/ap_Dialog_Options.cpp-195-	UT_Bool			b;
./wp/ap/xp/ap_Dialog_Options.cpp-196-	XAP_Prefs		*pPrefs;
./wp/ap/xp/ap_Dialog_Options.cpp-197-	const XML_Char	*pszBuffer;	
./wp/ap/xp/ap_Dialog_Options.cpp-198-
./wp/ap/xp/ap_Dialog_Options.cpp:199:	// TODO: move this logic when we get a PrefsListener API and turn this
./wp/ap/xp/ap_Dialog_Options.cpp-200-	//		 dialog into an app-specific
./wp/ap/xp/ap_Dialog_Options.cpp-201-
./wp/ap/xp/ap_Dialog_Options.cpp-202-	pPrefs = m_pApp->getPrefs();
./wp/ap/xp/ap_Dialog_Options.cpp-203-	UT_ASSERT( pPrefs );
./wp/ap/xp/ap_Dialog_Options.cpp-204-
./wp/ap/xp/ap_Dialog_Options.cpp-325-
./wp/ap/xp/ap_Dialog_Options.cpp-326-	pPrefs->setCurrentScheme((XML_Char*)"_builtin_");		
./wp/ap/xp/ap_Dialog_Options.cpp-327-	
./wp/ap/xp/ap_Dialog_Options.cpp-328-	_populateWindowData();
./wp/ap/xp/ap_Dialog_Options.cpp-329-
./wp/ap/xp/ap_Dialog_Options.cpp:330:	// TODO i'm not sure you want to do the following at this
./wp/ap/xp/ap_Dialog_Options.cpp:331:	// TODO time.  setting to "defaults" should probably just
./wp/ap/xp/ap_Dialog_Options.cpp:332:	// TODO set us to "_builtin_" and that's it.  if the user
./wp/ap/xp/ap_Dialog_Options.cpp:333:	// TODO then changes something, we should create a new
./wp/ap/xp/ap_Dialog_Options.cpp:334:	// TODO scheme and fill in the new value.  --jeff
./wp/ap/xp/ap_Dialog_Options.cpp-335-	_setNotebookPageNum( currentPage );		
./wp/ap/xp/ap_Dialog_Options.cpp-336-	pPrefs->setCurrentScheme(old_name);
./wp/ap/xp/ap_Dialog_Options.cpp-337-}
./wp/ap/xp/ap_Dialog_Options.cpp-338-
./wp/ap/xp/ap_Dialog_Options.cpp-339-void AP_Dialog_Options::_event_IgnoreReset(void)
./wp/ap/xp/ap_Dialog_Options.cpp-340-{
./wp/ap/xp/ap_Dialog_Options.cpp-341-	UT_DEBUGMSG(("AP_Dialog_Options::_event_IgnoreReset\n"));
./wp/ap/xp/ap_Dialog_Options.cpp-342-	UT_ASSERT( m_pFrame );
./wp/ap/xp/ap_Dialog_Options.cpp-343-
./wp/ap/xp/ap_Dialog_Options.cpp:344:	// TODO:  shack@uiuc.edu: waiting for a vote for reset strings...
./wp/ap/xp/ap_Dialog_Options.cpp-345-
./wp/ap/xp/ap_Dialog_Options.cpp-346-	// Ask "Do you want to reset ignored words in the current document?" 
./wp/ap/xp/ap_Dialog_Options.cpp-347-    XAP_Dialog_MessageBox::tAnswer ans = m_pFrame->showMessageBox(AP_STRING_ID_DLG_Options_Prompt_IgnoreResetCurrent,
./wp/ap/xp/ap_Dialog_Options.cpp-348-								XAP_Dialog_MessageBox::b_YNC,
./wp/ap/xp/ap_Dialog_Options.cpp-349-								XAP_Dialog_MessageBox::a_NO); // should this be YES?
./wp/ap/xp/ap_Dialog_Options.cpp-402-			pFrame->getCurrentDoc()->clearIgnores();
./wp/ap/xp/ap_Dialog_Options.cpp-403-			((FV_View *)pFrame->getCurrentView())->getLayout()->recheckIgnoredWords();
./wp/ap/xp/ap_Dialog_Options.cpp-404-		}
./wp/ap/xp/ap_Dialog_Options.cpp-405-	}
./wp/ap/xp/ap_Dialog_Options.cpp-406-
./wp/ap/xp/ap_Dialog_Options.cpp:407:	// TODO : recheck spelling
./wp/ap/xp/ap_Dialog_Options.cpp-408-
./wp/ap/xp/ap_Dialog_Options.cpp-409-}
./wp/ap/xp/ap_Dialog_Options.cpp-410-
./wp/ap/xp/ap_Dialog_Options.cpp-411-void AP_Dialog_Options::_event_IgnoreEdit(void)
./wp/ap/xp/ap_Dialog_Options.cpp-412-{
./wp/ap/xp/ap_Dialog_Paragraph.cpp-304-		if (sz)
./wp/ap/xp/ap_Dialog_Paragraph.cpp-305-		{
./wp/ap/xp/ap_Dialog_Paragraph.cpp-306-			UT_XML_cloneString(m_pageRightMargin, sz);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-307-		}
./wp/ap/xp/ap_Dialog_Paragraph.cpp-308-			
./wp/ap/xp/ap_Dialog_Paragraph.cpp:309:		// TODO : add these to PP_Property (pp_Property.cpp) !!!
./wp/ap/xp/ap_Dialog_Paragraph.cpp:310:		// TODO : and to FV_View::getBlockFormat (or else they won't come in)
./wp/ap/xp/ap_Dialog_Paragraph.cpp-311-		/*
./wp/ap/xp/ap_Dialog_Paragraph.cpp-312-		  m_pageBreakBefore;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-313-		  m_suppressLineNumbers;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-314-		  m_noHyphenate;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-315-		*/
./wp/ap/xp/ap_Dialog_Paragraph.cpp-383-		UT_XML_cloneString(p->val, _getSpinItemValue(id_SPIN_RIGHT_INDENT));
./wp/ap/xp/ap_Dialog_Paragraph.cpp-384-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-385-		v.addItem(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-386-	}
./wp/ap/xp/ap_Dialog_Paragraph.cpp-387-
./wp/ap/xp/ap_Dialog_Paragraph.cpp:388:	// TODO : The logic here might not be bulletproof.  If the user triggers
./wp/ap/xp/ap_Dialog_Paragraph.cpp:389:	// TODO : a change in the TYPE of special indent (hanging, first line,
./wp/ap/xp/ap_Dialog_Paragraph.cpp:390:	// TODO : none), we will always save what's in the box as a property.
./wp/ap/xp/ap_Dialog_Paragraph.cpp:391:	// TODO : One could make it smarter with a stronger contract with
./wp/ap/xp/ap_Dialog_Paragraph.cpp:392:	// TODO : the platform interfaces.
./wp/ap/xp/ap_Dialog_Paragraph.cpp-393-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-394-	if (_wasChanged(id_MENU_SPECIAL_INDENT) || _wasChanged(id_SPIN_SPECIAL_INDENT))
./wp/ap/xp/ap_Dialog_Paragraph.cpp-395-	{
./wp/ap/xp/ap_Dialog_Paragraph.cpp-396-		ALLOC_PROP_PAIR(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-397-		UT_XML_cloneString(p->prop, "text-indent");
./wp/ap/xp/ap_Dialog_Paragraph.cpp-437-		UT_XML_cloneString(p->val, _getSpinItemValue(id_SPIN_AFTER_SPACING));
./wp/ap/xp/ap_Dialog_Paragraph.cpp-438-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-439-		v.addItem(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-440-	}
./wp/ap/xp/ap_Dialog_Paragraph.cpp-441-	
./wp/ap/xp/ap_Dialog_Paragraph.cpp:442:	// TODO : The logic here might not be bulletproof.  If the user triggers
./wp/ap/xp/ap_Dialog_Paragraph.cpp:443:	// TODO : a change in the TYPE of special indent (single, double, etc.)
./wp/ap/xp/ap_Dialog_Paragraph.cpp:444:	// TODO : we will always save what's in the box as a property.
./wp/ap/xp/ap_Dialog_Paragraph.cpp:445:	// TODO : One could make it smarter with a stronger contract with
./wp/ap/xp/ap_Dialog_Paragraph.cpp:446:	// TODO : the platform interfaces.
./wp/ap/xp/ap_Dialog_Paragraph.cpp-447-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-448-	if(_wasChanged(id_MENU_SPECIAL_SPACING) || _wasChanged(id_SPIN_SPECIAL_SPACING))
./wp/ap/xp/ap_Dialog_Paragraph.cpp-449-	{
./wp/ap/xp/ap_Dialog_Paragraph.cpp-450-		ALLOC_PROP_PAIR(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-451-		UT_XML_cloneString(p->prop, "line-height");
./wp/ap/xp/ap_Dialog_Paragraph.cpp-501-	// NOTE : 0, then some form of control is in effect.  If the property
./wp/ap/xp/ap_Dialog_Paragraph.cpp-502-	// NOTE : is not set, they're indeterminate.
./wp/ap/xp/ap_Dialog_Paragraph.cpp-503-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-504-	if (_wasChanged(id_CHECK_WIDOW_ORPHAN))
./wp/ap/xp/ap_Dialog_Paragraph.cpp-505-	{
./wp/ap/xp/ap_Dialog_Paragraph.cpp:506:		// TODO : fix this!  we stomp on both properties (setting them
./wp/ap/xp/ap_Dialog_Paragraph.cpp:507:		// TODO : to "2"s or "0"s) if the one check box was ever
./wp/ap/xp/ap_Dialog_Paragraph.cpp:508:		// TODO : changed
./wp/ap/xp/ap_Dialog_Paragraph.cpp-509-		
./wp/ap/xp/ap_Dialog_Paragraph.cpp-510-		{
./wp/ap/xp/ap_Dialog_Paragraph.cpp-511-			ALLOC_PROP_PAIR(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-512-			UT_XML_cloneString(p->prop, "orphans");
./wp/ap/xp/ap_Dialog_Paragraph.cpp-513-		
./wp/ap/xp/ap_Dialog_Paragraph.cpp-556-			UT_XML_cloneString(p->val, "no");
./wp/ap/xp/ap_Dialog_Paragraph.cpp-557-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-558-		v.addItem(p);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-559-	}
./wp/ap/xp/ap_Dialog_Paragraph.cpp-560-
./wp/ap/xp/ap_Dialog_Paragraph.cpp:561:	// TODO : add these to PP_Property (pp_Property.cpp) !!!
./wp/ap/xp/ap_Dialog_Paragraph.cpp-562-	/*
./wp/ap/xp/ap_Dialog_Paragraph.cpp-563-	  m_pageBreakBefore;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-564-	  m_suppressLineNumbers;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-565-	  m_noHyphenate;
./wp/ap/xp/ap_Dialog_Paragraph.cpp-566-	*/
./wp/ap/xp/ap_Dialog_Paragraph.cpp-655-	
./wp/ap/xp/ap_Dialog_Paragraph.cpp-656-	UT_ASSERT(m_paragraphPreview);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-657-	
./wp/ap/xp/ap_Dialog_Paragraph.cpp-658-	m_paragraphPreview->setWindowSize(width, height);
./wp/ap/xp/ap_Dialog_Paragraph.cpp-659-
./wp/ap/xp/ap_Dialog_Paragraph.cpp:660:	// TODO : any setup of the GC for drawing
./wp/ap/xp/ap_Dialog_Paragraph.cpp-661-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-662-}
./wp/ap/xp/ap_Dialog_Paragraph.cpp-663-
./wp/ap/xp/ap_Dialog_Paragraph.cpp-664-void AP_Dialog_Paragraph::_setMenuItemValue(tControl item, UT_sint32 value,
./wp/ap/xp/ap_Dialog_Paragraph.cpp-665-											tOperation op /* = op_UICHANGE */)
./wp/ap/xp/ap_Dialog_Spell.cpp-206-		  
./wp/ap/xp/ap_Dialog_Spell.cpp-207-	    // for some reason, the spell checker fails on all 1-char words & really big ones
./wp/ap/xp/ap_Dialog_Spell.cpp-208-	    // -this is a limitation in the underlying default checker ispell --JB
./wp/ap/xp/ap_Dialog_Spell.cpp-209-	    if ((m_iWordLength > 1) &&
./wp/ap/xp/ap_Dialog_Spell.cpp-210-		XAP_EncodingManager::instance->noncjk_letters(pBlockText+m_iWordOffset, m_iWordLength) && 
./wp/ap/xp/ap_Dialog_Spell.cpp:211:		(!checkCaps || !bAllUpperCase) &&             // TODO: iff relevant Option is set
./wp/ap/xp/ap_Dialog_Spell.cpp-212-		(!UT_UCS_isdigit(pBlockText[m_iWordOffset]) &&
./wp/ap/xp/ap_Dialog_Spell.cpp-213-		 (m_iWordLength < 100))) {
./wp/ap/xp/ap_Dialog_Spell.cpp-214-	    
./wp/ap/xp/ap_Dialog_Spell.cpp-215-	       // try testing our current change all lists
./wp/ap/xp/ap_Dialog_Spell.cpp-216-		  if (!inChangeAll()) {
./wp/ap/xp/ap_Dialog_Spell.cpp-417-   
./wp/ap/xp/ap_Dialog_Spell.cpp-418-   return postword;
./wp/ap/xp/ap_Dialog_Spell.cpp-419-}
./wp/ap/xp/ap_Dialog_Spell.cpp-420-
./wp/ap/xp/ap_Dialog_Spell.cpp-421-
./wp/ap/xp/ap_Dialog_Spell.cpp:422:// TODO  This function finds the beginning and end of a sentence enclosing
./wp/ap/xp/ap_Dialog_Spell.cpp:423:// TODO  the current misspelled word. Right now, it starts from the word
./wp/ap/xp/ap_Dialog_Spell.cpp:424:// TODO  and works forward/backward until finding [.!?] or EOB
./wp/ap/xp/ap_Dialog_Spell.cpp:425:// TODO  This needs to be improved badly. However, I can't think of a 
./wp/ap/xp/ap_Dialog_Spell.cpp:426:// TODO  algorithm to do so -- especially not one which could work with
./wp/ap/xp/ap_Dialog_Spell.cpp:427:// TODO  other languages very well...
./wp/ap/xp/ap_Dialog_Spell.cpp:428:// TODO  Anyone have something better?
./wp/ap/xp/ap_Dialog_Spell.cpp-429-
./wp/ap/xp/ap_Dialog_Spell.cpp-430-void AP_Dialog_Spell::_updateSentenceBoundaries(void)
./wp/ap/xp/ap_Dialog_Spell.cpp-431-{
./wp/ap/xp/ap_Dialog_Spell.cpp-432-   
./wp/ap/xp/ap_Dialog_Spell.cpp-433-   UT_UCSChar* pBlockText = m_pBlockBuf->getPointer(0);
./wp/ap/xp/ap_Dialog_Tab.cpp-416-{
./wp/ap/xp/ap_Dialog_Tab.cpp-417-	// get current value from member
./wp/ap/xp/ap_Dialog_Tab.cpp-418-	const XML_Char* szOld = _gatherTabEdit();
./wp/ap/xp/ap_Dialog_Tab.cpp-419-	const XML_Char* szNew = UT_reformatDimensionString(m_dim, szOld); 
./wp/ap/xp/ap_Dialog_Tab.cpp-420-
./wp/ap/xp/ap_Dialog_Tab.cpp:421:	// TODO - use snprintf
./wp/ap/xp/ap_Dialog_Tab.cpp-422-
./wp/ap/xp/ap_Dialog_Tab.cpp-423-	sprintf( buffer, "%s/%c", szNew, AlignmentToChar(_gatherAlignment()));
./wp/ap/xp/ap_Dialog_Tab.cpp-424-}
./wp/ap/xp/ap_Dialog_Tab.cpp-425-
./wp/ap/xp/ap_Dialog_Tab.cpp-426-void AP_Dialog_Tab::_event_somethingChanged()
./wp/ap/xp/ap_Dialog_Tab.cpp-627-	const XML_Char* szNew = UT_formatDimensionString(dimSpin, d, szPrecision); 
./wp/ap/xp/ap_Dialog_Tab.cpp-628-
./wp/ap/xp/ap_Dialog_Tab.cpp-629-	_setDefaultTabStop(szNew);
./wp/ap/xp/ap_Dialog_Tab.cpp-630-}
./wp/ap/xp/ap_Dialog_Tab.cpp-631-
./wp/ap/xp/ap_Dialog_Tab.cpp:632://TODO: Roll this function and the above into one function.
./wp/ap/xp/ap_Dialog_Tab.cpp-633-//      Most things will increment for us so we just need to bound
./wp/ap/xp/ap_Dialog_Tab.cpp-634-//      limit and make sure the settings are correct.
./wp/ap/xp/ap_Dialog_Tab.cpp-635-void AP_Dialog_Tab::_doSpinValue(tControl id, double value)
./wp/ap/xp/ap_Dialog_Tab.cpp-636-{
./wp/ap/xp/ap_Dialog_Tab.cpp-637-  //	UT_ASSERT(amt); // zero makes no sense
./wp/ap/xp/ap_EditMethods.cpp-218-	static EV_EditMethod_Fn insertCedillaData;
./wp/ap/xp/ap_EditMethods.cpp-219-	static EV_EditMethod_Fn insertOgonekData;
./wp/ap/xp/ap_EditMethods.cpp-220-
./wp/ap/xp/ap_EditMethods.cpp-221-	static EV_EditMethod_Fn replaceChar;
./wp/ap/xp/ap_EditMethods.cpp-222-
./wp/ap/xp/ap_EditMethods.cpp:223:	// TODO add functions for all of the standard menu commands.
./wp/ap/xp/ap_EditMethods.cpp:224:	// TODO here are a few that i started.
./wp/ap/xp/ap_EditMethods.cpp-225-
./wp/ap/xp/ap_EditMethods.cpp-226-	static EV_EditMethod_Fn fileNew;
./wp/ap/xp/ap_EditMethods.cpp-227-	static EV_EditMethod_Fn fileOpen;
./wp/ap/xp/ap_EditMethods.cpp-228-	static EV_EditMethod_Fn fileSave;
./wp/ap/xp/ap_EditMethods.cpp-229-	static EV_EditMethod_Fn fileSaveAs;
./wp/ap/xp/ap_EditMethods.cpp-814-}
./wp/ap/xp/ap_EditMethods.cpp-815-
./wp/ap/xp/ap_EditMethods.cpp-816-/*****************************************************************/
./wp/ap/xp/ap_EditMethods.cpp-817-/*****************************************************************/
./wp/ap/xp/ap_EditMethods.cpp-818-
./wp/ap/xp/ap_EditMethods.cpp:819:// TODO i've pulled the code to compose a question in a message
./wp/ap/xp/ap_EditMethods.cpp:820:// TODO box into these little s_Ask*() functions.  part of this
./wp/ap/xp/ap_EditMethods.cpp:821:// TODO is to isolate the question asking from the code which
./wp/ap/xp/ap_EditMethods.cpp:822:// TODO decides what to do with the answer.  but also to see if
./wp/ap/xp/ap_EditMethods.cpp:823:// TODO we want to abstract things further and make us think about
./wp/ap/xp/ap_EditMethods.cpp:824:// TODO localization of the question strings....
./wp/ap/xp/ap_EditMethods.cpp-825-
./wp/ap/xp/ap_EditMethods.cpp-826-static void s_TellSaveFailed(XAP_Frame * pFrame, const char * fileName, UT_Error errorCode)
./wp/ap/xp/ap_EditMethods.cpp-827-{
./wp/ap/xp/ap_EditMethods.cpp-828-	XAP_String_Id String_id;
./wp/ap/xp/ap_EditMethods.cpp-829-	
./wp/ap/xp/ap_EditMethods.cpp-1242-			pNewFrame->show();
./wp/ap/xp/ap_EditMethods.cpp-1243-			pPrefs->addRecent(pNewFile);
./wp/ap/xp/ap_EditMethods.cpp-1244-		}
./wp/ap/xp/ap_EditMethods.cpp-1245-		else
./wp/ap/xp/ap_EditMethods.cpp-1246-		{
./wp/ap/xp/ap_EditMethods.cpp:1247:			// TODO there is a problem with the way we create a
./wp/ap/xp/ap_EditMethods.cpp:1248:			// TODO new frame and then load a documentent into
./wp/ap/xp/ap_EditMethods.cpp:1249:			// TODO it.  if we try to load pNewFile and fail,
./wp/ap/xp/ap_EditMethods.cpp:1250:			// TODO and then destroy the window, and raise a
./wp/ap/xp/ap_EditMethods.cpp:1251:			// TODO message box (on the original window) we get
./wp/ap/xp/ap_EditMethods.cpp:1252:			// TODO nasty race on UNIX.  raising the dialog and
./wp/ap/xp/ap_EditMethods.cpp:1253:			// TODO waiting for input flushes out the show-windows
./wp/ap/xp/ap_EditMethods.cpp:1254:			// TODO on the new (and not yet completely instantiated)
./wp/ap/xp/ap_EditMethods.cpp:1255:			// TODO window.  this causes a view-less top-level
./wp/ap/xp/ap_EditMethods.cpp:1256:			// TODO window to appear -- which causes lots of
./wp/ap/xp/ap_EditMethods.cpp:1257:			// TODO expose-related problems... and then other
./wp/ap/xp/ap_EditMethods.cpp:1258:			// TODO problems which appear to be related to having
./wp/ap/xp/ap_EditMethods.cpp:1259:			// TODO multiple gtk_main()'s on the stack....
./wp/ap/xp/ap_EditMethods.cpp:1260:			// TODO
./wp/ap/xp/ap_EditMethods.cpp:1261:			// TODO for now, we force a new untitled document into
./wp/ap/xp/ap_EditMethods.cpp:1262:			// TODO the new window and then raise the message on
./wp/ap/xp/ap_EditMethods.cpp:1263:			// TODO this new window.
./wp/ap/xp/ap_EditMethods.cpp:1264:			// TODO
./wp/ap/xp/ap_EditMethods.cpp:1265:			// TODO long term, we may want to modified pApp->newFrame()
./wp/ap/xp/ap_EditMethods.cpp:1266:			// TODO to take an 'UT_Bool bShowWindow' argument....
./wp/ap/xp/ap_EditMethods.cpp-1267-
./wp/ap/xp/ap_EditMethods.cpp-1268-			// the IEFileType here doesn't really matter since the file name is NULL
./wp/ap/xp/ap_EditMethods.cpp-1269-			errorCode = pNewFrame->loadDocument(NULL, IEFT_Unknown);
./wp/ap/xp/ap_EditMethods.cpp-1270-			if (!errorCode)
./wp/ap/xp/ap_EditMethods.cpp-1271-				pNewFrame->show();
./wp/ap/xp/ap_EditMethods.cpp-1421-	UT_ASSERT(ndx > 0);
./wp/ap/xp/ap_EditMethods.cpp-1422-	UT_ASSERT(ndx <= pPrefs->getRecentCount());
./wp/ap/xp/ap_EditMethods.cpp-1423-
./wp/ap/xp/ap_EditMethods.cpp-1424-	const char * szRecent = pPrefs->getRecent(ndx);
./wp/ap/xp/ap_EditMethods.cpp-1425-
./wp/ap/xp/ap_EditMethods.cpp:1426:	// TODO HACK BROKEN BUSTED BLAH WARNING NOTE ERROR
./wp/ap/xp/ap_EditMethods.cpp-1427-	// BROKEN: We should store some sort of file type with the MRU data
./wp/ap/xp/ap_EditMethods.cpp-1428-	// BROKEN: or we don't know what to open it as!  We can't assume
./wp/ap/xp/ap_EditMethods.cpp-1429-	// BROKEN: IEFT_Unknown will detect what the user saved it as,
./wp/ap/xp/ap_EditMethods.cpp-1430-	// BROKEN: since the user can explictly export as any type.
./wp/ap/xp/ap_EditMethods.cpp:1431:	// TODO HACK BROKEN BUSTED BLAH WARNING NOTE ERROR
./wp/ap/xp/ap_EditMethods.cpp-1432-	
./wp/ap/xp/ap_EditMethods.cpp-1433-	UT_Error error = fileOpen(pFrame, szRecent, IEFT_Unknown);
./wp/ap/xp/ap_EditMethods.cpp-1434-
./wp/ap/xp/ap_EditMethods.cpp-1435-	if (error)
./wp/ap/xp/ap_EditMethods.cpp-1436-		pPrefs->removeRecent(ndx);
./wp/ap/xp/ap_EditMethods.cpp-1639-		tmpURL = helpURL;
./wp/ap/xp/ap_EditMethods.cpp-1640-		helpURL = UT_catPathname(helpURL, pathAfterLang);
./wp/ap/xp/ap_EditMethods.cpp-1641-		FREEP(tmpURL);
./wp/ap/xp/ap_EditMethods.cpp-1642-	}
./wp/ap/xp/ap_EditMethods.cpp-1643-	else {
./wp/ap/xp/ap_EditMethods.cpp:1644:		//TODO: No one uses this, so what kind of prefix should it have?
./wp/ap/xp/ap_EditMethods.cpp-1645-		tmpURL = helpURL = UT_catPathname(pathBeforeLang, abiSuiteLocString);
./wp/ap/xp/ap_EditMethods.cpp-1646-		helpURL = UT_catPathname(helpURL, pathAfterLang);
./wp/ap/xp/ap_EditMethods.cpp-1647-		FREEP(tmpURL);
./wp/ap/xp/ap_EditMethods.cpp-1648-	}
./wp/ap/xp/ap_EditMethods.cpp-1649-
./wp/ap/xp/ap_EditMethods.cpp-1827-	{
./wp/ap/xp/ap_EditMethods.cpp-1828-
./wp/ap/xp/ap_EditMethods.cpp-1829- 	        //  delete all open modeless dialogs
./wp/ap/xp/ap_EditMethods.cpp-1830-	        pApp->closeModelessDlgs();
./wp/ap/xp/ap_EditMethods.cpp-1831-
./wp/ap/xp/ap_EditMethods.cpp:1832:		// TODO: this shouldn't be necessary, but just in case
./wp/ap/xp/ap_EditMethods.cpp-1833-		pApp->reallyExit();
./wp/ap/xp/ap_EditMethods.cpp-1834-	}
./wp/ap/xp/ap_EditMethods.cpp-1835-
./wp/ap/xp/ap_EditMethods.cpp-1836-	return bRet;
./wp/ap/xp/ap_EditMethods.cpp-1837-}
./wp/ap/xp/ap_EditMethods.cpp-2079-	return UT_TRUE;
./wp/ap/xp/ap_EditMethods.cpp-2080-}
./wp/ap/xp/ap_EditMethods.cpp-2081-
./wp/ap/xp/ap_EditMethods.cpp-2082-Defun1(cursorImageSize)
./wp/ap/xp/ap_EditMethods.cpp-2083-{
./wp/ap/xp/ap_EditMethods.cpp:2084:	// TODO figure out which corner or side we are on and
./wp/ap/xp/ap_EditMethods.cpp:2085:	// TODO map cursor to one of the standard 8 resizers.
./wp/ap/xp/ap_EditMethods.cpp-2086-	ABIWORD_VIEW;
./wp/ap/xp/ap_EditMethods.cpp-2087-	GR_Graphics * pG = pView->getGraphics();
./wp/ap/xp/ap_EditMethods.cpp-2088-	if (pG)
./wp/ap/xp/ap_EditMethods.cpp-2089-		pG->setCursor(GR_Graphics::GR_CURSOR_IBEAM);
./wp/ap/xp/ap_EditMethods.cpp-2090-	return UT_TRUE;
./wp/ap/xp/ap_EditMethods.cpp-2820-	case 0x43:		abovedotChar=0x02c5;	break;	// Cabovedot
./wp/ap/xp/ap_EditMethods.cpp-2821-	case 0x47:		abovedotChar=0x02d5;	break;	// Gabovedot
./wp/ap/xp/ap_EditMethods.cpp-2822-	case 0x45:		abovedotChar=0x03cc;	break;	// Eabovedot
./wp/ap/xp/ap_EditMethods.cpp-2823-
./wp/ap/xp/ap_EditMethods.cpp-2824-	case 0x7a:		abovedotChar=0x01bf;	break;	// zabovedot
./wp/ap/xp/ap_EditMethods.cpp:2825:	//case 0x69: TODO no corresponding 'iabovedot', is this supposed to be 'idotless' ??
./wp/ap/xp/ap_EditMethods.cpp-2826-	case 0x63:		abovedotChar=0x02e5;	break;	// cabovedot
./wp/ap/xp/ap_EditMethods.cpp-2827-	case 0x67:		abovedotChar=0x02f5;	break;	// gabovedot
./wp/ap/xp/ap_EditMethods.cpp-2828-	case 0x65:		abovedotChar=0x03ec;	break;	// eabovedot
./wp/ap/xp/ap_EditMethods.cpp-2829-
./wp/ap/xp/ap_EditMethods.cpp-2830-	default:
./wp/ap/xp/ap_EditMethods.cpp-2854-	case 0x41:		diaeresisChar=0x00c4;	break;	// Adiaeresis
./wp/ap/xp/ap_EditMethods.cpp-2855-	case 0x45:		diaeresisChar=0x00cb;	break;	// Ediaeresis
./wp/ap/xp/ap_EditMethods.cpp-2856-	case 0x49:		diaeresisChar=0x00cf;	break;	// Idiaeresis
./wp/ap/xp/ap_EditMethods.cpp-2857-	case 0x4f:		diaeresisChar=0x00d6;	break;	// Odiaeresis
./wp/ap/xp/ap_EditMethods.cpp-2858-	case 0x55:		diaeresisChar=0x00dc;	break;	// Udiaeresis
./wp/ap/xp/ap_EditMethods.cpp:2859:	// TODO no Ydiaeresis ??
./wp/ap/xp/ap_EditMethods.cpp-2860-
./wp/ap/xp/ap_EditMethods.cpp-2861-	case 0x61:		diaeresisChar=0x00e4;	break;	// adiaeresis
./wp/ap/xp/ap_EditMethods.cpp-2862-	case 0x65:		diaeresisChar=0x00eb;	break;	// ediaeresis
./wp/ap/xp/ap_EditMethods.cpp-2863-	case 0x69:		diaeresisChar=0x00ef;	break;	// idiaeresis
./wp/ap/xp/ap_EditMethods.cpp-2864-	case 0x6f:		diaeresisChar=0x00f6;	break;	// odiaeresis
./wp/ap/xp/ap_EditMethods.cpp-3767-	pDialog->setDocumentTitle(pFrame->getTempNameFromTitle());
./wp/ap/xp/ap_EditMethods.cpp-3768-	pDialog->setDocumentPathname((doc->getFilename())
./wp/ap/xp/ap_EditMethods.cpp-3769-								 ? doc->getFilename()
./wp/ap/xp/ap_EditMethods.cpp-3770-								 : pFrame->getTempNameFromTitle());
./wp/ap/xp/ap_EditMethods.cpp-3771-	pDialog->setEnablePageRangeButton(UT_TRUE,1,pLayout->countPages());
./wp/ap/xp/ap_EditMethods.cpp:3772:	pDialog->setEnablePrintSelection(UT_FALSE);	// TODO change this when we know how to do it.
./wp/ap/xp/ap_EditMethods.cpp-3773-	pDialog->setEnablePrintToFile(UT_TRUE);
./wp/ap/xp/ap_EditMethods.cpp-3774-	pDialog->setTryToBypassActualDialog(bTryToSuppressDialog);
./wp/ap/xp/ap_EditMethods.cpp-3775-
./wp/ap/xp/ap_EditMethods.cpp-3776-	pDialog->runModal(pFrame);
./wp/ap/xp/ap_EditMethods.cpp-3777-
./wp/ap/xp/ap_EditMethods.cpp-3792-		if (nToPage > pDocLayout->countPages())
./wp/ap/xp/ap_EditMethods.cpp-3793-		{
./wp/ap/xp/ap_EditMethods.cpp-3794-			nToPage = pDocLayout->countPages();
./wp/ap/xp/ap_EditMethods.cpp-3795-		}
./wp/ap/xp/ap_EditMethods.cpp-3796-		
./wp/ap/xp/ap_EditMethods.cpp:3797:		// TODO add code to handle getDoPrintSelection()
./wp/ap/xp/ap_EditMethods.cpp-3798-
./wp/ap/xp/ap_EditMethods.cpp-3799-		UT_uint32 nCopies = pDialog->getNrCopies();
./wp/ap/xp/ap_EditMethods.cpp-3800-		UT_Bool bCollate = pDialog->getCollate();
./wp/ap/xp/ap_EditMethods.cpp-3801-
./wp/ap/xp/ap_EditMethods.cpp:3802:		// TODO these are here temporarily to make printing work.  We'll fix the hack later.
./wp/ap/xp/ap_EditMethods.cpp-3803-		// BUGBUG assumes all pages are same size and orientation
./wp/ap/xp/ap_EditMethods.cpp-3804-		UT_sint32 iWidth = pDocLayout->getWidth();
./wp/ap/xp/ap_EditMethods.cpp-3805-		UT_sint32 iHeight = pDocLayout->getHeight() / pDocLayout->countPages();
./wp/ap/xp/ap_EditMethods.cpp-3806-
./wp/ap/xp/ap_EditMethods.cpp-3807-		const char *pDocName = ((doc->getFilename()) ? doc->getFilename() : pFrame->getTempNameFromTitle());
./wp/ap/xp/ap_EditMethods.cpp-3859-	  }
./wp/ap/xp/ap_EditMethods.cpp-3860-		
./wp/ap/xp/ap_EditMethods.cpp-3861-	UT_uint32 nCopies = 1;
./wp/ap/xp/ap_EditMethods.cpp-3862-	UT_Bool bCollate  = UT_FALSE;
./wp/ap/xp/ap_EditMethods.cpp-3863-	
./wp/ap/xp/ap_EditMethods.cpp:3864:	// TODO these are here temporarily to make printing work.  We'll fix the hack later.
./wp/ap/xp/ap_EditMethods.cpp-3865-	// BUGBUG assumes all pages are same size and orientation
./wp/ap/xp/ap_EditMethods.cpp-3866-	UT_sint32 iWidth = pDocLayout->getWidth();
./wp/ap/xp/ap_EditMethods.cpp-3867-	UT_sint32 iHeight = pDocLayout->getHeight() / pDocLayout->countPages();
./wp/ap/xp/ap_EditMethods.cpp-3868-	
./wp/ap/xp/ap_EditMethods.cpp-3869-	const char *pDocName = ((doc->getFilename()) ? doc->getFilename() : pFrame->getTempNameFromTitle());
./wp/ap/xp/ap_EditMethods.cpp-4094-/*****************************************************************/
./wp/ap/xp/ap_EditMethods.cpp-4095-/*****************************************************************/
./wp/ap/xp/ap_EditMethods.cpp-4096-
./wp/ap/xp/ap_EditMethods.cpp-4097-Defun1(viewStd)
./wp/ap/xp/ap_EditMethods.cpp-4098-{
./wp/ap/xp/ap_EditMethods.cpp:4099:	// TODO: Share this function with viewFormat & viewExtra
./wp/ap/xp/ap_EditMethods.cpp-4100-	XAP_Frame * pFrame = static_cast<XAP_Frame *> ( pAV_View->getParentData());
./wp/ap/xp/ap_EditMethods.cpp-4101-	UT_ASSERT(pFrame);
./wp/ap/xp/ap_EditMethods.cpp-4102-
./wp/ap/xp/ap_EditMethods.cpp-4103-	AP_FrameData *pFrameData = (AP_FrameData *)pFrame->getFrameData();
./wp/ap/xp/ap_EditMethods.cpp-4104-	UT_ASSERT(pFrameData);
./wp/ap/xp/ap_EditMethods.cpp-4261-Defun1(viewHeadFoot)
./wp/ap/xp/ap_EditMethods.cpp-4262-{
./wp/ap/xp/ap_EditMethods.cpp-4263-	XAP_Frame * pFrame = static_cast<XAP_Frame *> ( pAV_View->getParentData());
./wp/ap/xp/ap_EditMethods.cpp-4264-	UT_ASSERT(pFrame);
./wp/ap/xp/ap_EditMethods.cpp-4265-
./wp/ap/xp/ap_EditMethods.cpp:4266:	// TODO: synch this implementation with ap_GetState_View
./wp/ap/xp/ap_EditMethods.cpp-4267-	s_TellNotImplemented(pFrame, "View Headers and Footers", __LINE__);
./wp/ap/xp/ap_EditMethods.cpp-4268-	return UT_TRUE;
./wp/ap/xp/ap_EditMethods.cpp-4269-}
./wp/ap/xp/ap_EditMethods.cpp-4270-
./wp/ap/xp/ap_EditMethods.cpp-4271-Defun(zoom)
./wp/ap/xp/ap_EditMethods.cpp-4273-	ABIWORD_VIEW;
./wp/ap/xp/ap_EditMethods.cpp-4274-
./wp/ap/xp/ap_EditMethods.cpp-4275-	XAP_Frame * pFrame = static_cast<XAP_Frame *> ( pAV_View->getParentData());
./wp/ap/xp/ap_EditMethods.cpp-4276-	UT_ASSERT(pFrame);
./wp/ap/xp/ap_EditMethods.cpp-4277-
./wp/ap/xp/ap_EditMethods.cpp:4278:	// TODO the cast below is ugly
./wp/ap/xp/ap_EditMethods.cpp-4279-
./wp/ap/xp/ap_EditMethods.cpp-4280-	UT_uint32 iZoom = 0;
./wp/ap/xp/ap_EditMethods.cpp-4281-	char *p_zoom = (char*) (pCallData->m_pData);
./wp/ap/xp/ap_EditMethods.cpp-4282-
./wp/ap/xp/ap_EditMethods.cpp-4283-	const XAP_StringSet * pSS = XAP_App::getApp()->getStringSet();
./wp/ap/xp/ap_EditMethods.cpp-4430-
./wp/ap/xp/ap_EditMethods.cpp-4431-	pDialog->runModal(pFrame);
./wp/ap/xp/ap_EditMethods.cpp-4432-
./wp/ap/xp/ap_EditMethods.cpp-4433-	if (pDialog->getAnswer() == AP_Dialog_Field::a_OK)
./wp/ap/xp/ap_EditMethods.cpp-4434-	{
./wp/ap/xp/ap_EditMethods.cpp:4435:		// TODO - Insert field correctly
./wp/ap/xp/ap_EditMethods.cpp-4436-		pView->cmdInsertField(pDialog->GetFieldFormat());
./wp/ap/xp/ap_EditMethods.cpp-4437-	}
./wp/ap/xp/ap_EditMethods.cpp-4438-
./wp/ap/xp/ap_EditMethods.cpp-4439-	pDialogFactory->releaseDialog(pDialog);
./wp/ap/xp/ap_EditMethods.cpp-4440-
./wp/ap/xp/ap_EditMethods.cpp-4827-	return UT_TRUE;
./wp/ap/xp/ap_EditMethods.cpp-4828-}
./wp/ap/xp/ap_EditMethods.cpp-4829-
./wp/ap/xp/ap_EditMethods.cpp-4830-Defun0(togglePlain)
./wp/ap/xp/ap_EditMethods.cpp-4831-{
./wp/ap/xp/ap_EditMethods.cpp:4832:	// TODO: remove all character-level formatting
./wp/ap/xp/ap_EditMethods.cpp-4833-	// HYP: explicitly delete it, to get back to defaults, styles
./wp/ap/xp/ap_EditMethods.cpp-4834-	return UT_TRUE;
./wp/ap/xp/ap_EditMethods.cpp-4835-}
./wp/ap/xp/ap_EditMethods.cpp-4836-
./wp/ap/xp/ap_EditMethods.cpp-4837-Defun1(alignLeft)
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-54-	{0x41, /* A      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-55-	{0x45, /* E      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-56-	{0x49, /* I      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-57-	{0x4f, /* O      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-58-	{0x55, /* U      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp:59:	// TODO no Y ??
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-60-	{0x61, /* a      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-61-	{0x65, /* e      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-62-	{0x69, /* i      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-63-	{0x6f, /* o      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_DeadDiaeresis.cpp-64-	{0x75, /* u      */ { "insertDiaeresisData",		"",		"",		""		}},
./wp/ap/xp/ap_LB_Default.cpp-65-#define _B5		| EV_EMB_BUTTON5
./wp/ap/xp/ap_LB_Default.cpp-66-
./wp/ap/xp/ap_LB_Default.cpp-67-ap_bs_Mouse MouseTable[] =
./wp/ap/xp/ap_LB_Default.cpp-68-{
./wp/ap/xp/ap_LB_Default.cpp-69-
./wp/ap/xp/ap_LB_Default.cpp:70:	// TODO some of these bindings are what i think they
./wp/ap/xp/ap_LB_Default.cpp:71:	// TODO should be and some are just for testing until
./wp/ap/xp/ap_LB_Default.cpp:72:	// TODO the full features are implemented.  some i've
./wp/ap/xp/ap_LB_Default.cpp:73:	// TODO just filled in some guesses, but never used.
./wp/ap/xp/ap_LB_Default.cpp-74-	
./wp/ap/xp/ap_LB_Default.cpp-75-//	Button-0 (no buttons pressed)
./wp/ap/xp/ap_LB_Default.cpp-76-//  { context	{ click	dblclick	drag,				dbldrag,	release,	doublerelease	}},
./wp/ap/xp/ap_LB_Default.cpp-77-	{_CU _B0,	{ "",	"",			"cursorDefault",	"",			"",			""				}},
./wp/ap/xp/ap_LB_Default.cpp-78-	{_CT _B0,	{ "",	"",			"cursorIBeam",		"",			"",			""				}},
./wp/ap/xp/ap_LB_Default.cpp-402-//	that the set is reasonably complete.
./wp/ap/xp/ap_LB_Default.cpp-403-//	
./wp/ap/xp/ap_LB_Default.cpp-404-//	I don't know how to test these on my en-US system with my en-US keyboard,
./wp/ap/xp/ap_LB_Default.cpp-405-//	but I think they will work.
./wp/ap/xp/ap_LB_Default.cpp-406-//
./wp/ap/xp/ap_LB_Default.cpp:407://	TODO For now I just bound them all to "insertData" which will cause
./wp/ap/xp/ap_LB_Default.cpp:408://	TODO the character to be inserted into the document.  I'm wondering
./wp/ap/xp/ap_LB_Default.cpp:409://	TODO if some of these (e.g., paragraph and section) should be bound
./wp/ap/xp/ap_LB_Default.cpp:410://	TODO to some other functions -- but rather than try guessing, let's
./wp/ap/xp/ap_LB_Default.cpp:411://	TODO wait and let some of our European friends comment.
./wp/ap/xp/ap_LB_Default.cpp-412-
./wp/ap/xp/ap_LB_Default.cpp-413-//	{char, /* desc           */ { none,				_C,					_A,				_A_C				}},
./wp/ap/xp/ap_LB_Default.cpp-414-
./wp/ap/xp/ap_LB_Default.cpp-415-	{0xa0, /* nbs            */ { "insertNBSpace",	"",					"",				""					}},
./wp/ap/xp/ap_LB_Default.cpp-416-	{0xa1, /* exclamdown     */ { "insertData",		"",					"",				""					}},
./wp/ap/xp/ap_LB_Emacs.cpp-180-//	that the set is reasonably complete.
./wp/ap/xp/ap_LB_Emacs.cpp-181-//	
./wp/ap/xp/ap_LB_Emacs.cpp-182-//	I don't know how to test these on my en-US system with my en-US keyboard,
./wp/ap/xp/ap_LB_Emacs.cpp-183-//	but I think they will work.
./wp/ap/xp/ap_LB_Emacs.cpp-184-//
./wp/ap/xp/ap_LB_Emacs.cpp:185://	TODO For now I just bound them all to "insertData" which will cause
./wp/ap/xp/ap_LB_Emacs.cpp:186://	TODO the character to be inserted into the document.  I'm wondering
./wp/ap/xp/ap_LB_Emacs.cpp:187://	TODO if some of these (e.g., paragraph and section) should be bound
./wp/ap/xp/ap_LB_Emacs.cpp:188://	TODO to some other functions -- but rather than try guessing, let's
./wp/ap/xp/ap_LB_Emacs.cpp:189://	TODO wait and let some of our European friends comment.
./wp/ap/xp/ap_LB_Emacs.cpp-190-
./wp/ap/xp/ap_LB_Emacs.cpp-191-//	{char, /* desc           */ { none,				_C,					_A,				_A_C				}},
./wp/ap/xp/ap_LB_Emacs.cpp-192-
./wp/ap/xp/ap_LB_Emacs.cpp-193-	{0xa0, /* nbs            */ { "insertNBSpace",	"",					"",				""					}},
./wp/ap/xp/ap_LB_Emacs.cpp-194-	{0xa1, /* exclamdown     */ { "insertData",		"",					"",				""					}},
./wp/ap/xp/ap_LB_viEdit.cpp-178-//	that the set is reasonably complete.
./wp/ap/xp/ap_LB_viEdit.cpp-179-//	
./wp/ap/xp/ap_LB_viEdit.cpp-180-//	I don't know how to test these on my en-US system with my en-US keyboard,
./wp/ap/xp/ap_LB_viEdit.cpp-181-//	but I think they will work.
./wp/ap/xp/ap_LB_viEdit.cpp-182-//
./wp/ap/xp/ap_LB_viEdit.cpp:183://	TODO For now I just bound them all to "insertData" which will cause
./wp/ap/xp/ap_LB_viEdit.cpp:184://	TODO the character to be inserted into the document.  I'm wondering
./wp/ap/xp/ap_LB_viEdit.cpp:185://	TODO if some of these (e.g., paragraph and section) should be bound
./wp/ap/xp/ap_LB_viEdit.cpp:186://	TODO to some other functions -- but rather than try guessing, let's
./wp/ap/xp/ap_LB_viEdit.cpp:187://	TODO wait and let some of our European friends comment.
./wp/ap/xp/ap_LB_viEdit.cpp-188-
./wp/ap/xp/ap_LB_viEdit.cpp-189-//	{char, /* desc           */ { none,				_C,					_A,				_A_C				}},
./wp/ap/xp/ap_LB_viEdit.cpp-190-
./wp/ap/xp/ap_LB_viEdit.cpp-191-	{0xa0, /* nbs            */ { "",	"",					"",				""					}},
./wp/ap/xp/ap_LB_viEdit.cpp-192-	{0xa1, /* exclamdown     */ { "",		"",					"",				""					}},
./wp/ap/xp/ap_LB_viEdit_r.cpp-130-//	that the set is reasonably complete.
./wp/ap/xp/ap_LB_viEdit_r.cpp-131-//	
./wp/ap/xp/ap_LB_viEdit_r.cpp-132-//	I don't know how to test these on my en-US system with my en-US keyboard,
./wp/ap/xp/ap_LB_viEdit_r.cpp-133-//	but I think they will work.
./wp/ap/xp/ap_LB_viEdit_r.cpp-134-//
./wp/ap/xp/ap_LB_viEdit_r.cpp:135://	TODO For now I just bound them all to "replaceChar" which will cause
./wp/ap/xp/ap_LB_viEdit_r.cpp:136://	TODO the character to be inserted into the document.  I'm wondering
./wp/ap/xp/ap_LB_viEdit_r.cpp:137://	TODO if some of these (e.g., paragraph and section) should be bound
./wp/ap/xp/ap_LB_viEdit_r.cpp:138://	TODO to some other functions -- but rather than try guessing, let's
./wp/ap/xp/ap_LB_viEdit_r.cpp:139://	TODO wait and let some of our European friends comment.
./wp/ap/xp/ap_LB_viEdit_r.cpp-140-
./wp/ap/xp/ap_LB_viEdit_r.cpp-141-//	{char, /* desc           */ { none,				_C,					_A,				_A_C				}},
./wp/ap/xp/ap_LB_viEdit_r.cpp-142-
./wp/ap/xp/ap_LB_viEdit_r.cpp-143-	{0xa0, /* nbs            */ { "insertNBSpace",	"",					"",				""					}},
./wp/ap/xp/ap_LB_viEdit_r.cpp-144-	{0xa1, /* exclamdown     */ { "replaceChar",		"",					"",				""					}},
./wp/ap/xp/ap_Menu_Functions.cpp-621-            s = EV_MIS_Toggled;
./wp/ap/xp/ap_Menu_Functions.cpp-622-        else
./wp/ap/xp/ap_Menu_Functions.cpp-623-            s = EV_MIS_ZERO;
./wp/ap/xp/ap_Menu_Functions.cpp-624-        break;
./wp/ap/xp/ap_Menu_Functions.cpp-625-	case AP_MENU_ID_VIEW_HEADFOOT:
./wp/ap/xp/ap_Menu_Functions.cpp:626:		// TODO: implement view methods to check, toggle state
./wp/ap/xp/ap_Menu_Functions.cpp-627-		s = EV_MIS_Gray;
./wp/ap/xp/ap_Menu_Functions.cpp-628-		break;
./wp/ap/xp/ap_Menu_Functions.cpp-629-	case AP_MENU_ID_VIEW_TB_STD:
./wp/ap/xp/ap_Menu_Functions.cpp-630-		if ( pFrameData->m_bShowBar[0] ) 
./wp/ap/xp/ap_Menu_Functions.cpp-631-			s = EV_MIS_Toggled;
./wp/ap/xp/ap_Prefs.cpp-56-	// in the <select...> of the user's profile.  note,
./wp/ap/xp/ap_Prefs.cpp-57-	// we do not do any reinterpretation of the user's
./wp/ap/xp/ap_Prefs.cpp-58-	// disk settings (that is, we do not overlay the
./wp/ap/xp/ap_Prefs.cpp-59-	// environment onto explicitly set user preferences).
./wp/ap/xp/ap_Prefs.cpp-60-	//
./wp/ap/xp/ap_Prefs.cpp:61:	// TODO overlay command line arguments onto preferences...
./wp/ap/xp/ap_Prefs.cpp-62-
./wp/ap/xp/ap_Prefs.cpp-63-	// group all the prefListener signals into one block change
./wp/ap/xp/ap_Prefs.cpp-64-	startBlockChange();	
./wp/ap/xp/ap_Prefs.cpp-65-
./wp/ap/xp/ap_Prefs.cpp-66-	loadBuiltinPrefs();
./wp/ap/xp/ap_Preview_Paragraph.cpp-224-			break;
./wp/ap/xp/ap_Preview_Paragraph.cpp-225-		case AP_Dialog_Paragraph::spacing_DOUBLE:
./wp/ap/xp/ap_Preview_Paragraph.cpp-226-			m_lineSpacing = m_fontHeight;
./wp/ap/xp/ap_Preview_Paragraph.cpp-227-			break;
./wp/ap/xp/ap_Preview_Paragraph.cpp-228-		case AP_Dialog_Paragraph::spacing_ATLEAST:
./wp/ap/xp/ap_Preview_Paragraph.cpp:229:			// TODO : THIS IS BROKEN SOMEHOW.  m_lineSpacing should be the number
./wp/ap/xp/ap_Preview_Paragraph.cpp:230:			// TODO : of pixels needed to place before the line (of height
./wp/ap/xp/ap_Preview_Paragraph.cpp:231:			// TODO : m_fontHeight pixels).  
./wp/ap/xp/ap_Preview_Paragraph.cpp-232-			
./wp/ap/xp/ap_Preview_Paragraph.cpp-233-			// we measure from top to top here, and use a minimum of the current
./wp/ap/xp/ap_Preview_Paragraph.cpp-234-			// line height
./wp/ap/xp/ap_Preview_Paragraph.cpp-235-			if (SCALE_TO_PIXELS(lineSpacing) > m_fontHeight)
./wp/ap/xp/ap_Preview_Paragraph.cpp-236-				m_lineSpacing = SCALE_TO_PIXELS(lineSpacing) - m_fontHeight;
./wp/ap/xp/ap_Preview_Paragraph.cpp-635-		i++;
./wp/ap/xp/ap_Preview_Paragraph.cpp-636-	}
./wp/ap/xp/ap_Preview_Paragraph.cpp-637-
./wp/ap/xp/ap_Preview_Paragraph.cpp-638-	// we have "i" words to plot on this line, and they will take pixelsForThisLine space
./wp/ap/xp/ap_Preview_Paragraph.cpp-639-
./wp/ap/xp/ap_Preview_Paragraph.cpp:640:	// TODO : maybe rework following code to remove this variable for more speed
./wp/ap/xp/ap_Preview_Paragraph.cpp-641-	UT_uint32 willDrawAt = left;
./wp/ap/xp/ap_Preview_Paragraph.cpp-642-	spaceCharWidth <<= 8;	// Calculate spacing at 256 times the resolution
./wp/ap/xp/ap_Preview_Paragraph.cpp-643-		
./wp/ap/xp/ap_Preview_Paragraph.cpp-644-	// obey alignment requests
./wp/ap/xp/ap_Preview_Paragraph.cpp-645-	switch(align)
./wp/ap/xp/ap_StatusBar.cpp-254-{
./wp/ap/xp/ap_StatusBar.cpp-255-}
./wp/ap/xp/ap_StatusBar.cpp-256-
./wp/ap/xp/ap_StatusBar.cpp-257-UT_uint32 ap_sb_Field_StatusMessage::getDesiredWidth(void)
./wp/ap/xp/ap_StatusBar.cpp-258-{
./wp/ap/xp/ap_StatusBar.cpp:259:	return 300;							// TODO define this somewhere
./wp/ap/xp/ap_StatusBar.cpp-260-}
./wp/ap/xp/ap_StatusBar.cpp-261-
./wp/ap/xp/ap_StatusBar.cpp-262-void ap_sb_Field_StatusMessage::draw(void)
./wp/ap/xp/ap_StatusBar.cpp-263-{
./wp/ap/xp/ap_StatusBar.cpp-264-	int centertext = 0;
./wp/ap/xp/ap_StatusBar.cpp-307-
./wp/ap/xp/ap_StatusBar.cpp-308-			buffer[0] = '\0';
./wp/ap/xp/ap_StatusBar.cpp-309-			newrect = 
./wp/ap/xp/ap_StatusBar.cpp-310-			greyrect = m_rect3d;
./wp/ap/xp/ap_StatusBar.cpp-311-
./wp/ap/xp/ap_StatusBar.cpp:312:			//TODO: Get rid of the double here ...
./wp/ap/xp/ap_StatusBar.cpp-313-			double percent = (double)m_ProgressValue / (double)(m_ProgressEnd - m_ProgressStart); 
./wp/ap/xp/ap_StatusBar.cpp-314-			newrect.width = (UT_sint32)((double)newrect.width * percent); 
./wp/ap/xp/ap_StatusBar.cpp-315-
./wp/ap/xp/ap_StatusBar.cpp-316-			greyrect.left += newrect.width;
./wp/ap/xp/ap_StatusBar.cpp-317-			greyrect.width -= newrect.width;
./wp/ap/xp/ap_StatusBar.cpp-397- If start == end then the progress bar is a continuous update.
./wp/ap/xp/ap_StatusBar.cpp-398- If start != end then the progress bar will indicate an amount
./wp/ap/xp/ap_StatusBar.cpp-399-	between start-end
./wp/ap/xp/ap_StatusBar.cpp-400-
./wp/ap/xp/ap_StatusBar.cpp-401- FLAGS: 0 
./wp/ap/xp/ap_StatusBar.cpp:402: TODO: Allow status message to xor on top,
./wp/ap/xp/ap_StatusBar.cpp-403-       or update the message with the value (as a percent or
./wp/ap/xp/ap_StatusBar.cpp-404-       raw via the setProgressType. Start/Stop the progress bar.
./wp/ap/xp/ap_StatusBar.cpp-405-*/ 
./wp/ap/xp/ap_StatusBar.cpp-406-void ap_sb_Field_StatusMessage::setStatusProgressType(int start, int end, int flags) {
./wp/ap/xp/ap_StatusBar.cpp-407-	m_ProgressStart = 
./wp/ap/xp/ap_StatusBar.cpp-671-										// so that setStatusMessage() can do its thing.
./wp/ap/xp/ap_StatusBar.cpp-672-
./wp/ap/xp/ap_StatusBar.cpp-673-		DclField(ap_sb_Field_InsertMode, pf4);
./wp/ap/xp/ap_StatusBar.cpp-674-		DclField(ap_sb_Field_InputMode, pf3);
./wp/ap/xp/ap_StatusBar.cpp-675-		
./wp/ap/xp/ap_StatusBar.cpp:676:		// TODO add other fields
./wp/ap/xp/ap_StatusBar.cpp-677-
./wp/ap/xp/ap_StatusBar.cpp-678-#undef DclField
./wp/ap/xp/ap_StatusBar.cpp-679-		m_bInitFields = UT_TRUE;
./wp/ap/xp/ap_StatusBar.cpp-680-	}
./wp/ap/xp/ap_StatusBar.cpp-681-
./wp/ap/xp/ap_Strings.cpp-220-	if (szString && *szString)
./wp/ap/xp/ap_Strings.cpp-221-	{
./wp/ap/xp/ap_Strings.cpp-222-		UT_GrowBuf gb;
./wp/ap/xp/ap_Strings.cpp-223-		UT_decodeUTF8string(szString,UT_XML_strlen(szString),&gb);
./wp/ap/xp/ap_Strings.cpp-224-
./wp/ap/xp/ap_Strings.cpp:225:		// TODO The strings that we use (for dialogs and etc) are currently
./wp/ap/xp/ap_Strings.cpp:226:		// TODO limited to single-byte encodings by the code below.  
./wp/ap/xp/ap_Strings.cpp-227-
./wp/ap/xp/ap_Strings.cpp-228-		int kLimit=gb.getLength();
./wp/ap/xp/ap_Strings.cpp-229-		UT_uint16 * p=gb.getPointer(0);
./wp/ap/xp/ap_Strings.cpp-230-		UT_ByteBuf str;		
./wp/ap/xp/ap_Strings.cpp-231-		UT_Wctomb wctomb_conv;
./wp/ap/xp/ap_Strings.cpp-320-	if (!XAP_DiskStringSet::loadStringsFromDisk(szFilename))
./wp/ap/xp/ap_Strings.cpp-321-		return UT_FALSE;
./wp/ap/xp/ap_Strings.cpp-322-
./wp/ap/xp/ap_Strings.cpp-323-#ifdef DEBUG	
./wp/ap/xp/ap_Strings.cpp-324-	{
./wp/ap/xp/ap_Strings.cpp:325:		// TODO should we promote this test to be production code
./wp/ap/xp/ap_Strings.cpp:326:		// TODO and maybe raise a message box ??
./wp/ap/xp/ap_Strings.cpp-327-		UT_uint32 kLimit = NrElements(s_map);
./wp/ap/xp/ap_Strings.cpp-328-		UT_uint32 k;
./wp/ap/xp/ap_Strings.cpp-329-
./wp/ap/xp/ap_Strings.cpp-330-		for (k=0; k<kLimit; k++)
./wp/ap/xp/ap_Strings.cpp-331-		{
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-115-
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-116-	_s(AP_TOOLBAR_ID_1COLUMN,		EV_TBIT_GroupButton,	"sectColumns1",	AV_CHG_FMTSECTION,	ap_ToolbarGetState_SectionFmt);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-117-	_s(AP_TOOLBAR_ID_2COLUMN,		EV_TBIT_GroupButton,	"sectColumns2",	AV_CHG_FMTSECTION,	ap_ToolbarGetState_SectionFmt);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-118-	_s(AP_TOOLBAR_ID_3COLUMN,		EV_TBIT_GroupButton,	"sectColumns3",	AV_CHG_FMTSECTION,	ap_ToolbarGetState_SectionFmt);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-119-
./wp/ap/xp/ap_Toolbar_ActionSet.cpp:120:	// AV_CHG_WINDOWSIZE, below, doesn't seem right.  TODO
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-121-	
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-122-	_s(AP_TOOLBAR_ID_ZOOM,			EV_TBIT_ComboBox,		"zoom",			AV_CHG_WINDOWSIZE,	ap_ToolbarGetState_Zoom);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-123-	_s(AP_TOOLBAR_ID_LISTS_BULLETS,		EV_TBIT_ToggleButton,		"doBullets",		AV_CHG_ALL,	ap_ToolbarGetState_Bullets	);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-124-	_s(AP_TOOLBAR_ID_LISTS_NUMBERS,		EV_TBIT_ToggleButton,		"doNumbers",		AV_CHG_ALL,	ap_ToolbarGetState_Numbers	);
./wp/ap/xp/ap_Toolbar_ActionSet.cpp-125-	
./wp/ap/xp/ap_TopRuler.cpp-107-	this->setView(pView);
./wp/ap/xp/ap_TopRuler.cpp-108-
./wp/ap/xp/ap_TopRuler.cpp-109-	UT_ASSERT(m_pG);
./wp/ap/xp/ap_TopRuler.cpp-110-	m_pG->setZoomPercentage(iZoom);
./wp/ap/xp/ap_TopRuler.cpp-111-
./wp/ap/xp/ap_TopRuler.cpp:112:	m_minColumnWidth = m_pG->convertDimension("0.5in");//TODO should this dimension be hard coded.
./wp/ap/xp/ap_TopRuler.cpp-113-
./wp/ap/xp/ap_TopRuler.cpp-114-}
./wp/ap/xp/ap_TopRuler.cpp-115-
./wp/ap/xp/ap_TopRuler.cpp-116-void AP_TopRuler::setView(AV_View * pView)
./wp/ap/xp/ap_TopRuler.cpp-117-{
./wp/ap/xp/ap_TopRuler.cpp-893-	// draw the tab toggle inside the fixed area in the left-hand corner
./wp/ap/xp/ap_TopRuler.cpp-894-
./wp/ap/xp/ap_TopRuler.cpp-895-	_drawTabToggle(pClipRect, UT_FALSE);
./wp/ap/xp/ap_TopRuler.cpp-896-
./wp/ap/xp/ap_TopRuler.cpp-897-
./wp/ap/xp/ap_TopRuler.cpp:898:	// TODO for now assume we are in column display mode.
./wp/ap/xp/ap_TopRuler.cpp-899-	UT_ASSERT(pInfo->m_mode==AP_TopRulerInfo::TRI_MODE_COLUMNS);
./wp/ap/xp/ap_TopRuler.cpp-900-
./wp/ap/xp/ap_TopRuler.cpp-901-	// draw the dark-gray and white bar across the
./wp/ap/xp/ap_TopRuler.cpp-902-	// width of the paper.  we adjust the x coords
./wp/ap/xp/ap_TopRuler.cpp-903-	// by 1 to keep a light-gray bar between the
./wp/ap/xp/ap_TopRuler.cpp-1007-	UT_sint32 xOther = m_draggingRect.left - xFixed;
./wp/ap/xp/ap_TopRuler.cpp-1008-
./wp/ap/xp/ap_TopRuler.cpp-1009-	GR_Graphics * pG = (static_cast<FV_View *>(m_pView))->getGraphics();
./wp/ap/xp/ap_TopRuler.cpp-1010-	UT_ASSERT(pG);
./wp/ap/xp/ap_TopRuler.cpp-1011-
./wp/ap/xp/ap_TopRuler.cpp:1012:	// TODO we need to query the document window to see what the actual
./wp/ap/xp/ap_TopRuler.cpp:1013:	// TODO background color is so that we can compose the proper color so
./wp/ap/xp/ap_TopRuler.cpp:1014:	// TODO that we can XOR on it and be guaranteed that it will show up.
./wp/ap/xp/ap_TopRuler.cpp-1015-
./wp/ap/xp/ap_TopRuler.cpp-1016-	UT_RGBColor clrWhite(255,255,255);
./wp/ap/xp/ap_TopRuler.cpp-1017-	pG->setColor(clrWhite);
./wp/ap/xp/ap_TopRuler.cpp-1018-
./wp/ap/xp/ap_TopRuler.cpp-1019-	UT_sint32 h = m_pView->getWindowHeight();
./wp/ap/xp/ap_TopRuler.cpp-1926-			}
./wp/ap/xp/ap_TopRuler.cpp-1927-			else if (x > xAbsRight - m_infoCache.u.c.m_xaRightMargin)
./wp/ap/xp/ap_TopRuler.cpp-1928-			{
./wp/ap/xp/ap_TopRuler.cpp-1929-				x = xAbsRight - m_infoCache.u.c.m_xaRightMargin;
./wp/ap/xp/ap_TopRuler.cpp-1930-			}
./wp/ap/xp/ap_TopRuler.cpp:1931:			UT_sint32 xrel = ((UT_sint32)x) - xStartPixel - 1; // TODO why is the -1 necessary? w/o it problems arise.
./wp/ap/xp/ap_TopRuler.cpp-1932-			UT_sint32 xgrid = _snapPixelToGrid(xrel,tick);
./wp/ap/xp/ap_TopRuler.cpp-1933-			double dgrid = _scalePixelDistanceToUnits(xrel,tick);
./wp/ap/xp/ap_TopRuler.cpp-1934-			UT_DEBUGMSG(("SettingTabStop: %s\n",m_pG->invertDimension(tick.dimType,dgrid)));
./wp/ap/xp/ap_TopRuler.cpp-1935-			UT_sint32 oldDraggingCenter = m_draggingCenter;
./wp/ap/xp/ap_TopRuler.cpp-1936-			UT_Rect oldDraggingRect = m_draggingRect;
./wp/ap/xp/ap_TopRuler.cpp-2294-			l += 1;
./wp/ap/xp/ap_TopRuler.cpp-2295-			r -= 1;
./wp/ap/xp/ap_TopRuler.cpp-2296-			break;
./wp/ap/xp/ap_TopRuler.cpp-2297-
./wp/ap/xp/ap_TopRuler.cpp-2298-		default:
./wp/ap/xp/ap_TopRuler.cpp:2299:			UT_ASSERT(UT_TODO);
./wp/ap/xp/ap_TopRuler.cpp-2300-			break;
./wp/ap/xp/ap_TopRuler.cpp-2301-	}
./wp/ap/xp/ap_TopRuler.cpp-2302-
./wp/ap/xp/ap_TopRuler.cpp-2303-	m_pG->fillRect(clr3d, l,     t+4,  r-l,  2);
./wp/ap/xp/ap_TopRuler.cpp-2304-}
./wp/impexp/xp/ie_exp.cpp-108-
./wp/impexp/xp/ie_exp.cpp-109-UT_Bool IE_Exp::_openFile(const char * szFilename)
./wp/impexp/xp/ie_exp.cpp-110-{
./wp/impexp/xp/ie_exp.cpp-111-	UT_ASSERT(!m_fp);
./wp/impexp/xp/ie_exp.cpp-112-
./wp/impexp/xp/ie_exp.cpp:113:	// TODO add code to make a backup of the original file, if it exists.
./wp/impexp/xp/ie_exp.cpp-114-
./wp/impexp/xp/ie_exp.cpp-115-#ifndef HAVE_GNOMEVFS
./wp/impexp/xp/ie_exp.cpp-116-	m_fp = fopen(szFilename,"w");
./wp/impexp/xp/ie_exp.cpp-117-	return (m_fp != 0);
./wp/impexp/xp/ie_exp.cpp-118-#else
./wp/impexp/xp/ie_exp.cpp-180-}
./wp/impexp/xp/ie_exp.cpp-181-
./wp/impexp/xp/ie_exp.cpp-182-void IE_Exp::_abortFile(void)
./wp/impexp/xp/ie_exp.cpp-183-{
./wp/impexp/xp/ie_exp.cpp-184-	// abort the write.
./wp/impexp/xp/ie_exp.cpp:185:	// TODO close the file and do any restore and/or cleanup.
./wp/impexp/xp/ie_exp.cpp-186-        UT_ASSERT(0);
./wp/impexp/xp/ie_exp.cpp-187-	_closeFile();
./wp/impexp/xp/ie_exp.cpp-188-	return;
./wp/impexp/xp/ie_exp.cpp-189-}
./wp/impexp/xp/ie_exp.cpp-190-
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-205-		const XML_Char * szValue;
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-206-		UT_uint32 k = 0;
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-207-
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-208-		while (pAP->getNthAttribute(k++,szName,szValue))
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-209-		{
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:210:			// TODO we force double-quotes on all values.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:211:			// TODO consider scanning the value to see if it has one
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:212:			// TODO in it and escaping it or using single-quotes.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-213-			
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-214-			m_pie->write(" ");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-215-			m_pie->write((char*)szName);
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-216-			m_pie->write("=\"");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-217-			m_pie->write((char*)szValue);
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-362-					pData++;
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-363-				}
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-364-#	endif
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-365-#else
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-366-				// convert to UTF8
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:367:				// TODO if we choose this, do we have to put the ISO header in
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:368:				// TODO like we did for the strings files.... i hesitate to
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:369:				// TODO make such a change to our file format.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-370-				XML_Char * pszUTF8 = UT_encodeUTF8char(*pData);
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-371-				while (*pszUTF8)
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-372-				{
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-373-					*pBuf++ = (UT_Byte)*pszUTF8;
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-374-					pszUTF8++;
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-420-		m_pie->write(XAP_App::s_szBuild_Version);
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-421-	}
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-422-	m_pie->write("\"");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-423-	m_pie->write(">\n");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-424-
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:425:	// TODO add a file-format name/value pair to this tag.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-426-
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-427-
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-428-	// NOTE we output the following preamble in XML comments.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-429-	// NOTE this information is for human viewing only.
./wp/impexp/xp/ie_exp_AbiWord_1.cpp:430:	// TODO should this preamble have a DTD reference in it ??
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-431-	
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-432-	m_pie->write("<!-- =====================================================================  -->\n");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-433-	m_pie->write("<!-- This file is an AbiWord document.                                      -->\n");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-434-	m_pie->write("<!-- AbiWord is a free, Open Source word processor.                         -->\n");
./wp/impexp/xp/ie_exp_AbiWord_1.cpp-435-	m_pie->write("<!-- You may obtain more information about AbiWord at www.abisource.com     -->\n");
./wp/impexp/xp/ie_exp_DocBook.cpp-383-	if (!m_bInParagraph)
./wp/impexp/xp/ie_exp_DocBook.cpp-384-	{
./wp/impexp/xp/ie_exp_DocBook.cpp-385-		return;
./wp/impexp/xp/ie_exp_DocBook.cpp-386-	}
./wp/impexp/xp/ie_exp_DocBook.cpp-387-	
./wp/impexp/xp/ie_exp_DocBook.cpp:388:	// TODO deal with unicode.
./wp/impexp/xp/ie_exp_DocBook.cpp:389:	// TODO for now, just squish it into ascii.
./wp/impexp/xp/ie_exp_DocBook.cpp-390-	
./wp/impexp/xp/ie_exp_DocBook.cpp-391-#define MY_BUFFER_SIZE		1024
./wp/impexp/xp/ie_exp_DocBook.cpp-392-#define MY_HIGHWATER_MARK	20
./wp/impexp/xp/ie_exp_DocBook.cpp-393-	char buf[MY_BUFFER_SIZE];
./wp/impexp/xp/ie_exp_DocBook.cpp-394-	char * pBuf;
./wp/impexp/xp/ie_exp_DocBook.cpp-507-					pData++;
./wp/impexp/xp/ie_exp_DocBook.cpp-508-				}
./wp/impexp/xp/ie_exp_DocBook.cpp-509-#	endif
./wp/impexp/xp/ie_exp_DocBook.cpp-510-#else
./wp/impexp/xp/ie_exp_DocBook.cpp-511-				// convert to UTF8
./wp/impexp/xp/ie_exp_DocBook.cpp:512:				// TODO if we choose this, do we have to put the ISO header in
./wp/impexp/xp/ie_exp_DocBook.cpp:513:				// TODO like we did for the strings files.... i hesitate to
./wp/impexp/xp/ie_exp_DocBook.cpp:514:				// TODO make such a change to our file format.
./wp/impexp/xp/ie_exp_DocBook.cpp-515-				XML_Char * pszUTF8 = UT_encodeUTF8char(*pData);
./wp/impexp/xp/ie_exp_DocBook.cpp-516-				while (*pszUTF8)
./wp/impexp/xp/ie_exp_DocBook.cpp-517-				{
./wp/impexp/xp/ie_exp_DocBook.cpp-518-					*pBuf++ = (UT_Byte)*pszUTF8;
./wp/impexp/xp/ie_exp_DocBook.cpp-519-					pszUTF8++;
./wp/impexp/xp/ie_exp_DocBook.cpp-635-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_DocBook.cpp-636-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_DocBook.cpp-637-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_DocBook.cpp-638-			{
./wp/impexp/xp/ie_exp_DocBook.cpp-639-			case PTO_Image:
./wp/impexp/xp/ie_exp_DocBook.cpp:640:				// TODO we *could* insert the images and create separate GIF files.
./wp/impexp/xp/ie_exp_DocBook.cpp-641-				return UT_TRUE;
./wp/impexp/xp/ie_exp_DocBook.cpp-642-
./wp/impexp/xp/ie_exp_DocBook.cpp-643-			case PTO_Field:
./wp/impexp/xp/ie_exp_DocBook.cpp-644-				// we do nothing with computed fields.
./wp/impexp/xp/ie_exp_DocBook.cpp-645-				return UT_TRUE;
./wp/impexp/xp/ie_exp_HTML.cpp-355-}
./wp/impexp/xp/ie_exp_HTML.cpp-356-
./wp/impexp/xp/ie_exp_HTML.cpp-357-void s_HTML_Listener::_convertColor(char* szDest, const char* pszColor)
./wp/impexp/xp/ie_exp_HTML.cpp-358-{
./wp/impexp/xp/ie_exp_HTML.cpp-359-	/*
./wp/impexp/xp/ie_exp_HTML.cpp:360:	  TODO we might want to be a little more careful about this.
./wp/impexp/xp/ie_exp_HTML.cpp-361-	  The proper HTML color is #rrggbb, which is basically the same
./wp/impexp/xp/ie_exp_HTML.cpp-362-	  as what we use this.  HTML browsers are likely to be more
./wp/impexp/xp/ie_exp_HTML.cpp-363-	  forgiving than we are, so this is probably not a big
./wp/impexp/xp/ie_exp_HTML.cpp-364-	  problem.
./wp/impexp/xp/ie_exp_HTML.cpp-365-	*/
./wp/impexp/xp/ie_exp_HTML.cpp-369-void s_HTML_Listener::_convertFontSize(char* szDest, const char* pszFontSize)
./wp/impexp/xp/ie_exp_HTML.cpp-370-{
./wp/impexp/xp/ie_exp_HTML.cpp-371-	double fSizeInPoints = UT_convertToPoints(pszFontSize);
./wp/impexp/xp/ie_exp_HTML.cpp-372-
./wp/impexp/xp/ie_exp_HTML.cpp-373-	/*
./wp/impexp/xp/ie_exp_HTML.cpp:374:	  TODO we can probably come up with a mapping of font sizes that
./wp/impexp/xp/ie_exp_HTML.cpp-375-	  is more accurate than the code below.  I just guessed.
./wp/impexp/xp/ie_exp_HTML.cpp-376-	*/
./wp/impexp/xp/ie_exp_HTML.cpp-377-	
./wp/impexp/xp/ie_exp_HTML.cpp-378-	if (fSizeInPoints <= 7)
./wp/impexp/xp/ie_exp_HTML.cpp-379-	{
./wp/impexp/xp/ie_exp_HTML.cpp-474-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_HTML.cpp-475-
./wp/impexp/xp/ie_exp_HTML.cpp-476-			XML_Char* p;
./wp/impexp/xp/ie_exp_HTML.cpp-477-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_HTML.cpp-478-			{
./wp/impexp/xp/ie_exp_HTML.cpp:479:				// TODO outofmem
./wp/impexp/xp/ie_exp_HTML.cpp-480-			}
./wp/impexp/xp/ie_exp_HTML.cpp-481-			
./wp/impexp/xp/ie_exp_HTML.cpp-482-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_HTML.cpp-483-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_HTML.cpp-484-
./wp/impexp/xp/ie_exp_HTML.cpp-516-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_HTML.cpp-517-			
./wp/impexp/xp/ie_exp_HTML.cpp-518-			XML_Char* p;
./wp/impexp/xp/ie_exp_HTML.cpp-519-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_HTML.cpp-520-			{
./wp/impexp/xp/ie_exp_HTML.cpp:521:				// TODO outofmem
./wp/impexp/xp/ie_exp_HTML.cpp-522-			}
./wp/impexp/xp/ie_exp_HTML.cpp-523-			
./wp/impexp/xp/ie_exp_HTML.cpp-524-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_HTML.cpp-525-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_HTML.cpp-526-
./wp/impexp/xp/ie_exp_HTML.cpp-558-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_HTML.cpp-559-			
./wp/impexp/xp/ie_exp_HTML.cpp-560-			XML_Char* p;
./wp/impexp/xp/ie_exp_HTML.cpp-561-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_HTML.cpp-562-			{
./wp/impexp/xp/ie_exp_HTML.cpp:563:				// TODO outofmem
./wp/impexp/xp/ie_exp_HTML.cpp-564-			}
./wp/impexp/xp/ie_exp_HTML.cpp-565-			
./wp/impexp/xp/ie_exp_HTML.cpp-566-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_HTML.cpp-567-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_HTML.cpp-568-
./wp/impexp/xp/ie_exp_HTML.cpp-767-	if (!m_bInBlock)
./wp/impexp/xp/ie_exp_HTML.cpp-768-	{
./wp/impexp/xp/ie_exp_HTML.cpp-769-		return;
./wp/impexp/xp/ie_exp_HTML.cpp-770-	}
./wp/impexp/xp/ie_exp_HTML.cpp-771-	
./wp/impexp/xp/ie_exp_HTML.cpp:772:	// TODO deal with unicode.
./wp/impexp/xp/ie_exp_HTML.cpp:773:	// TODO for now, just squish it into ascii.
./wp/impexp/xp/ie_exp_HTML.cpp-774-	
./wp/impexp/xp/ie_exp_HTML.cpp-775-#define MY_BUFFER_SIZE		1024
./wp/impexp/xp/ie_exp_HTML.cpp-776-#define MY_HIGHWATER_MARK	20
./wp/impexp/xp/ie_exp_HTML.cpp-777-	char buf[MY_BUFFER_SIZE];
./wp/impexp/xp/ie_exp_HTML.cpp-778-	char * pBuf;
./wp/impexp/xp/ie_exp_HTML.cpp-997-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_HTML.cpp-998-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_HTML.cpp-999-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_HTML.cpp-1000-			{
./wp/impexp/xp/ie_exp_HTML.cpp-1001-			case PTO_Image:
./wp/impexp/xp/ie_exp_HTML.cpp:1002:				// TODO we *could* insert the images and create separate GIF files.
./wp/impexp/xp/ie_exp_HTML.cpp-1003-				return UT_TRUE;
./wp/impexp/xp/ie_exp_HTML.cpp-1004-
./wp/impexp/xp/ie_exp_HTML.cpp-1005-			case PTO_Field:
./wp/impexp/xp/ie_exp_HTML.cpp-1006-				// we do nothing with computed fields.
./wp/impexp/xp/ie_exp_HTML.cpp-1007-				return UT_TRUE;
./wp/impexp/xp/ie_exp_HTML.cpp-1129-
./wp/impexp/xp/ie_exp_HTML.cpp-1130-void s_HTML_Listener::_handleDataItems(void)
./wp/impexp/xp/ie_exp_HTML.cpp-1131-{
./wp/impexp/xp/ie_exp_HTML.cpp-1132-	/*
./wp/impexp/xp/ie_exp_HTML.cpp-1133-	  We *could* handle these by creating separate files with GIF/JPG
./wp/impexp/xp/ie_exp_HTML.cpp:1134:	  images in them, and inlining IMG tags into the HTML.  TODO
./wp/impexp/xp/ie_exp_HTML.cpp-1135-	*/
./wp/impexp/xp/ie_exp_HTML.cpp-1136-	
./wp/impexp/xp/ie_exp_HTML.cpp-1137-#if 0
./wp/impexp/xp/ie_exp_HTML.cpp-1138-	UT_Bool bWroteOpenDataSection = UT_FALSE;
./wp/impexp/xp/ie_exp_HTML.cpp-1139-
./wp/impexp/xp/ie_exp_HTML.cpp-1154-		{
./wp/impexp/xp/ie_exp_HTML.cpp-1155-			m_pie->write("<d name=\"");
./wp/impexp/xp/ie_exp_HTML.cpp-1156-			m_pie->write(szName);
./wp/impexp/xp/ie_exp_HTML.cpp-1157-			m_pie->write("\">\n");
./wp/impexp/xp/ie_exp_HTML.cpp-1158-
./wp/impexp/xp/ie_exp_HTML.cpp:1159:			// TODO for now just spat the whole thing, later we'll want to
./wp/impexp/xp/ie_exp_HTML.cpp:1160:			// TODO line wrap it for readability -- just like mime.
./wp/impexp/xp/ie_exp_HTML.cpp-1161-
./wp/impexp/xp/ie_exp_HTML.cpp-1162-			m_pie->write((const char *)bb64.getPointer(0),bb64.getLength());
./wp/impexp/xp/ie_exp_HTML.cpp-1163-			
./wp/impexp/xp/ie_exp_HTML.cpp-1164-			m_pie->write("\n</d>\n");
./wp/impexp/xp/ie_exp_HTML.cpp-1165-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-277-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-278-			m_iBlockType = BT_NORMAL;
./wp/impexp/xp/ie_exp_LaTeX.cpp-279-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-280-		
./wp/impexp/xp/ie_exp_LaTeX.cpp-281-		/* Assumption: never get property set with h1-h3, block text, plain text. Probably true. */
./wp/impexp/xp/ie_exp_LaTeX.cpp:282:		// TODO: Split this function in several ones
./wp/impexp/xp/ie_exp_LaTeX.cpp-283-		if (m_iBlockType == BT_NORMAL)
./wp/impexp/xp/ie_exp_LaTeX.cpp-284-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-285-			if (pAP->getProperty((XML_Char*)"text-align", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-286-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp-287-				if (0 == UT_strcmp(szValue, "center"))
./wp/impexp/xp/ie_exp_LaTeX.cpp-313-				}
./wp/impexp/xp/ie_exp_LaTeX.cpp-314-				if (height > 1.4 && height < 1.6)
./wp/impexp/xp/ie_exp_LaTeX.cpp-315-					m_pie->write("1.24}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-316-				else if (height > 1.9 && height < 2.1)
./wp/impexp/xp/ie_exp_LaTeX.cpp-317-					m_pie->write("1.66}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp:318:				else if (m_bLineHeight) // glup.  TODO: calculate the spacing :)
./wp/impexp/xp/ie_exp_LaTeX.cpp-319-				    m_pie->write("1.0} % Sorry.  I know that you don't expected the 1.0... feel free to fix it! :)\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-320-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-321-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-322-	}
./wp/impexp/xp/ie_exp_LaTeX.cpp-323-	else 
./wp/impexp/xp/ie_exp_LaTeX.cpp-378-}
./wp/impexp/xp/ie_exp_LaTeX.cpp-379-
./wp/impexp/xp/ie_exp_LaTeX.cpp-380-void s_LaTeX_Listener::_convertColor(char* szDest, const char* pszColor)
./wp/impexp/xp/ie_exp_LaTeX.cpp-381-{
./wp/impexp/xp/ie_exp_LaTeX.cpp-382-	/*
./wp/impexp/xp/ie_exp_LaTeX.cpp:383:	  TODO I've no clue about the colors in LaTeX
./wp/impexp/xp/ie_exp_LaTeX.cpp-384-	*/
./wp/impexp/xp/ie_exp_LaTeX.cpp-385-	strcpy(szDest, pszColor);
./wp/impexp/xp/ie_exp_LaTeX.cpp-386-}
./wp/impexp/xp/ie_exp_LaTeX.cpp-387-
./wp/impexp/xp/ie_exp_LaTeX.cpp-388-void s_LaTeX_Listener::_convertFontSize(char* szDest, const char* pszFontSize)
./wp/impexp/xp/ie_exp_LaTeX.cpp-466-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_LaTeX.cpp-467-
./wp/impexp/xp/ie_exp_LaTeX.cpp-468-			XML_Char* p;
./wp/impexp/xp/ie_exp_LaTeX.cpp-469-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_LaTeX.cpp-470-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:471:				// TODO outofmem
./wp/impexp/xp/ie_exp_LaTeX.cpp-472-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-473-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-474-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_LaTeX.cpp-475-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_LaTeX.cpp-476-
./wp/impexp/xp/ie_exp_LaTeX.cpp-477-			while (q)
./wp/impexp/xp/ie_exp_LaTeX.cpp-478-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:479:			  if (0 == UT_strcmp(q, "underline")) // TODO: \def\undertext#1{$\underline{\vphantom{y}\smash{\hbox{#1}}}$}
./wp/impexp/xp/ie_exp_LaTeX.cpp-480-				{
./wp/impexp/xp/ie_exp_LaTeX.cpp-481-					m_pie->write("\\underline{");
./wp/impexp/xp/ie_exp_LaTeX.cpp-482-				}
./wp/impexp/xp/ie_exp_LaTeX.cpp-483-
./wp/impexp/xp/ie_exp_LaTeX.cpp-484-				if (0 == UT_strcmp(q, "overline"))
./wp/impexp/xp/ie_exp_LaTeX.cpp-486-					m_pie->write("$\\overline{\\textrm{");
./wp/impexp/xp/ie_exp_LaTeX.cpp-487-				}
./wp/impexp/xp/ie_exp_LaTeX.cpp-488-
./wp/impexp/xp/ie_exp_LaTeX.cpp-489-				if (0 == UT_strcmp(q, "line-through"))
./wp/impexp/xp/ie_exp_LaTeX.cpp-490-				{
./wp/impexp/xp/ie_exp_LaTeX.cpp:491:					m_pie->write("");	// TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-492-				}
./wp/impexp/xp/ie_exp_LaTeX.cpp-493-
./wp/impexp/xp/ie_exp_LaTeX.cpp-494-				q = strtok(NULL, " ");
./wp/impexp/xp/ie_exp_LaTeX.cpp-495-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-496-
./wp/impexp/xp/ie_exp_LaTeX.cpp-499-
./wp/impexp/xp/ie_exp_LaTeX.cpp-500-		if (pAP->getProperty((XML_Char*)"text-position", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-501-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-502-			if (!UT_strcmp("superscript", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-503-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:504:				m_pie->write("$^{\\rm{}"); // TODO: Finish it
./wp/impexp/xp/ie_exp_LaTeX.cpp-505-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-506-			else if (!UT_strcmp("subscript", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-507-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:508:				m_pie->write("$_{\\rm{}"); // TODO: Finish it
./wp/impexp/xp/ie_exp_LaTeX.cpp-509-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-510-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-511-		
./wp/impexp/xp/ie_exp_LaTeX.cpp-512-		if (pAP->getProperty((XML_Char*)"color", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp:513:			; // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-514-
./wp/impexp/xp/ie_exp_LaTeX.cpp-515-		if (pAP->getProperty((XML_Char*)"font-size", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-516-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-517-			if (strcmp (szValue, DEFAULT_SIZE) != 0)
./wp/impexp/xp/ie_exp_LaTeX.cpp-518-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp-523-				m_pie->write("{}");
./wp/impexp/xp/ie_exp_LaTeX.cpp-524-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-525-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-526-		
./wp/impexp/xp/ie_exp_LaTeX.cpp-527-		if (pAP->getProperty((XML_Char*)"font-family", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp:528:			; // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-529-
./wp/impexp/xp/ie_exp_LaTeX.cpp-530-		m_bInSpan = UT_TRUE;
./wp/impexp/xp/ie_exp_LaTeX.cpp-531-		m_pAP_Span = pAP;
./wp/impexp/xp/ie_exp_LaTeX.cpp-532-	}
./wp/impexp/xp/ie_exp_LaTeX.cpp-533-}
./wp/impexp/xp/ie_exp_LaTeX.cpp-541-	
./wp/impexp/xp/ie_exp_LaTeX.cpp-542-	if (pAP)
./wp/impexp/xp/ie_exp_LaTeX.cpp-543-	{
./wp/impexp/xp/ie_exp_LaTeX.cpp-544-		const XML_Char * szValue;
./wp/impexp/xp/ie_exp_LaTeX.cpp-545-		
./wp/impexp/xp/ie_exp_LaTeX.cpp:546:		if (// (pAP->getProperty((XML_Char*)"color", szValue)) ||    // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-547-		    (pAP->getProperty((XML_Char*)"font-size", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp:548://		    || (pAP->getProperty((XML_Char*)"font-family", szValue))  // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-549-			)
./wp/impexp/xp/ie_exp_LaTeX.cpp-550-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-551-			if (strcmp (szValue, DEFAULT_SIZE) != 0)
./wp/impexp/xp/ie_exp_LaTeX.cpp-552-				m_pie->write("}");
./wp/impexp/xp/ie_exp_LaTeX.cpp-553-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-554-
./wp/impexp/xp/ie_exp_LaTeX.cpp-555-		if (pAP->getProperty((XML_Char*)"text-position", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-556-		{
./wp/impexp/xp/ie_exp_LaTeX.cpp-557-			if (!UT_strcmp("superscript", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-558-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:559:				m_pie->write("}$"); // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-560-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-561-			else if (!UT_strcmp("subscript", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-562-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:563:				m_pie->write("}$"); // TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-564-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-565-		}
./wp/impexp/xp/ie_exp_LaTeX.cpp-566-
./wp/impexp/xp/ie_exp_LaTeX.cpp-567-		if (
./wp/impexp/xp/ie_exp_LaTeX.cpp-568-			(pAP->getProperty((XML_Char*)"text-decoration", szValue))
./wp/impexp/xp/ie_exp_LaTeX.cpp-571-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_LaTeX.cpp-572-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-573-			XML_Char* p;
./wp/impexp/xp/ie_exp_LaTeX.cpp-574-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_LaTeX.cpp-575-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:576:				// TODO outofmem
./wp/impexp/xp/ie_exp_LaTeX.cpp-577-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-578-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-579-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_LaTeX.cpp-580-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_LaTeX.cpp-581-
./wp/impexp/xp/ie_exp_LaTeX.cpp-582-			while (q)
./wp/impexp/xp/ie_exp_LaTeX.cpp-583-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp-584-				if (0 == UT_strcmp(q, "line-through"))
./wp/impexp/xp/ie_exp_LaTeX.cpp-585-				{
./wp/impexp/xp/ie_exp_LaTeX.cpp:586:					m_pie->write("");	// TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-587-				}
./wp/impexp/xp/ie_exp_LaTeX.cpp-588-
./wp/impexp/xp/ie_exp_LaTeX.cpp-589-				q = strtok(NULL, " ");
./wp/impexp/xp/ie_exp_LaTeX.cpp-590-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-591-
./wp/impexp/xp/ie_exp_LaTeX.cpp-599-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_LaTeX.cpp-600-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-601-			XML_Char* p;
./wp/impexp/xp/ie_exp_LaTeX.cpp-602-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_LaTeX.cpp-603-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp:604:				// TODO outofmem
./wp/impexp/xp/ie_exp_LaTeX.cpp-605-			}
./wp/impexp/xp/ie_exp_LaTeX.cpp-606-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-607-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_LaTeX.cpp-608-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_LaTeX.cpp-609-
./wp/impexp/xp/ie_exp_LaTeX.cpp-654-	if (!m_bInBlock)
./wp/impexp/xp/ie_exp_LaTeX.cpp-655-	{
./wp/impexp/xp/ie_exp_LaTeX.cpp-656-		return;
./wp/impexp/xp/ie_exp_LaTeX.cpp-657-	}
./wp/impexp/xp/ie_exp_LaTeX.cpp-658-	
./wp/impexp/xp/ie_exp_LaTeX.cpp:659:	// TODO deal with unicode.
./wp/impexp/xp/ie_exp_LaTeX.cpp:660:	// TODO for now, just squish it into ascii.
./wp/impexp/xp/ie_exp_LaTeX.cpp-661-	
./wp/impexp/xp/ie_exp_LaTeX.cpp-662-#define MY_BUFFER_SIZE		1024
./wp/impexp/xp/ie_exp_LaTeX.cpp-663-#define MY_HIGHWATER_MARK	20
./wp/impexp/xp/ie_exp_LaTeX.cpp-664-	char buf[MY_BUFFER_SIZE];
./wp/impexp/xp/ie_exp_LaTeX.cpp-665-	char * pBuf;
./wp/impexp/xp/ie_exp_LaTeX.cpp-743-			*pBuf++ = '\\';
./wp/impexp/xp/ie_exp_LaTeX.cpp-744-			*pBuf++ = '\\';
./wp/impexp/xp/ie_exp_LaTeX.cpp-745-			pData++;
./wp/impexp/xp/ie_exp_LaTeX.cpp-746-			break;
./wp/impexp/xp/ie_exp_LaTeX.cpp-747-
./wp/impexp/xp/ie_exp_LaTeX.cpp:748:		case UCS_VTAB:					// VTAB -- representing a Forced-Column-Break -- TODO
./wp/impexp/xp/ie_exp_LaTeX.cpp-749-			pData++;
./wp/impexp/xp/ie_exp_LaTeX.cpp-750-			break;
./wp/impexp/xp/ie_exp_LaTeX.cpp-751-			
./wp/impexp/xp/ie_exp_LaTeX.cpp-752-		case UCS_FF:					// FF -- representing a Forced-Page-Break
./wp/impexp/xp/ie_exp_LaTeX.cpp-753-			*pBuf++ = '\\';
./wp/impexp/xp/ie_exp_LaTeX.cpp-846-	
./wp/impexp/xp/ie_exp_LaTeX.cpp-847-	m_pie->write("\\documentclass[12pt]{article}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-848-	m_pie->write("\\usepackage[T1]{fontenc}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-849-	m_pie->write("\\usepackage{calc}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-850-	m_pie->write("\\usepackage{setspace}\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp:851:	m_pie->write("\\usepackage{multicol}\t% TODO: I don't need this package if the document is a single column one.\n");
./wp/impexp/xp/ie_exp_LaTeX.cpp-852-	{
./wp/impexp/xp/ie_exp_LaTeX.cpp-853-	    const char* misc = XAP_EncodingManager::instance->getTexPrologue();
./wp/impexp/xp/ie_exp_LaTeX.cpp-854-	    if (misc)
./wp/impexp/xp/ie_exp_LaTeX.cpp-855-		m_pie->write(misc);
./wp/impexp/xp/ie_exp_LaTeX.cpp-856-	}
./wp/impexp/xp/ie_exp_LaTeX.cpp-898-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_LaTeX.cpp-899-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_LaTeX.cpp-900-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_LaTeX.cpp-901-			{
./wp/impexp/xp/ie_exp_LaTeX.cpp-902-			case PTO_Image:
./wp/impexp/xp/ie_exp_LaTeX.cpp:903:				// TODO we *could* insert the images and create separate GIF files.
./wp/impexp/xp/ie_exp_LaTeX.cpp-904-				return UT_TRUE;
./wp/impexp/xp/ie_exp_LaTeX.cpp-905-
./wp/impexp/xp/ie_exp_LaTeX.cpp-906-			case PTO_Field:
./wp/impexp/xp/ie_exp_LaTeX.cpp-907-				// we do nothing with computed fields.
./wp/impexp/xp/ie_exp_LaTeX.cpp-908-				return UT_TRUE;
./wp/impexp/xp/ie_exp_Psion.cpp-34-//		Better determination of font type (serif, sansserif or nonproportional)
./wp/impexp/xp/ie_exp_Psion.cpp-35-//		Add support for other sections (page-level layout, headers, footers)
./wp/impexp/xp/ie_exp_Psion.cpp-36-//		Add support for objects, fields, format marks
./wp/impexp/xp/ie_exp_Psion.cpp-37-
./wp/impexp/xp/ie_exp_Psion.cpp-38-
./wp/impexp/xp/ie_exp_Psion.cpp:39:// Search for TODO for more things to do.
./wp/impexp/xp/ie_exp_Psion.cpp-40-
./wp/impexp/xp/ie_exp_Psion.cpp-41-#include "ut_string.h"
./wp/impexp/xp/ie_exp_Psion.cpp-42-#include "ut_bytebuf.h"
./wp/impexp/xp/ie_exp_Psion.cpp-43-#include "ut_units.h"
./wp/impexp/xp/ie_exp_Psion.cpp-44-#include "ut_debugmsg.h"
./wp/impexp/xp/ie_exp_Psion.cpp-471-	for (i = 0; i < inLength; i++)  {
./wp/impexp/xp/ie_exp_Psion.cpp-472-		if (!wctomb.wctomb(pC,mbLen,(wchar_t) p[i])) {
./wp/impexp/xp/ie_exp_Psion.cpp-473-			pC[0]='?'; // Do we really want this?
./wp/impexp/xp/ie_exp_Psion.cpp-474-			wctomb.initialize();
./wp/impexp/xp/ie_exp_Psion.cpp-475-		}
./wp/impexp/xp/ie_exp_Psion.cpp:476:		// TODO: Check for special ASCII codes (below 32 decimal)
./wp/impexp/xp/ie_exp_Psion.cpp-477-		if ((mbLen ==1) && (pC[0] < 0x20)) {
./wp/impexp/xp/ie_exp_Psion.cpp:478:			// TODO
./wp/impexp/xp/ie_exp_Psion.cpp-479-		}
./wp/impexp/xp/ie_exp_Psion.cpp-480-		if (!m_currentParagraphText.append( (UT_Byte *) pC,mbLen))
./wp/impexp/xp/ie_exp_Psion.cpp-481-			return UT_FALSE;
./wp/impexp/xp/ie_exp_Psion.cpp-482-		if (outLength)
./wp/impexp/xp/ie_exp_Psion.cpp-483-			*outLength += mbLen;
./wp/impexp/xp/ie_exp_Psion.cpp-494-	UT_Bool widowsorphans;
./wp/impexp/xp/ie_exp_Psion.cpp-495-
./wp/impexp/xp/ie_exp_Psion.cpp-496-	// New paragraph, new text.
./wp/impexp/xp/ie_exp_Psion.cpp-497-	m_currentParagraphText.truncate(0);
./wp/impexp/xp/ie_exp_Psion.cpp-498-	// Set the base layout of this paragraph.
./wp/impexp/xp/ie_exp_Psion.cpp:499:	// TODO: This should be based on the current style!
./wp/impexp/xp/ie_exp_Psion.cpp-500-	if (!(m_currentParagraphPLayout = psiconv_basic_paragraph_layout()))
./wp/impexp/xp/ie_exp_Psion.cpp-501-		return UT_FALSE;
./wp/impexp/xp/ie_exp_Psion.cpp-502-	if (!(m_currentParagraphCLayout = psiconv_basic_character_layout())) {
./wp/impexp/xp/ie_exp_Psion.cpp-503-		psiconv_free_paragraph_layout(m_currentParagraphPLayout);
./wp/impexp/xp/ie_exp_Psion.cpp-504-		return UT_FALSE;
./wp/impexp/xp/ie_exp_Psion.cpp-581-				psiconv_free_character_layout(m_currentParagraphCLayout);
./wp/impexp/xp/ie_exp_Psion.cpp-582-				psiconv_free_paragraph_layout(m_currentParagraphPLayout);
./wp/impexp/xp/ie_exp_Psion.cpp-583-				psiconv_list_free(m_currentParagraphInLines);
./wp/impexp/xp/ie_exp_Psion.cpp-584-				return UT_FALSE;
./wp/impexp/xp/ie_exp_Psion.cpp-585-			}
./wp/impexp/xp/ie_exp_Psion.cpp:586:		// TODO: Bullets
./wp/impexp/xp/ie_exp_Psion.cpp-587-	}
./wp/impexp/xp/ie_exp_Psion.cpp-588-
./wp/impexp/xp/ie_exp_Psion.cpp-589-	return UT_TRUE;
./wp/impexp/xp/ie_exp_Psion.cpp-590-}
./wp/impexp/xp/ie_exp_Psion.cpp-591-
./wp/impexp/xp/ie_exp_Psion.cpp-607-		// Get the base paragraph and character layout.
./wp/impexp/xp/ie_exp_Psion.cpp-608-		para.base_character = m_currentParagraphCLayout;
./wp/impexp/xp/ie_exp_Psion.cpp-609-		m_currentParagraphCLayout = NULL;
./wp/impexp/xp/ie_exp_Psion.cpp-610-		para.base_paragraph = m_currentParagraphPLayout;
./wp/impexp/xp/ie_exp_Psion.cpp-611-		m_currentParagraphPLayout = NULL;
./wp/impexp/xp/ie_exp_Psion.cpp:612:		// TODO: Set the real style here.
./wp/impexp/xp/ie_exp_Psion.cpp-613-		para.base_style = 0;
./wp/impexp/xp/ie_exp_Psion.cpp:614:		// TODO: Set the in-block character layout here.
./wp/impexp/xp/ie_exp_Psion.cpp-615-		para.in_lines = m_currentParagraphInLines;
./wp/impexp/xp/ie_exp_Psion.cpp-616-		m_currentParagraphInLines = 0;
./wp/impexp/xp/ie_exp_Psion.cpp-617-		// We don't do replacements, because I do not really understand
./wp/impexp/xp/ie_exp_Psion.cpp-618-		// the Psion-side of it yet.
./wp/impexp/xp/ie_exp_Psion.cpp-619-		if (!(para.replacements = 
./wp/impexp/xp/ie_exp_RTF.cpp-482-			}
./wp/impexp/xp/ie_exp_RTF.cpp-483-			UT_DEBUGMSG(("Belcon:after XAP_EncodingManager::instance->CodepageFromCharset(%s),codepage=%s\n",cpgname,codepage));
./wp/impexp/xp/ie_exp_RTF.cpp-484-		}
./wp/impexp/xp/ie_exp_RTF.cpp-485-	};
./wp/impexp/xp/ie_exp_RTF.cpp-486-	if (!wrote_cpg)
./wp/impexp/xp/ie_exp_RTF.cpp:487:	    _rtf_keyword("ansicpg",1252);		// TODO what CodePage do we want here ??
./wp/impexp/xp/ie_exp_RTF.cpp-488-
./wp/impexp/xp/ie_exp_RTF.cpp-489-	_rtf_keyword("deff",0);				// default font is index 0 aka black
./wp/impexp/xp/ie_exp_RTF.cpp-490-	if (m_atticFormat)
./wp/impexp/xp/ie_exp_RTF.cpp-491-	{	
./wp/impexp/xp/ie_exp_RTF.cpp-492-		/* I'm not sure whether this makes any sense - VH */
./wp/impexp/xp/ie_exp_RTF.cpp-530-		
./wp/impexp/xp/ie_exp_RTF.cpp-531-		_rtf_close_brace();
./wp/impexp/xp/ie_exp_RTF.cpp-532-	}
./wp/impexp/xp/ie_exp_RTF.cpp-533-	_rtf_close_brace();
./wp/impexp/xp/ie_exp_RTF.cpp-534-	
./wp/impexp/xp/ie_exp_RTF.cpp:535:	// TODO write the "file table" if necessary...
./wp/impexp/xp/ie_exp_RTF.cpp-536-
./wp/impexp/xp/ie_exp_RTF.cpp-537-	kLimit = m_vecColors.getItemCount();
./wp/impexp/xp/ie_exp_RTF.cpp-538-	_rtf_nl();
./wp/impexp/xp/ie_exp_RTF.cpp-539-	_rtf_open_brace();
./wp/impexp/xp/ie_exp_RTF.cpp-540-	_rtf_keyword("colortbl");
./wp/impexp/xp/ie_exp_RTF.cpp-549-		_rtf_keyword("blue", localColor.m_blu);
./wp/impexp/xp/ie_exp_RTF.cpp-550-		_rtf_semi();
./wp/impexp/xp/ie_exp_RTF.cpp-551-	}
./wp/impexp/xp/ie_exp_RTF.cpp-552-	_rtf_close_brace();
./wp/impexp/xp/ie_exp_RTF.cpp-553-
./wp/impexp/xp/ie_exp_RTF.cpp:554:	// TODO write the "style sheets"...
./wp/impexp/xp/ie_exp_RTF.cpp:555:	// TODO write the "list table"...
./wp/impexp/xp/ie_exp_RTF.cpp:556:	// TODO write the "rev table"...
./wp/impexp/xp/ie_exp_RTF.cpp-557-
./wp/impexp/xp/ie_exp_RTF.cpp-558-	// write default character properties at global scope...
./wp/impexp/xp/ie_exp_RTF.cpp-559-	_rtf_nl();
./wp/impexp/xp/ie_exp_RTF.cpp-560-	_rtf_keyword("kerning",0);			// turn off kerning
./wp/impexp/xp/ie_exp_RTF.cpp-561-	_rtf_keyword("cf",0);				// set color 0 -- black
./wp/impexp/xp/ie_exp_RTF.cpp-619-	GR_Font::FontPitchEnum fp;
./wp/impexp/xp/ie_exp_RTF.cpp-620-	UT_Bool tt;
./wp/impexp/xp/ie_exp_RTF.cpp-621-	
./wp/impexp/xp/ie_exp_RTF.cpp-622-	GR_Font::s_getGenericFontProperties((char*)szFontFamily, &ff, &fp, &tt);
./wp/impexp/xp/ie_exp_RTF.cpp-623-
./wp/impexp/xp/ie_exp_RTF.cpp:624:	// TODO there is a general confusion in this program between fontname and fontfamily.
./wp/impexp/xp/ie_exp_RTF.cpp:625:	// TODO one is "Courier New" and the other is "Modern".  it seems that we interchange
./wp/impexp/xp/ie_exp_RTF.cpp:626:	// TODO these in a few places....
./wp/impexp/xp/ie_exp_RTF.cpp-627-	
./wp/impexp/xp/ie_exp_RTF.cpp-628-	*p_sz_font_name = szFontFamily;
./wp/impexp/xp/ie_exp_RTF.cpp-629-	
./wp/impexp/xp/ie_exp_RTF.cpp-630-	if ((ff >= 0) && (ff < (int)NrElements(t_ff)))
./wp/impexp/xp/ie_exp_RTF.cpp-631-		*p_sz_rtf_family = t_ff[ff];
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-125-			m_pie->_rtf_keyword("super");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-126-		else if (!UT_strcmp(szFontPosition,"subscript"))
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-127-			m_pie->_rtf_keyword("sub");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-128-	}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-129-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:130:	// TODO do something with our font-stretch and font-variant properties
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-131-	// note: we assume that kerning has been turned off at global scope.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-132-	
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-133-	m_bInSpan = UT_TRUE;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-134-	m_apiLastSpan = apiSpan;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-135-	return;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-226-					// RTF spec says that we should emit an ASCII-equivalent
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-227-					// character for each unicode character, so that dumb/older
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-228-					// readers don't lose a char.  i don't have a good algorithm
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-229-					// for deciding how to do this, so i'm not going to put out
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-230-					// any chars.  so i'm setting \uc0 before emitting \u<u>.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:231:					// TODO decide if we should be smarter here and do a \uc1\u<u><A> ??
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:232:					// TODO if so, we may need to begin a sub-brace level to avoid
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:233:					// TODO polluting the global context w/r/t \uc.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-234-					
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-235-					UT_UCSChar lc = XAP_EncodingManager::instance->try_UToWindows(*pData);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-236-					m_pie->_rtf_keyword("uc",lc && lc<256 ? 1 : 0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-237-					unsigned short ui = ((unsigned short)(*pData));	// RTF is limited to +/-32K ints
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-238-					signed short si = *((signed short *)(&ui));		// so we need to write negative
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-277-					// RTF spec says that we should emit an ASCII-equivalent
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-278-					// character for each unicode character, so that dumb/older
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-279-					// readers don't lose a char.  i don't have a good algorithm
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-280-					// for deciding how to do this, so i'm not going to put out
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-281-					// any chars.  so i'm setting \uc0 before emitting \u<u>.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:282:					// TODO decide if we should be smarter here and do a \uc1\u<u><A> ??
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:283:					// TODO if so, we may need to begin a sub-brace level to avoid
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:284:					// TODO polluting the global context w/r/t \uc.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-285-					
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-286-					m_pie->_rtf_keyword("uc",0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-287-					unsigned short ui = ((unsigned short)(*pData));	// RTF is limited to +/-32K ints
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-288-					signed short si = *((signed short *)(&ui));		// so we need to write negative
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-289-					m_pie->_rtf_keyword("u",si);					// numbers for large unicode values.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-339-	// and block.  when going to a file we should not.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-340-	m_bJustStartingDoc = !m_bToClipboard;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-341-	m_bJustStartingSection = !m_bToClipboard;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-342-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-343-	m_wctomb.setOutCharset(XAP_EncodingManager::instance->WindowsCharsetName());
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:344:	// TODO emit <info> if desired
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-345-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-346-	_rtf_docfmt();						// deal with <docfmt>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-347-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-348-	// <section>+ will be handled by the populate code.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-349-}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-383-				_closeSpan();
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-384-				_writeImageInRTF(pcro);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-385-				return UT_TRUE;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-386-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-387-				//#if 0
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:388:			// TODO deal with these other inline objects....
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-389-			
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-390-			case PTO_Field:
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-391-				_closeSpan();
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-392-				_openTag("field","/",UT_FALSE,api);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-393-				return UT_TRUE;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-409-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-410-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-411-void	 s_RTF_ListenerWriteDoc::_openTag(const char * szPrefix, const char * szSuffix,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-412-								 UT_Bool bNewLineAfter, PT_AttrPropIndex api)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-413-{
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:414:  UT_DEBUGMSG(("TODO: Write code to go in here. In _openTag, szPrefix = %s  api = %x \n",szPrefix,api));
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-415-}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-416-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-417-UT_Bool s_RTF_ListenerWriteDoc::populateStrux(PL_StruxDocHandle /*sdh*/,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-418-										   const PX_ChangeRecord * pcr,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-419-										   PL_StruxFmtHandle * psfh)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-498-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-499-	// <docfmt> -- document views and zoom level
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-500-	
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-501-	m_pie->_rtf_keyword("viewkind",1);	/* PageLayout */
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-502-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:503:	// TODO <docfmt> -- footnotes and endnotes
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-504-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-505-	// <docfmt> -- page information
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-506-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:507:	const XML_Char * szPaperWidth = "8.5in"; // TODO look this up in the document
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-508-	m_pie->_rtf_keyword_ifnotdefault_twips("paperw",(char*)szPaperWidth,0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:509:	const XML_Char * szPaperHeight = "11in"; // TODO look this up in the document
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-510-	m_pie->_rtf_keyword_ifnotdefault_twips("paperh",(char*)szPaperHeight,0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-511-	
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-512-	const XML_Char * szLeftMargin = PP_evalProperty("page-margin-left",
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-513-													 pSpanAP,pBlockAP,pSectionAP,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-514-													 m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-525-													 pSpanAP,pBlockAP,pSectionAP,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-526-													 m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-527-	m_pie->_rtf_keyword_ifnotdefault_twips("margb",(char*)szBottomMargin,1440);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-528-	m_pie->_rtf_keyword("widowctl");	// enable widow and orphan control
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-529-	
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:530:	// TODO <docfmt> -- linked styles
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:531:	// TODO <docfmt> -- compatibility options
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:532:	// TODO <docfmt> -- forms
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:533:	// TODO <docfmt> -- revision marks
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:534:	// TODO <docfmt> -- comments (annotations)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:535:	// TODO <docfmt> -- bidirectional controls
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:536:	// TODO <docfmt> -- page borders
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-537-}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-538-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-539-//////////////////////////////////////////////////////////////////
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-540-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-541-void s_RTF_ListenerWriteDoc::_rtf_open_section(PT_AttrPropIndex api)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-553-												 m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-554-	const XML_Char * szColumnGap = PP_evalProperty("column-gap",
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-555-												   pSpanAP,pBlockAP,pSectionAP,
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-556-												   m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-557-		
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:558:	// TODO add other properties here
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-559-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-560-	m_pie->_rtf_nl();
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-561-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-562-	if (m_bJustStartingDoc)			// 'sect' is a delimiter, rather than a plain start
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-563-		m_bJustStartingDoc = UT_FALSE;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-620-	const XML_Char * szLineHeight = PP_evalProperty("line-height",pSpanAP,pBlockAP,pSectionAP,m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-621-	const XML_Char * szKeepTogether = PP_evalProperty("keep-together",pSpanAP,pBlockAP,pSectionAP,m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-622-	const XML_Char * szKeepWithNext = PP_evalProperty("keep-with-next",pSpanAP,pBlockAP,pSectionAP,m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-623-	const XML_Char * szTabStops = PP_evalProperty("tabstops",pSpanAP,pBlockAP,pSectionAP,m_pDocument,UT_TRUE);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-624-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:625:	// TODO add other properties here
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-626-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-627-	m_pie->_rtf_nl();
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-628-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-629-	if (m_bJustStartingSection)			// 'par' is a delimiter, rather than a plain start.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-630-		m_bJustStartingSection = UT_FALSE;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-666-		m_pie->_rtf_keyword("keepn");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-667-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-668-	if (szTabStops && *szTabStops)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-669-	{
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-670-		// write tabstops for this paragraph
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:671:		// TODO the following parser was copied from abi/src/text/fmt/xp/fl_BlockLayout.cpp
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:672:		// TODO we should extract both of them and share the code.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-673-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-674-		UT_Vector vecTabs;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-675-		
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-676-		const char* pStart = szTabStops;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-677-		while (*pStart)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-736-		{
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-737-			_t * p_t = (_t *)vecTabs.getNthItem(k);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-738-			// write <tabkind>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-739-			if (p_t->m_szTabKindKeyword && *p_t->m_szTabKindKeyword)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-740-				m_pie->_rtf_keyword(p_t->m_szTabKindKeyword);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:741:			// TODO write leader character in <tablead>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-742-			// write tab type
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-743-			m_pie->_rtf_keyword(p_t->m_szTabTypeKeyword,p_t->m_iTabPosition);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-744-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-745-			delete p_t;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-746-		}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-786-	// get the width/height of the image from the image itself.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-787-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-788-	UT_sint32 iImageWidth, iImageHeight;
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-789-	UT_PNG_getDimensions(pbb,iImageWidth,iImageHeight);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-790-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:791:	// TODO compute scale factors...
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-792-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-793-	// if everything is ok, we need to dump the image data (in hex)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-794-	// to the RTF stream with some screwy keywords...
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-795-	//
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-796-	// we need to emit:     {\*\shppict{\pict <stuff>}}
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-803-		m_pie->_rtf_keyword("*");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-804-		m_pie->_rtf_keyword("shppict");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-805-		m_pie->_rtf_open_brace();
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-806-		{
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-807-			m_pie->_rtf_keyword("pict");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:808:			// TODO deal with <brdr>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:809:			// TODO deal with <shading>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-810-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-811-			// <pictype> -- we store everything internall as PNG, so that's all
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:812:			//              we output here.  TODO consider listing multiple formats
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-813-			//              here -- word97 seems to, but this really bloats the file.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-814-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-815-			m_pie->_rtf_keyword("pngblip");
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-816-			
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-817-			// <pictsize>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-822-				m_pie->_rtf_keyword_ifnotdefault_twips("picwgoal",(char*)szWidthProp,0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-823-			if (bFoundHeightProperty)
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-824-				m_pie->_rtf_keyword_ifnotdefault_twips("pichgoal",(char*)szHeightProp,0);
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-825-			// we use the default values for picscale[xy]==100, piccrop[tblr]==0
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-826-			
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:827:			// TODO deal with <metafileinfo>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-828-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-829-			// <data>
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-830-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp:831:			// TODO create meaningful values for bliptag and bliduid...
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-832-			// we emit "\bliptag<N>{\*\blipuid <N16>}"
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-833-			// where <N> is an integer.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-834-			// where <N16> is a 16-byte integer in hex.
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-835-
./wp/impexp/xp/ie_exp_RTF_listenerWriteDoc.cpp-836-			m_pie->_rtf_nl();
./wp/impexp/xp/ie_exp_Text.cpp-235-		}
./wp/impexp/xp/ie_exp_Text.cpp-236-
./wp/impexp/xp/ie_exp_Text.cpp-237-	case PX_ChangeRecord::PXT_InsertObject:
./wp/impexp/xp/ie_exp_Text.cpp-238-		{
./wp/impexp/xp/ie_exp_Text.cpp-239-#if 0
./wp/impexp/xp/ie_exp_Text.cpp:240:			// TODO decide how to indicate objects in text output.
./wp/impexp/xp/ie_exp_Text.cpp-241-			
./wp/impexp/xp/ie_exp_Text.cpp-242-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_Text.cpp-243-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_Text.cpp-244-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_Text.cpp-245-			{
./wp/impexp/xp/ie_exp_UTF8.cpp-225-		}
./wp/impexp/xp/ie_exp_UTF8.cpp-226-
./wp/impexp/xp/ie_exp_UTF8.cpp-227-	case PX_ChangeRecord::PXT_InsertObject:
./wp/impexp/xp/ie_exp_UTF8.cpp-228-		{
./wp/impexp/xp/ie_exp_UTF8.cpp-229-#if 0
./wp/impexp/xp/ie_exp_UTF8.cpp:230:			// TODO decide how to indicate objects in text output.
./wp/impexp/xp/ie_exp_UTF8.cpp-231-			
./wp/impexp/xp/ie_exp_UTF8.cpp-232-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_UTF8.cpp-233-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_UTF8.cpp-234-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_UTF8.cpp-235-			{
./wp/impexp/xp/ie_exp_WML.cpp-279-			const PX_ChangeRecord_Object * pcro = static_cast<const PX_ChangeRecord_Object *> (pcr);
./wp/impexp/xp/ie_exp_WML.cpp-280-			PT_AttrPropIndex api = pcr->getIndexAP();
./wp/impexp/xp/ie_exp_WML.cpp-281-			switch (pcro->getObjectType())
./wp/impexp/xp/ie_exp_WML.cpp-282-			{
./wp/impexp/xp/ie_exp_WML.cpp-283-			case PTO_Image:
./wp/impexp/xp/ie_exp_WML.cpp:284:				// TODO we *could* insert the images and create separate WBMP files.
./wp/impexp/xp/ie_exp_WML.cpp-285-				return UT_TRUE;
./wp/impexp/xp/ie_exp_WML.cpp-286-
./wp/impexp/xp/ie_exp_WML.cpp-287-			case PTO_Field:
./wp/impexp/xp/ie_exp_WML.cpp-288-				// we do nothing with computed fields.
./wp/impexp/xp/ie_exp_WML.cpp-289-				return UT_TRUE;
./wp/impexp/xp/ie_exp_WML.cpp-411-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_WML.cpp-412-
./wp/impexp/xp/ie_exp_WML.cpp-413-			XML_Char* p;
./wp/impexp/xp/ie_exp_WML.cpp-414-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_WML.cpp-415-			{
./wp/impexp/xp/ie_exp_WML.cpp:416:				// TODO outofmem
./wp/impexp/xp/ie_exp_WML.cpp-417-			}
./wp/impexp/xp/ie_exp_WML.cpp-418-			
./wp/impexp/xp/ie_exp_WML.cpp-419-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_WML.cpp-420-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_WML.cpp-421-
./wp/impexp/xp/ie_exp_WML.cpp-456-	if (!m_bInBlock)
./wp/impexp/xp/ie_exp_WML.cpp-457-	{
./wp/impexp/xp/ie_exp_WML.cpp-458-		return;
./wp/impexp/xp/ie_exp_WML.cpp-459-	}
./wp/impexp/xp/ie_exp_WML.cpp-460-	
./wp/impexp/xp/ie_exp_WML.cpp:461:	// TODO deal with unicode.
./wp/impexp/xp/ie_exp_WML.cpp:462:	// TODO for now, just squish it into ascii.
./wp/impexp/xp/ie_exp_WML.cpp-463-	
./wp/impexp/xp/ie_exp_WML.cpp-464-#define MY_BUFFER_SIZE		1024
./wp/impexp/xp/ie_exp_WML.cpp-465-#define MY_HIGHWATER_MARK	20
./wp/impexp/xp/ie_exp_WML.cpp-466-	char buf[MY_BUFFER_SIZE];
./wp/impexp/xp/ie_exp_WML.cpp-467-	char * pBuf;
./wp/impexp/xp/ie_exp_WML.cpp-580-					pData++;
./wp/impexp/xp/ie_exp_WML.cpp-581-				}
./wp/impexp/xp/ie_exp_WML.cpp-582-#	endif
./wp/impexp/xp/ie_exp_WML.cpp-583-#else
./wp/impexp/xp/ie_exp_WML.cpp-584-				// convert to UTF8
./wp/impexp/xp/ie_exp_WML.cpp:585:				// TODO if we choose this, do we have to put the ISO header in
./wp/impexp/xp/ie_exp_WML.cpp:586:				// TODO like we did for the strings files.... i hesitate to
./wp/impexp/xp/ie_exp_WML.cpp:587:				// TODO make such a change to our file format.
./wp/impexp/xp/ie_exp_WML.cpp-588-				XML_Char * pszUTF8 = UT_encodeUTF8char(*pData);
./wp/impexp/xp/ie_exp_WML.cpp-589-				while (*pszUTF8)
./wp/impexp/xp/ie_exp_WML.cpp-590-				{
./wp/impexp/xp/ie_exp_WML.cpp-591-					*pBuf++ = (UT_Byte)*pszUTF8;
./wp/impexp/xp/ie_exp_WML.cpp-592-					pszUTF8++;
./wp/impexp/xp/ie_exp_WML.cpp-634-			const XML_Char* pszDecor = szValue;
./wp/impexp/xp/ie_exp_WML.cpp-635-
./wp/impexp/xp/ie_exp_WML.cpp-636-			XML_Char* p;
./wp/impexp/xp/ie_exp_WML.cpp-637-			if (!UT_cloneString((char *&)p, pszDecor))
./wp/impexp/xp/ie_exp_WML.cpp-638-			{
./wp/impexp/xp/ie_exp_WML.cpp:639:				// TODO outofmem
./wp/impexp/xp/ie_exp_WML.cpp-640-			}
./wp/impexp/xp/ie_exp_WML.cpp-641-			
./wp/impexp/xp/ie_exp_WML.cpp-642-			UT_ASSERT(p || !pszDecor);
./wp/impexp/xp/ie_exp_WML.cpp-643-			XML_Char*	q = strtok(p, " ");
./wp/impexp/xp/ie_exp_WML.cpp-644-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-135-#define TT_STYLE		13		// a style <s> within a style section
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-136-#define TT_LISTSECTION		14	// a list section <lists>
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-137-#define TT_LIST			15	// a list <l> within a list section
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-138-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-139-/*
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:140:  TODO remove tag synonyms.  We're currently accepted
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-141-  synonyms for tags, as follows:
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-142-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-143-  abiword	awml
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-144-  field		f
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-145-  image		i
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-234-		X_CheckError(m_pDocument->appendFmt(&m_vecInlineFmt));
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-235-		return;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-236-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-237-		// Images and Fields are not containers.  Therefore we don't
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-238-		// push the ParseState (_PS_...).
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:239:		// TODO should Images or Fields inherit the (possibly nested)
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:240:		// TODO inline span formatting.
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-241-		
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-242-	case TT_IMAGE:
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-243-		X_VerifyParseState(_PS_Block);
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-244-		X_CheckError(m_pDocument->appendObject(PTO_Image,atts));
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-245-		return;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-261-	        if(X_TestParseState(_PS_Field))
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-262-		  return; // just return
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-263-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-264-		X_VerifyParseState(_PS_Block);
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-265-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:266:		// TODO decide if we should push and pop the attr's
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:267:		// TODO that came in with the <br/>.  that is, decide
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:268:		// TODO if <br/>'s will have any attributes or will
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:269:		// TODO just inherit everything from the surrounding
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:270:		// TODO spans.
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-271-		{
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-272-			UT_UCSChar ucs = UCS_LF;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-273-			X_CheckError(m_pDocument->appendSpan(&ucs,1));
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-274-		}
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-275-		return;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-279-	        if(X_TestParseState(_PS_Field))
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-280-		        return; // just return
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-281-#endif
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-282-		X_VerifyParseState(_PS_Block);
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-283-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:284:		// TODO decide if we should push and pop the attr's
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:285:		// TODO that came in with the <cbr/>.  that is, decide
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:286:		// TODO if <cbr/>'s will have any attributes or will
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:287:		// TODO just inherit everything from the surrounding
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:288:		// TODO spans.
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-289-		{
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-290-			UT_UCSChar ucs = UCS_VTAB;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-291-			X_CheckError(m_pDocument->appendSpan(&ucs,1));
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-292-		}
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-293-		return;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-297-		if(X_TestParseState(_PS_Field)
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-298-		         return; //just return
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-299-#endif
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-300-
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-301-		X_VerifyParseState(_PS_Block);
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:302:		// TODO decide if we should push and pop the attr's
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:303:		// TODO that came in with the <pbr/>.  that is, decide
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:304:		// TODO if <pbr/>'s will have any attributes or will
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:305:		// TODO just inherit everything from the surrounding
./wp/impexp/xp/ie_imp_AbiWord_1.cpp:306:		// TODO spans.
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-307-		{
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-308-			UT_UCSChar ucs = UCS_FF;
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-309-			X_CheckError(m_pDocument->appendSpan(&ucs,1));
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-310-		}
./wp/impexp/xp/ie_imp_AbiWord_1.cpp-311-		return;
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-184-           
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-185-           // deal with plain character.
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-186-           // this cast is OK.  we have US-ASCII (actually Latin-1) character
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-187-           // data, so we can do this.
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-188-           
./wp/impexp/xp/ie_imp_ClarisWorks.cpp:189:           // TODO consider scanning for UTF8...
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-190-           
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-191-           UT_UCSChar uc = (UT_UCSChar) c;
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-192-           X_ReturnNoMemIfError(gbBlock.ins(gbBlock.getLength(),&uc,1));
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-193-           break;
./wp/impexp/xp/ie_imp_ClarisWorks.cpp-194-       }
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-54-/*****************************************************************/
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-55-/*****************************************************************/
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-56-
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-57-UT_Bool IE_Imp_GZipAbiWord::RecognizeContents(const char * szBuf, UT_uint32 iNumbytes)
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-58-{
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:59:	// TODO: This is a hack.  Since we're just passed in some
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:60:	// TODO: some data, and not the actual filename, there isn't
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:61:	// TODO: much we can do other than verify that it is gzip'ed
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:62:	// TODO: data.  For the time being, assume that if it is
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:63:	// TODO: gzip'ed, it's gzip'ed abiword.  This assumption will
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:64:	// TODO: be false if and when we support any other compressed
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp:65:	// TODO: formats.
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-66-	if ( iNumbytes < 2 ) return(UT_FALSE);
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-67-	if ( ( szBuf[0] == (char)0x1f ) && ( szBuf[1] == (char)0x8b ) )
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-68-	{
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-69-		return(UT_TRUE);
./wp/impexp/xp/ie_imp_GZipAbiWord.cpp-70-	}
./wp/impexp/xp/ie_imp_MSWrite.cpp-264-                
./wp/impexp/xp/ie_imp_MSWrite.cpp-265-                // deal with plain character.
./wp/impexp/xp/ie_imp_MSWrite.cpp-266-                // this cast is OK.  we have US-ASCII (actually Latin-1) character
./wp/impexp/xp/ie_imp_MSWrite.cpp-267-                // data, so we can do this.
./wp/impexp/xp/ie_imp_MSWrite.cpp-268-                
./wp/impexp/xp/ie_imp_MSWrite.cpp:269:                // TODO consider scanning for CP1252 
./wp/impexp/xp/ie_imp_MSWrite.cpp-270-                // because actually it is CP1252 and NOT Latin-1
./wp/impexp/xp/ie_imp_MSWrite.cpp-271-                
./wp/impexp/xp/ie_imp_MSWrite.cpp-272-                UT_UCSChar uc = (UT_UCSChar) c;
./wp/impexp/xp/ie_imp_MSWrite.cpp-273-                X_ReturnNoMemIfError(gbBlock.ins(gbBlock.getLength(),&uc,1));
./wp/impexp/xp/ie_imp_MSWrite.cpp-274-                break;
./wp/impexp/xp/ie_imp_MSWrite.cpp-540-IE_Imp_MSWrite::MakeProperties (XML_Char * buf, const size_t bufSize,
./wp/impexp/xp/ie_imp_MSWrite.cpp-541-                                XML_Char * attr, XML_Char * value)
./wp/impexp/xp/ie_imp_MSWrite.cpp-542-   //  build a properties XML pair and add it to the buffer.
./wp/impexp/xp/ie_imp_MSWrite.cpp-543-   //  return buf.
./wp/impexp/xp/ie_imp_MSWrite.cpp-544-   //
./wp/impexp/xp/ie_imp_MSWrite.cpp:545:   //  TODO: make buf dynamically reallocated if needed.
./wp/impexp/xp/ie_imp_MSWrite.cpp-546-{
./wp/impexp/xp/ie_imp_MSWrite.cpp-547-    XML_Char * temp = (XML_Char *)malloc ((strlen (attr) + strlen (value) + 1) 
./wp/impexp/xp/ie_imp_MSWrite.cpp-548-                                          * sizeof (XML_Char));
./wp/impexp/xp/ie_imp_MSWrite.cpp-549-    // here we know that 'temp' has the right size. No overflow possible
./wp/impexp/xp/ie_imp_MSWrite.cpp-550-    sprintf (temp, attr, value);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-164-	     //eachchar = XAP_EncodingManager::instance->UToNative(eachchar);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-165-	     
./wp/impexp/xp/ie_imp_MsWord_97.cpp-166-	   xxx_UT_DEBUGMSG(("word 97 char is %c (%d), type is %d\n",eachchar,(int)eachchar,chartype));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-167-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-168-	   // take care of any oddities in Microsoft's character "encoding"
./wp/impexp/xp/ie_imp_MsWord_97.cpp:169:	   // TODO: does the above code page handler take care of these?
./wp/impexp/xp/ie_imp_MsWord_97.cpp-170-	   if (chartype == 1 && eachchar == 146) eachchar = 39; // apostrophe
./wp/impexp/xp/ie_imp_MsWord_97.cpp-171-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-172-	   // marks, breaks, etc.
./wp/impexp/xp/ie_imp_MsWord_97.cpp-173-	   switch (eachchar)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-174-	     {
./wp/impexp/xp/ie_imp_MsWord_97.cpp-214-		ps->fieldmiddle = 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-215-		pDocReader->_fieldProc(ps, eachchar, chartype, lid);	/* temp */
./wp/impexp/xp/ie_imp_MsWord_97.cpp-216-		return 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-217-	     }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-218-
./wp/impexp/xp/ie_imp_MsWord_97.cpp:219:	   // TODO: it seems the text which is displayed by a field is contained
./wp/impexp/xp/ie_imp_MsWord_97.cpp:220:	   // TODO: after the field separator. since I haven't written real field
./wp/impexp/xp/ie_imp_MsWord_97.cpp:221:	   // TODO: import support, yet, this will fake it somewhat...
./wp/impexp/xp/ie_imp_MsWord_97.cpp-222-	   if (ps->fieldstate) {
./wp/impexp/xp/ie_imp_MsWord_97.cpp-223-	     if(pDocReader->_fieldProc(ps, eachchar, chartype, lid))
./wp/impexp/xp/ie_imp_MsWord_97.cpp-224-	       return 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-225-	   }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-226-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-252-   long pos;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-253-   FSPA * fspa;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-254-   PICF picf;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-255-   FDOA * fdoa;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-256-   
./wp/impexp/xp/ie_imp_MsWord_97.cpp:257:   // TODO: handle special characters (images, objects, fields(?))
./wp/impexp/xp/ie_imp_MsWord_97.cpp-258-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-259-   switch (eachchar)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-260-     {
./wp/impexp/xp/ie_imp_MsWord_97.cpp-261-      case 19: // field begin
./wp/impexp/xp/ie_imp_MsWord_97.cpp-262-	// flush current text buffer
./wp/impexp/xp/ie_imp_MsWord_97.cpp-296-   switch (eachchar) 
./wp/impexp/xp/ie_imp_MsWord_97.cpp-297-     {
./wp/impexp/xp/ie_imp_MsWord_97.cpp-298-     case 0x01:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-299-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-300-	if (achp->fOle2) {
./wp/impexp/xp/ie_imp_MsWord_97.cpp:301:	   // TODO: support embedded OLE2 components...
./wp/impexp/xp/ie_imp_MsWord_97.cpp-302-	   xxx_UT_DEBUGMSG(("embedded OLE2 component. currently unsupported"));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-303-	   return 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-304-	}
./wp/impexp/xp/ie_imp_MsWord_97.cpp-305-	
./wp/impexp/xp/ie_imp_MsWord_97.cpp-306-	pos = wvStream_tell(ps->data);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-360-	else
./wp/impexp/xp/ie_imp_MsWord_97.cpp-361-	  {
./wp/impexp/xp/ie_imp_MsWord_97.cpp-362-	     UT_DEBUGMSG(("pre Word8 0x08 graphic -- unsupported at the moment"));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-363-	     fdoa = wvGetFDOAFromCP(ps->currentcp, NULL, ps->fdoapos, ps->nooffdoa);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-364-	     
./wp/impexp/xp/ie_imp_MsWord_97.cpp:365:	     // TODO: do something with the data in this fdoa someday...	     
./wp/impexp/xp/ie_imp_MsWord_97.cpp-366-	  }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-367-	
./wp/impexp/xp/ie_imp_MsWord_97.cpp-368-	return 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-369-	break;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-370-	
./wp/impexp/xp/ie_imp_MsWord_97.cpp-452-	       * field when we see FC_DateTimePicture, but this should be good enough
./wp/impexp/xp/ie_imp_MsWord_97.cpp-453-	       */
./wp/impexp/xp/ie_imp_MsWord_97.cpp-454-	      X_CheckError0(m_pDocument->appendObject(PTO_Field,atts));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-455-	      break;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-456-
./wp/impexp/xp/ie_imp_MsWord_97.cpp:457:	      // TODO: get Abi to support more field types :-)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-458-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-459-	    default: 
./wp/impexp/xp/ie_imp_MsWord_97.cpp-460-	      break;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-461-	    }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-462-	}
./wp/impexp/xp/ie_imp_MsWord_97.cpp-607-			      "column-gap:%s;", 
./wp/impexp/xp/ie_imp_MsWord_97.cpp-608-			      UT_convertInchesToDimensionString(DIM_IN, (((float)asep->dxaColumns) / 1440), "1.4"));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-609-		   }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-610-		   
./wp/impexp/xp/ie_imp_MsWord_97.cpp-611-		   // space after section 
./wp/impexp/xp/ie_imp_MsWord_97.cpp:612:		   // TODO: this is the gutter, right?
./wp/impexp/xp/ie_imp_MsWord_97.cpp-613-		   sprintf(propBuffer + strlen(propBuffer),
./wp/impexp/xp/ie_imp_MsWord_97.cpp-614-			   "section-space-after:%s;",
./wp/impexp/xp/ie_imp_MsWord_97.cpp-615-			   UT_convertInchesToDimensionString(DIM_IN, (((float)asep->dzaGutter) / 1440), "1.4"));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-616-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-617-		   // remove trailing semi-colon
./wp/impexp/xp/ie_imp_MsWord_97.cpp-635-		   apap = (PAP*)props;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-636-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-637-		   // break before paragraph?
./wp/impexp/xp/ie_imp_MsWord_97.cpp-638-		   if (apap->fPageBreakBefore)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-639-		     {
./wp/impexp/xp/ie_imp_MsWord_97.cpp:640:		        // TODO: this should really set a property in
./wp/impexp/xp/ie_imp_MsWord_97.cpp:641:		        // TODO: in the paragraph, instead; but this
./wp/impexp/xp/ie_imp_MsWord_97.cpp:642:		        // TODO: gives a similar effect for now.
./wp/impexp/xp/ie_imp_MsWord_97.cpp-643-			UT_UCSChar ucs = UCS_FF;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-644-                        m_pDocument->appendSpan(&ucs,1);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-645-		     }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-646-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-647-		   // paragraph alignment
./wp/impexp/xp/ie_imp_MsWord_97.cpp-933-/*****************************************************************/
./wp/impexp/xp/ie_imp_MsWord_97.cpp-934-/*****************************************************************/
./wp/impexp/xp/ie_imp_MsWord_97.cpp-935-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-936-UT_Bool IE_Imp_MsWord_97::RecognizeContents(const char * szBuf, UT_uint32 iNumbytes)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-937-{
./wp/impexp/xp/ie_imp_MsWord_97.cpp:938:	// TODO: This is rather crude, because we don't parse OLE files.
./wp/impexp/xp/ie_imp_MsWord_97.cpp:939:	// TODO: For the time being, we assume that any OLE file is an
./wp/impexp/xp/ie_imp_MsWord_97.cpp:940:	// TODO: msword document.
./wp/impexp/xp/ie_imp_MsWord_97.cpp:941:	// TODO: Caolan is gonna kill me for this.  :)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-942-	// Most of the magic numbers here were taken from the public domain
./wp/impexp/xp/ie_imp_MsWord_97.cpp-943-	// /etc/magic file distributed with the file(1) command written
./wp/impexp/xp/ie_imp_MsWord_97.cpp-944-	// by Ian F. Darwin, with contributions and magic entries from
./wp/impexp/xp/ie_imp_MsWord_97.cpp-945-	// Rob McMahon, Guy Harris, Christos Zoulas <christos@astron.com>,
./wp/impexp/xp/ie_imp_MsWord_97.cpp-946-	// Mark Moraes <moraes@deshaw.com>, and Pawel Wiecek.
./wp/impexp/xp/ie_imp_MsWord_97.cpp-989-			 szBuf[2] == (char)0 && szBuf[3] == (char)0x23 )
./wp/impexp/xp/ie_imp_MsWord_97.cpp-990-		{
./wp/impexp/xp/ie_imp_MsWord_97.cpp-991-			return(UT_TRUE);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-992-		}
./wp/impexp/xp/ie_imp_MsWord_97.cpp-993-		// OLE magic:
./wp/impexp/xp/ie_imp_MsWord_97.cpp:994:		// TODO: Dig through the OLE file
./wp/impexp/xp/ie_imp_MsWord_97.cpp-995-		if ( szBuf[0] == (char)0xd0 && szBuf[1] == (char)0xcf &&
./wp/impexp/xp/ie_imp_MsWord_97.cpp-996-			 szBuf[2] == (char)0x11 && szBuf[3] == (char)0xe0 &&
./wp/impexp/xp/ie_imp_MsWord_97.cpp-997-			 szBuf[4] == (char)0xa1 && szBuf[5] == (char)0xb1 &&
./wp/impexp/xp/ie_imp_MsWord_97.cpp-998-			 szBuf[6] == (char)0x1a && szBuf[7] == (char)0xe1 )
./wp/impexp/xp/ie_imp_MsWord_97.cpp-999-		{
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1041-//////////////////////////////////////////////////////////////////
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1042-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1043-void IE_Imp_MsWord_97::pasteFromBuffer(PD_DocumentRange * pDocRange,
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1044-				       unsigned char * pData, UT_uint32 lenData)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1045-{
./wp/impexp/xp/ie_imp_MsWord_97.cpp:1046:	xxx_UT_DEBUGMSG(("TODO IE_Imp_MsWord_97::pasteFromBuffer\n"));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1047-}
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1048-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1049-UT_Error IE_Imp_MsWord_97::_handleImage(Blip * b, long width, long height)
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1050-{
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1051-   int data = 0;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1071-      case msoblipWMF:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1072-      case msoblipEMF:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1073-      case msoblipPICT:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1074-      case msoblipJPEG:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1075-      default:
./wp/impexp/xp/ie_imp_MsWord_97.cpp:1076:	// TODO: support other image types
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1077-	return UT_ERROR;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1078-     }
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1079-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1080-   buf = new UT_ByteBuf();
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1081-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1124-   X_CheckError0(m_pDocument->createDataItem((char*)propsName, UT_FALSE,
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1125-					     pBBPNG, (void*)mimetype, NULL));
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1126-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1127- HandleImgEnd:
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1128-
./wp/impexp/xp/ie_imp_MsWord_97.cpp:1129:   // TODO: free mimetype??
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1130-
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1131-   DELETEP(buf);
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1132-   return err;
./wp/impexp/xp/ie_imp_MsWord_97.cpp-1133-}
./wp/impexp/xp/ie_imp_RTF.cpp-659-
./wp/impexp/xp/ie_imp_RTF.cpp-660-UT_Bool IE_Imp_RTF::SkipBackChar(unsigned char ch)
./wp/impexp/xp/ie_imp_RTF.cpp-661-{
./wp/impexp/xp/ie_imp_RTF.cpp-662-	if (m_pImportFile)					// if we are reading a file
./wp/impexp/xp/ie_imp_RTF.cpp-663-	{
./wp/impexp/xp/ie_imp_RTF.cpp:664:		// TODO - I've got a sneaking suspicion that this doesn't work on the Macintosh
./wp/impexp/xp/ie_imp_RTF.cpp-665-		return (ungetc(ch, m_pImportFile) != EOF);
./wp/impexp/xp/ie_imp_RTF.cpp-666-	}
./wp/impexp/xp/ie_imp_RTF.cpp-667-	else								// else we are pasting from a buffer
./wp/impexp/xp/ie_imp_RTF.cpp-668-	{
./wp/impexp/xp/ie_imp_RTF.cpp-669-		UT_Bool bStatus = (m_pCurrentCharInPasteBuffer > m_pPasteBuffer);
./wp/impexp/xp/ie_imp_RTF.cpp-750-		{
./wp/impexp/xp/ie_imp_RTF.cpp-751-			return HandleFontSize(fParam ? param : 24);
./wp/impexp/xp/ie_imp_RTF.cpp-752-		}
./wp/impexp/xp/ie_imp_RTF.cpp-753-		else if (strcmp((char*)pKeyword, "f") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-754-		{
./wp/impexp/xp/ie_imp_RTF.cpp:755:			return HandleFace(fParam ? param : 0); // TODO read the deff prop and use that instead of 0
./wp/impexp/xp/ie_imp_RTF.cpp-756-		}
./wp/impexp/xp/ie_imp_RTF.cpp-757-		else if (strcmp((char*)pKeyword, "fi") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-758-		{
./wp/impexp/xp/ie_imp_RTF.cpp-759-			m_currentRTFState.m_paraProps.m_indentFirst = param;
./wp/impexp/xp/ie_imp_RTF.cpp-760-		}
./wp/impexp/xp/ie_imp_RTF.cpp-767-			// italic - either on or off depending on the parameter
./wp/impexp/xp/ie_imp_RTF.cpp-768-			return HandleItalic(fParam ? UT_FALSE : UT_TRUE);
./wp/impexp/xp/ie_imp_RTF.cpp-769-		}
./wp/impexp/xp/ie_imp_RTF.cpp-770-		else if (strcmp((char*)pKeyword, "info") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-771-		{
./wp/impexp/xp/ie_imp_RTF.cpp:772:			// TODO Ignore document info for the moment
./wp/impexp/xp/ie_imp_RTF.cpp-773-			m_currentRTFState.m_destinationState = RTFStateStore::rdsSkip;
./wp/impexp/xp/ie_imp_RTF.cpp-774-		}
./wp/impexp/xp/ie_imp_RTF.cpp-775-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-776-
./wp/impexp/xp/ie_imp_RTF.cpp-777-	case 'l':
./wp/impexp/xp/ie_imp_RTF.cpp-855-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-856-
./wp/impexp/xp/ie_imp_RTF.cpp-857-	case 's':
./wp/impexp/xp/ie_imp_RTF.cpp-858-		if (strcmp((char*)pKeyword, "stylesheet") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-859-		{
./wp/impexp/xp/ie_imp_RTF.cpp:860:			// TODO Ignore stylesheet as ABIWord doesn't do styles (at the moment)
./wp/impexp/xp/ie_imp_RTF.cpp-861-			// In the text all applied styles also have their equivlent effects on too
./wp/impexp/xp/ie_imp_RTF.cpp-862-			m_currentRTFState.m_destinationState = RTFStateStore::rdsSkip;
./wp/impexp/xp/ie_imp_RTF.cpp-863-		}
./wp/impexp/xp/ie_imp_RTF.cpp-864-		else if (strcmp((char*)pKeyword, "strike") == 0  ||  strcmp((char*)pKeyword, "striked") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-865-		{
./wp/impexp/xp/ie_imp_RTF.cpp-981-                            }
./wp/impexp/xp/ie_imp_RTF.cpp-982-			}
./wp/impexp/xp/ie_imp_RTF.cpp-983-		    }
./wp/impexp/xp/ie_imp_RTF.cpp-984-
./wp/impexp/xp/ie_imp_RTF.cpp-985-// Ignore all other \* tags
./wp/impexp/xp/ie_imp_RTF.cpp:986:// TODO different destination (all unhandled at the moment, so enter skip mode)
./wp/impexp/xp/ie_imp_RTF.cpp-987-			m_currentRTFState.m_destinationState = RTFStateStore::rdsSkip;
./wp/impexp/xp/ie_imp_RTF.cpp-988-		}
./wp/impexp/xp/ie_imp_RTF.cpp-989-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-990-	case '\'':
./wp/impexp/xp/ie_imp_RTF.cpp-991-		if (strcmp((char*)pKeyword, "\'") == 0)
./wp/impexp/xp/ie_imp_RTF.cpp-1000-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-1001-	case '~':
./wp/impexp/xp/ie_imp_RTF.cpp-1002-		ParseChar(UCS_NBSP);
./wp/impexp/xp/ie_imp_RTF.cpp-1003-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-1004-	case '-':
./wp/impexp/xp/ie_imp_RTF.cpp:1005:		// TODO handle optional hyphen. Currently simply ignore them.
./wp/impexp/xp/ie_imp_RTF.cpp-1006-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-1007-	case '_':
./wp/impexp/xp/ie_imp_RTF.cpp-1008-		// currently simply make a standard hyphen
./wp/impexp/xp/ie_imp_RTF.cpp:1009:		ParseChar('-');	// TODO - make these optional and nonbreaking
./wp/impexp/xp/ie_imp_RTF.cpp-1010-		break;
./wp/impexp/xp/ie_imp_RTF.cpp-1011-	}
./wp/impexp/xp/ie_imp_RTF.cpp-1012-
./wp/impexp/xp/ie_imp_RTF.cpp-1013-	return UT_TRUE;
./wp/impexp/xp/ie_imp_RTF.cpp-1014-}
./wp/impexp/xp/ie_imp_RTF.cpp-1015-
./wp/impexp/xp/ie_imp_RTF.cpp-1016-
./wp/impexp/xp/ie_imp_RTF.cpp-1017-UT_Bool IE_Imp_RTF::ApplyCharacterAttributes()
./wp/impexp/xp/ie_imp_RTF.cpp-1018-{
./wp/impexp/xp/ie_imp_RTF.cpp-1019-	XML_Char* pProps = "props";
./wp/impexp/xp/ie_imp_RTF.cpp:1020:	XML_Char propBuffer[1024];	//TODO is this big enough?  better to make it a member and stop running all over the stack
./wp/impexp/xp/ie_imp_RTF.cpp-1021-	XML_Char tempBuffer[130];
./wp/impexp/xp/ie_imp_RTF.cpp-1022-
./wp/impexp/xp/ie_imp_RTF.cpp-1023-	propBuffer[0] = 0;
./wp/impexp/xp/ie_imp_RTF.cpp-1024-
./wp/impexp/xp/ie_imp_RTF.cpp-1025-	// bold
./wp/impexp/xp/ie_imp_RTF.cpp-1130-
./wp/impexp/xp/ie_imp_RTF.cpp-1131-
./wp/impexp/xp/ie_imp_RTF.cpp-1132-UT_Bool IE_Imp_RTF::ApplyParagraphAttributes()
./wp/impexp/xp/ie_imp_RTF.cpp-1133-{
./wp/impexp/xp/ie_imp_RTF.cpp-1134-	XML_Char* pProps = "props";
./wp/impexp/xp/ie_imp_RTF.cpp:1135:	XML_Char propBuffer[1024];	//TODO is this big enough?  better to make it a member and stop running all over the stack // TODO consider using a UT_ByteBuf instead -- jeff
./wp/impexp/xp/ie_imp_RTF.cpp-1136-	XML_Char tempBuffer[128];
./wp/impexp/xp/ie_imp_RTF.cpp-1137-
./wp/impexp/xp/ie_imp_RTF.cpp-1138-	propBuffer[0] = 0;
./wp/impexp/xp/ie_imp_RTF.cpp-1139-
./wp/impexp/xp/ie_imp_RTF.cpp-1140-	// tabs
./wp/impexp/xp/ie_imp_RTF.cpp-1150-				strcat(propBuffer, ",");
./wp/impexp/xp/ie_imp_RTF.cpp-1151-
./wp/impexp/xp/ie_imp_RTF.cpp-1152-			UT_sint32 tabTwips = (UT_sint32)m_currentRTFState.m_paraProps.m_tabStops.getNthItem(i);
./wp/impexp/xp/ie_imp_RTF.cpp-1153-			double tabIn = tabTwips/(20.0*72.0);
./wp/impexp/xp/ie_imp_RTF.cpp-1154-
./wp/impexp/xp/ie_imp_RTF.cpp:1155:			sprintf(tempBuffer, "%s/L", UT_convertInchesToDimensionString(DIM_IN,tabIn,"04"));	// TODO - left tabs only
./wp/impexp/xp/ie_imp_RTF.cpp-1156-			strcat(propBuffer, tempBuffer);
./wp/impexp/xp/ie_imp_RTF.cpp-1157-		}
./wp/impexp/xp/ie_imp_RTF.cpp-1158-
./wp/impexp/xp/ie_imp_RTF.cpp-1159-		strcat(propBuffer, "; ");
./wp/impexp/xp/ie_imp_RTF.cpp-1160-	}
./wp/impexp/xp/ie_imp_RTF.cpp-1245-
./wp/impexp/xp/ie_imp_RTF.cpp-1246-
./wp/impexp/xp/ie_imp_RTF.cpp-1247-UT_Bool IE_Imp_RTF::ApplySectionAttributes()
./wp/impexp/xp/ie_imp_RTF.cpp-1248-{
./wp/impexp/xp/ie_imp_RTF.cpp-1249-	XML_Char* pProps = "props";
./wp/impexp/xp/ie_imp_RTF.cpp:1250:	XML_Char propBuffer[1024];	//TODO is this big enough?  better to make it a member and stop running all over the stack
./wp/impexp/xp/ie_imp_RTF.cpp-1251-	XML_Char tempBuffer[128];
./wp/impexp/xp/ie_imp_RTF.cpp-1252-
./wp/impexp/xp/ie_imp_RTF.cpp-1253-	propBuffer[0] = 0;
./wp/impexp/xp/ie_imp_RTF.cpp-1254-
./wp/impexp/xp/ie_imp_RTF.cpp-1255-	// columns
./wp/impexp/xp/ie_imp_RTF.cpp-1292-		return UT_FALSE;
./wp/impexp/xp/ie_imp_RTF.cpp-1293-
./wp/impexp/xp/ie_imp_RTF.cpp-1294-	if (ch == '\\')
./wp/impexp/xp/ie_imp_RTF.cpp-1295-	{
./wp/impexp/xp/ie_imp_RTF.cpp-1296-		// one entry in the font table
./wp/impexp/xp/ie_imp_RTF.cpp:1297:		// TODO - Test one item font tables!
./wp/impexp/xp/ie_imp_RTF.cpp-1298-		if (!ReadOneFontFromTable())
./wp/impexp/xp/ie_imp_RTF.cpp-1299-			return UT_FALSE;
./wp/impexp/xp/ie_imp_RTF.cpp-1300-	}
./wp/impexp/xp/ie_imp_RTF.cpp-1301-	else
./wp/impexp/xp/ie_imp_RTF.cpp-1302-	{
./wp/impexp/xp/ie_imp_RTF.cpp-1436-				panose[i] = val;
./wp/impexp/xp/ie_imp_RTF.cpp-1437-			}
./wp/impexp/xp/ie_imp_RTF.cpp-1438-			--nesting;/*since this loop will break on '}'*/
./wp/impexp/xp/ie_imp_RTF.cpp-1439-		}
./wp/impexp/xp/ie_imp_RTF.cpp-1440-
./wp/impexp/xp/ie_imp_RTF.cpp:1441:		//TODO - handle the other keywords
./wp/impexp/xp/ie_imp_RTF.cpp-1442-
./wp/impexp/xp/ie_imp_RTF.cpp-1443-		if (!ReadCharFromFile(&ch))
./wp/impexp/xp/ie_imp_RTF.cpp-1444-			return UT_FALSE;
./wp/impexp/xp/ie_imp_RTF.cpp-1445-	}
./wp/impexp/xp/ie_imp_RTF.cpp-1446-	//we fall back here when space between parameter of keyword and font name
./wp/impexp/xp/ie_imp_RTF.cpp-1465-	if (!UT_stricmp((const char*)keyword,"helvetica"))
./wp/impexp/xp/ie_imp_RTF.cpp-1466-		strcpy((char*)keyword,"Helvetic");
./wp/impexp/xp/ie_imp_RTF.cpp-1467-
./wp/impexp/xp/ie_imp_RTF.cpp-1468-	if (!UT_cloneString(pFontName, (char*)keyword))
./wp/impexp/xp/ie_imp_RTF.cpp-1469-	{
./wp/impexp/xp/ie_imp_RTF.cpp:1470:		// TODO outofmem
./wp/impexp/xp/ie_imp_RTF.cpp-1471-	}			
./wp/impexp/xp/ie_imp_RTF.cpp-1472-	for(int i=0;i<=nesting;++i)
./wp/impexp/xp/ie_imp_RTF.cpp-1473-	{
./wp/impexp/xp/ie_imp_RTF.cpp-1474-		// Munch the remaining control words down to the close brace
./wp/impexp/xp/ie_imp_RTF.cpp-1475-		while (ch != '}')
./wp/impexp/xp/ie_imp_Text.cpp-240-/*****************************************************************/
./wp/impexp/xp/ie_imp_Text.cpp-241-/*****************************************************************/
./wp/impexp/xp/ie_imp_Text.cpp-242-
./wp/impexp/xp/ie_imp_Text.cpp-243-UT_Bool IE_Imp_Text::RecognizeContents(const char * szBuf, UT_uint32 iNumbytes)
./wp/impexp/xp/ie_imp_Text.cpp-244-{
./wp/impexp/xp/ie_imp_Text.cpp:245:	// TODO: We give the other guys a chance, since this
./wp/impexp/xp/ie_imp_Text.cpp:246:	// TODO: importer is so generic.  Does this seem
./wp/impexp/xp/ie_imp_Text.cpp:247:	// TODO: like a sensible strategy?
./wp/impexp/xp/ie_imp_Text.cpp-248-	return(UT_FALSE);
./wp/impexp/xp/ie_imp_Text.cpp-249-}
./wp/impexp/xp/ie_imp_Text.cpp-250-
./wp/impexp/xp/ie_imp_Text.cpp-251-UT_Bool IE_Imp_Text::RecognizeSuffix(const char * szSuffix)
./wp/impexp/xp/ie_imp_Text.cpp-252-{
./wp/impexp/xp/ie_imp_UTF8.cpp-306-/*****************************************************************/
./wp/impexp/xp/ie_imp_UTF8.cpp-307-/*****************************************************************/
./wp/impexp/xp/ie_imp_UTF8.cpp-308-
./wp/impexp/xp/ie_imp_UTF8.cpp-309-UT_Bool IE_Imp_UTF8::RecognizeContents(const char * szBuf, UT_uint32 iNumbytes)
./wp/impexp/xp/ie_imp_UTF8.cpp-310-{
./wp/impexp/xp/ie_imp_UTF8.cpp:311:	// TODO: Not yet written
./wp/impexp/xp/ie_imp_UTF8.cpp-312-	return(UT_FALSE);
./wp/impexp/xp/ie_imp_UTF8.cpp-313-}
./wp/impexp/xp/ie_imp_UTF8.cpp-314-
./wp/impexp/xp/ie_imp_UTF8.cpp-315-UT_Bool IE_Imp_UTF8::RecognizeSuffix(const char * szSuffix)
./wp/impexp/xp/ie_imp_UTF8.cpp-316-{
./wp/impexp/xp/ie_imp_XHTML.cpp-270-/*****************************************************************/
./wp/impexp/xp/ie_imp_XHTML.cpp-271-/*****************************************************************/
./wp/impexp/xp/ie_imp_XHTML.cpp-272-
./wp/impexp/xp/ie_imp_XHTML.cpp-273-static void convertFontFace(char *szDest, const char *szFrom)
./wp/impexp/xp/ie_imp_XHTML.cpp-274-{
./wp/impexp/xp/ie_imp_XHTML.cpp:275:  // TODO: make me better
./wp/impexp/xp/ie_imp_XHTML.cpp:276:  // TODO: and handle things like comma lists of font faces
./wp/impexp/xp/ie_imp_XHTML.cpp-277-  char *newFont;
./wp/impexp/xp/ie_imp_XHTML.cpp-278-
./wp/impexp/xp/ie_imp_XHTML.cpp-279-  // default...
./wp/impexp/xp/ie_imp_XHTML.cpp-280-  if(szFrom == NULL)
./wp/impexp/xp/ie_imp_XHTML.cpp-281-    newFont = "Times New Roman";
./wp/impexp/xp/ie_imp_XML.cpp-147-	{
./wp/impexp/xp/ie_imp_XML.cpp-148-		size_t len = _readBytes(buf, sizeof(buf));
./wp/impexp/xp/ie_imp_XML.cpp-149-		done = (len < sizeof(buf));
./wp/impexp/xp/ie_imp_XML.cpp-150-
./wp/impexp/xp/ie_imp_XML.cpp-151-#if 1
./wp/impexp/xp/ie_imp_XML.cpp:152:        // TODO - remove this then not needed anymore. In ver 0.7.7 and erlier, AbiWord export inserted 
./wp/impexp/xp/ie_imp_XML.cpp-153-        // chars below 0x20. Most of these are invalid XML and can't be imported.
./wp/impexp/xp/ie_imp_XML.cpp-154-        // See bug #762.
./wp/impexp/xp/ie_imp_XML.cpp-155-        for( UT_uint32 n1 = 0; n1 < len; n1++ )
./wp/impexp/xp/ie_imp_XML.cpp-156-	        if( buf[n1] >= 0x00 && buf[n1] < 0x20 && buf[n1] != 0x09 && buf[n1] != 0x0a && buf[n1] != 0x0d )
./wp/impexp/xp/ie_imp_XML.cpp-157-		        buf[n1] = 0x0d;
./wp/impexp/xp/ie_imp_XML.cpp-214-/*****************************************************************/
./wp/impexp/xp/ie_imp_XML.cpp-215-/*****************************************************************/
./wp/impexp/xp/ie_imp_XML.cpp-216-
./wp/impexp/xp/ie_imp_XML.cpp-217-void IE_Imp_XML::_charData(const XML_Char *s, int len)
./wp/impexp/xp/ie_imp_XML.cpp-218-{
./wp/impexp/xp/ie_imp_XML.cpp:219:	// TODO XML_Char is defined in the xml parser
./wp/impexp/xp/ie_imp_XML.cpp:220:	// TODO as a 'char' not as a 'unsigned char'.
./wp/impexp/xp/ie_imp_XML.cpp:221:	// TODO does this cause any problems ??
./wp/impexp/xp/ie_imp_XML.cpp-222-	
./wp/impexp/xp/ie_imp_XML.cpp-223-	X_EatIfAlreadyError();				// xml parser keeps running until buffer consumed
./wp/impexp/xp/ie_imp_XML.cpp-224-
./wp/impexp/xp/ie_imp_XML.cpp-225-	switch (m_parseState)
./wp/impexp/xp/ie_imp_XML.cpp-226-	{
./ask/gendata/xp/ask_gendata.c-340-		
./ask/gendata/xp/ask_gendata.c-341-		fprintf(fpOut, "\n");
./ask/gendata/xp/ask_gendata.c-342-
./ask/gendata/xp/ask_gendata.c-343-		{
./ask/gendata/xp/ask_gendata.c-344-			struct data_file_list_node* pNode = calloc(1, sizeof(struct data_file_list_node));
./ask/gendata/xp/ask_gendata.c:345:			/* TODO outofmem */
./ask/gendata/xp/ask_gendata.c-346-			pNode->iNum = iDataFileNum;
./ask/gendata/xp/ask_gendata.c-347-			pNode->pNext = pCurrentSet->pHead;
./ask/gendata/xp/ask_gendata.c-348-			pCurrentSet->pHead = pNode;
./ask/gendata/xp/ask_gendata.c-349-		}
./ask/gendata/xp/ask_gendata.c-350-
./ask/gendata/xp/ask_gendata.c-531-	
./ask/gendata/xp/ask_gendata.c-532-	fprintf(fpOut, "\n");
./ask/gendata/xp/ask_gendata.c-533-	
./ask/gendata/xp/ask_gendata.c-534-	fclose(fpOut);
./ask/gendata/xp/ask_gendata.c-535-
./ask/gendata/xp/ask_gendata.c:536:	/* TODO free the linked lists */
./ask/gendata/xp/ask_gendata.c-537-	
./ask/gendata/xp/ask_gendata.c-538-	return 0;
./ask/gendata/xp/ask_gendata.c-539-}
./ask/lib/xp/ask_lib.c-24-#include <zlib.h>
./ask/lib/xp/ask_lib.c-25-
./ask/lib/xp/ask_lib.c-26-#include "ask.h"
./ask/lib/xp/ask_lib.c-27-
./ask/lib/xp/ask_lib.c-28-/*
./ask/lib/xp/ask_lib.c:29:  TODO get rid of the following
./ask/lib/xp/ask_lib.c-30-*/
./ask/lib/xp/ask_lib.c-31-
./ask/lib/xp/ask_lib.c-32-#define CHECK_ERR(err, msg) { \
./ask/lib/xp/ask_lib.c-33-    if (err != Z_OK) { \
./ask/lib/xp/ask_lib.c-34-        fprintf(stderr, "%s error: %d\n", msg, err); \
./af/ev/xp/ev_EditEventMapper.h-103-**   We now support mouse events for button-up-motion events.
./af/ev/xp/ev_EditEventMapper.h-104-**   (These are primarily used for context cursors.)
./af/ev/xp/ev_EditEventMapper.h-105-**
./af/ev/xp/ev_EditEventMapper.h-106-**   We now suport the notion of mouse contexts.
./af/ev/xp/ev_EditEventMapper.h-107-**
./af/ev/xp/ev_EditEventMapper.h:108:**   TODO Question: If another event (keystroke, mouse click)
./af/ev/xp/ev_EditEventMapper.h:109:**   TODO           occurs during a drag, do we:
./af/ev/xp/ev_EditEventMapper.h:110:**   TODO           (1) end the drag with or without issuing an
./af/ev/xp/ev_EditEventMapper.h:111:**   TODO           implicit release and then process the new
./af/ev/xp/ev_EditEventMapper.h:112:**   TODO           event (and ignore the eventual actual 
./af/ev/xp/ev_EditEventMapper.h:113:**   TODO           release), or
./af/ev/xp/ev_EditEventMapper.h:114:**   TODO           (2) ignore the new event and keep the
./af/ev/xp/ev_EditEventMapper.h:115:**   TODO           drag active until the actual release, or
./af/ev/xp/ev_EditEventMapper.h:116:**   TODO           (3) ??
./af/ev/xp/ev_EditEventMapper.h-117-**
./af/ev/xp/ev_EditEventMapper.h-118-**
./af/ev/xp/ev_EditEventMapper.h:119:** TODO Question: Should Menus and Toolbars recognize keyboard
./af/ev/xp/ev_EditEventMapper.h:120:** TODO           modifiers (control, shift, etc) like keystroke
./af/ev/xp/ev_EditEventMapper.h:121:** TODO           and mouse events ??
./af/ev/xp/ev_EditEventMapper.h-122-**
./af/ev/xp/ev_EditEventMapper.h:123:** TODO Question: Should we distinguish between left- and right-versions
./af/ev/xp/ev_EditEventMapper.h:124:** TODO           of SHFIT, CONTROL, ALT, etc ??
./af/ev/xp/ev_EditEventMapper.h-125-**
./af/ev/xp/ev_EditEventMapper.h-126-******************************************************************
./af/ev/xp/ev_EditEventMapper.h-127-*****************************************************************/
./af/ev/xp/ev_EditEventMapper.h-128-
./af/ev/xp/ev_EditEventMapper.h-129-#include "ut_types.h"
./af/ev/xp/ev_Menu_Actions.h-45-class XAP_Frame;
./af/ev/xp/ev_Menu_Actions.h-46-class AV_View;
./af/ev/xp/ev_Menu_Actions.h-47-class EV_Menu_Label;
./af/ev/xp/ev_Menu_Actions.h-48-
./af/ev/xp/ev_Menu_Actions.h-49-
./af/ev/xp/ev_Menu_Actions.h:50:// TODO consider removing bHoldsSubMenu bit from this file.
./af/ev/xp/ev_Menu_Actions.h-51-
./af/ev/xp/ev_Menu_Actions.h-52-/*****************************************************************/
./af/ev/xp/ev_Menu_Actions.h-53-
./af/ev/xp/ev_Menu_Actions.h-54-typedef enum _ev_Menu_ItemState			/* values may be ORed */
./af/ev/xp/ev_Menu_Actions.h-55-{
./af/ev/xp/ev_Menu_Actions.h-62-
./af/ev/xp/ev_Menu_Actions.h-63-typedef EV_Menu_ItemState ( EV_GetMenuItemState_Fn )(AV_View * pView, XAP_Menu_Id id);
./af/ev/xp/ev_Menu_Actions.h-64-typedef EV_Menu_ItemState (*EV_GetMenuItemState_pFn)(AV_View * pView, XAP_Menu_Id id);
./af/ev/xp/ev_Menu_Actions.h-65-#define Defun_EV_GetMenuItemState_Fn(fn) EV_Menu_ItemState fn(AV_View * pAV_View, XAP_Menu_Id id)
./af/ev/xp/ev_Menu_Actions.h-66-
./af/ev/xp/ev_Menu_Actions.h:67:// TODO decide if ...GetMenuItemComputedLabel... should take an XAP_App or an AV_View.
./af/ev/xp/ev_Menu_Actions.h:68:// TODO for most-recently-used-file-list and window-history, we probably just need
./af/ev/xp/ev_Menu_Actions.h:69:// TODO the ap.  but for view-specific things (like toggles where we change the menu
./af/ev/xp/ev_Menu_Actions.h:70:// TODO item name rather than doing a checkmark), we need the view.
./af/ev/xp/ev_Menu_Actions.h-71-
./af/ev/xp/ev_Menu_Actions.h-72-// for now, current (quick) compromise is to pass the XAP_Frame, 
./af/ev/xp/ev_Menu_Actions.h-73-// because you can get to either of them easily from there -- pcr
./af/ev/xp/ev_Menu_Actions.h-74-
./af/ev/xp/ev_Menu_Actions.h-75-typedef const char * ( EV_GetMenuItemComputedLabel_Fn )(XAP_Frame * pFrame, const EV_Menu_Label * pLabel, XAP_Menu_Id id);
./af/ev/xp/ev_Menu_Labels.h-35-** We create one EV_Menu_LabelSet per language per application.
./af/ev/xp/ev_Menu_Labels.h-36-**
./af/ev/xp/ev_Menu_Labels.h-37-******************************************************************
./af/ev/xp/ev_Menu_Labels.h-38-*****************************************************************/
./af/ev/xp/ev_Menu_Labels.h-39-
./af/ev/xp/ev_Menu_Labels.h:40:// TODO decide if we should make all labels Unicode
./af/ev/xp/ev_Menu_Labels.h-41-
./af/ev/xp/ev_Menu_Labels.h-42-class EV_Menu_Label
./af/ev/xp/ev_Menu_Labels.h-43-{
./af/ev/xp/ev_Menu_Labels.h-44-public:
./af/ev/xp/ev_Menu_Labels.h-45-	EV_Menu_Label(XAP_Menu_Id id,
./af/ev/xp/ev_Toolbar_Labels.h-35-** We create one EV_Toolbar_LabelSet per language per application.
./af/ev/xp/ev_Toolbar_Labels.h-36-**
./af/ev/xp/ev_Toolbar_Labels.h-37-******************************************************************
./af/ev/xp/ev_Toolbar_Labels.h-38-*****************************************************************/
./af/ev/xp/ev_Toolbar_Labels.h-39-
./af/ev/xp/ev_Toolbar_Labels.h:40:// TODO decide if we should make all labels Unicode
./af/ev/xp/ev_Toolbar_Labels.h-41-
./af/ev/xp/ev_Toolbar_Labels.h-42-class EV_Toolbar_Label
./af/ev/xp/ev_Toolbar_Labels.h-43-{
./af/ev/xp/ev_Toolbar_Labels.h-44-public:
./af/ev/xp/ev_Toolbar_Labels.h-45-	EV_Toolbar_Label(XAP_Toolbar_Id id,
./af/util/xp/ut_assert.h-18- */
./af/util/xp/ut_assert.h-19- 
./af/util/xp/ut_assert.h-20-#ifndef UT_ASSERT_H
./af/util/xp/ut_assert.h-21-#define UT_ASSERT_H
./af/util/xp/ut_assert.h-22-
./af/util/xp/ut_assert.h:23:// TODO move these declarations into platform directories.
./af/util/xp/ut_assert.h-24-
./af/util/xp/ut_assert.h-25-#ifdef WIN32
./af/util/xp/ut_assert.h-26-
./af/util/xp/ut_assert.h-27-// Win32 assert() is cool, so we use it as is.
./af/util/xp/ut_assert.h-28-#if !defined(_MSC_VER)
./af/util/xp/ut_assert.h-133-#endif
./af/util/xp/ut_assert.h-134-
./af/util/xp/ut_assert.h-135-
./af/util/xp/ut_assert.h-136-#define UT_NOT_IMPLEMENTED		0
./af/util/xp/ut_assert.h-137-#define UT_SHOULD_NOT_HAPPEN	0
./af/util/xp/ut_assert.h:138:#define UT_TODO					0
./af/util/xp/ut_assert.h-139-
./af/util/xp/ut_assert.h-140-#endif /* UT_ASSERT_H */
./af/util/xp/ut_string.h-98-XML_Char * UT_decodeXMLstring(XML_Char *pcIn);
./af/util/xp/ut_string.h-99-
./af/util/xp/ut_string.h-100-UT_Bool UT_isSmartQuotableCharacter(UT_UCSChar c);
./af/util/xp/ut_string.h-101-UT_Bool UT_isSmartQuotedCharacter(UT_UCSChar c);
./af/util/xp/ut_string.h-102-
./af/util/xp/ut_string.h:103:#define UT_UCS_isdigit(x)	(((x) >= '0') && ((x) <= '9'))  // TODO: make UNICODE-wise
./af/util/xp/ut_string.h-104-#if 0
./af/util/xp/ut_string.h-105-#define UT_UCS_isupper(x)	(((x) >= 'A') && ((x) <= 'Z'))		// HACK: not UNICODE-safe
./af/util/xp/ut_string.h-106-#define UT_UCS_islower(x)	(((x) >= 'a') && ((x) <= 'z'))		// HACK: not UNICODE-safe
./af/util/xp/ut_string.h-107-#define UT_UCS_isalpha(x)	(UT_UCS_isupper(x) || UT_UCS_islower(x))		// HACK: not UNICODE-safe
./af/util/xp/ut_string.h-108-#else
./af/util/xp/ut_types.h-52-typedef		unsigned int		UT_uint32;
./af/util/xp/ut_types.h-53-typedef		signed int			UT_sint32;
./af/util/xp/ut_types.h-54-
./af/util/xp/ut_types.h-55-
./af/util/xp/ut_types.h-56-/*
./af/util/xp/ut_types.h:57:	TODO we currently use plain old C 'int' all over the place.
./af/util/xp/ut_types.h-58-	For many applications, this is inappropriate, and we should change
./af/util/xp/ut_types.h-59-	them to UT_sint32.  Also, there are places where we are
./af/util/xp/ut_types.h-60-	using it as a bool, and there are places where we are using it as
./af/util/xp/ut_types.h-61-	an error code.
./af/util/xp/ut_types.h-62-*/
./af/xap/xp/xad_Document.h-19-
./af/xap/xp/xad_Document.h-20-
./af/xap/xp/xad_Document.h-21-#ifndef AD_DOCUMENT_H
./af/xap/xp/xad_Document.h-22-#define AD_DOCUMENT_H
./af/xap/xp/xad_Document.h-23-
./af/xap/xp/xad_Document.h:24:// TODO should the filename be UT_UCSChar rather than char ?
./af/xap/xp/xad_Document.h-25-
./af/xap/xp/xad_Document.h-26-#include "ut_types.h"
./af/xap/xp/xad_Document.h-27-
./af/xap/xp/xad_Document.h-28-// fwd. decl.
./af/xap/xp/xad_Document.h-29-class UT_AlphaHashTable;
./af/xap/xp/xad_Document.h-36-	void				ref(void);
./af/xap/xp/xad_Document.h-37-	void				unref(void);
./af/xap/xp/xad_Document.h-38-
./af/xap/xp/xad_Document.h-39-	const char *			getFilename(void) const;
./af/xap/xp/xad_Document.h-40-	virtual UT_uint32               getLastType() = 0; 
./af/xap/xp/xad_Document.h:41:	// TODO - this should be returning IEFileType, 
./af/xap/xp/xad_Document.h-42-	// but that's AP stuff, so it's not here
./af/xap/xp/xad_Document.h-43-
./af/xap/xp/xad_Document.h-44-	virtual UT_Error   		readFromFile(const char * szFilename, int ieft) = 0;
./af/xap/xp/xad_Document.h-45-	virtual UT_Error		newDocument(void) = 0;
./af/xap/xp/xad_Document.h-46-	virtual UT_Bool			isDirty(void) const = 0;
./af/xap/xp/xap_App.h-53-******************************************************************
./af/xap/xp/xap_App.h-54-*****************************************************************/
./af/xap/xp/xap_App.h-55-
./af/xap/xp/xap_App.h-56-class XAP_App
./af/xap/xp/xap_App.h-57-{
./af/xap/xp/xap_App.h:58:public:									/* TODO these should be protected */
./af/xap/xp/xap_App.h-59-	static const char* s_szBuild_ID;
./af/xap/xp/xap_App.h-60-	static const char* s_szBuild_Version;
./af/xap/xp/xap_App.h-61-	static const char* s_szBuild_Options;
./af/xap/xp/xap_App.h-62-	static const char* s_szBuild_Target;
./af/xap/xp/xap_App.h-63-	static const char* s_szBuild_CompileTime;
./af/xap/xp/xap_Frame.h-184-	XAP_InputModes *			m_pInputModes;
./af/xap/xp/xap_Frame.h-185-	
./af/xap/xp/xap_Frame.h-186-	static int					_getNextUntitledNumber(void);
./af/xap/xp/xap_Frame.h-187-	
./af/xap/xp/xap_Frame.h-188-private:
./af/xap/xp/xap_Frame.h:189:	char						m_szTitle[512];				/* TODO need #define for this number */
./af/xap/xp/xap_Frame.h:190:	char						m_szNonDecoratedTitle[512]; /* TODO need #define for this number */
./af/xap/xp/xap_Frame.h-191-	
./af/xap/xp/xap_Frame.h-192-	static int					s_iUntitled;	
./af/xap/xp/xap_Frame.h-193-};
./af/xap/xp/xap_Frame.h-194-
./af/xap/xp/xap_Frame.h-195-#endif /* XAP_Frame_H */
./af/xap/xp/xap_Preview.h-50-	virtual void			onLeftButtonDown(UT_sint32 x, UT_sint32 y) {  };
./af/xap/xp/xap_Preview.h-51-
./af/xap/xp/xap_Preview.h-52-	
./af/xap/xp/xap_Preview.h-53-protected:
./af/xap/xp/xap_Preview.h-54-
./af/xap/xp/xap_Preview.h:55:	// TODO : 
./af/xap/xp/xap_Preview.h-56-	// later we might add some useful high-level macro-like drawing functions
./af/xap/xp/xap_Preview.h-57-	// for previews, like drawing page boundaries, etc.
./af/xap/xp/xap_Preview.h-58-	
./af/xap/xp/xap_Preview.h-59-	UT_sint32			m_iWindowHeight;
./af/xap/xp/xap_Preview.h-60-	UT_sint32			m_iWindowWidth;
./af/xap/xp/xap_ViewListener.h-31-/*
./af/xap/xp/xap_ViewListener.h-32-	The ap_ViewListener class handles UI change notifications from an AV_View
./af/xap/xp/xap_ViewListener.h-33-	to its associated XAP_Frame.  
./af/xap/xp/xap_ViewListener.h-34-*/
./af/xap/xp/xap_ViewListener.h-35-
./af/xap/xp/xap_ViewListener.h:36:// TODO shouldn't this class be xap_ ??
./af/xap/xp/xap_ViewListener.h-37-
./af/xap/xp/xap_ViewListener.h-38-class ap_ViewListener : public AV_Listener
./af/xap/xp/xap_ViewListener.h-39-{
./af/xap/xp/xap_ViewListener.h-40-public:
./af/xap/xp/xap_ViewListener.h-41-	ap_ViewListener(XAP_Frame* pFrame);
./af/xap/xp/xav_View.h-26-#include "ut_vector.h"
./af/xap/xp/xav_View.h-27-#include "xav_Listener.h"
./af/xap/xp/xav_View.h-28-#include "ev_EditBits.h"
./af/xap/xp/xav_View.h-29-class XAP_App;
./af/xap/xp/xav_View.h-30-
./af/xap/xp/xav_View.h:31:// TODO shouldn't these classes be xav_ prefixed ??
./af/xap/xp/xav_View.h-32-
./af/xap/xp/xav_View.h-33-enum AV_Focus
./af/xap/xp/xav_View.h-34-{
./af/xap/xp/xav_View.h-35-	AV_FOCUS_HERE,
./af/xap/xp/xav_View.h-36-	AV_FOCUS_NEARBY,
./ask/lib/xp/ask.h-37-	unsigned int	iModTime;
./ask/lib/xp/ask.h-38-	int				bNoCopy;
./ask/lib/xp/ask.h-39-	int				bNoRemove;
./ask/lib/xp/ask.h-40-	int				bNoCompress;
./ask/lib/xp/ask.h-41-	
./ask/lib/xp/ask.h:42:	/* TODO bKeywords, hash */
./ask/lib/xp/ask.h-43-	
./ask/lib/xp/ask.h-44-	char			szInstallPath[ASK_MAX_PATH+1];
./ask/lib/xp/ask.h-45-} ASK_DataFile;
./ask/lib/xp/ask.h-46-
./ask/lib/xp/ask.h-47-extern ASK_DataFile*	g_aDataFiles[];
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-27-
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-28-// We use the Win32 '&' character to denote a keyboard accelerator on a menu item.
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-29-// If your platform doesn't have a way to do accelerators or uses a different
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-30-// character, remove or change the '&' in your menu constructor code.
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-31-
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h:32:// TODO decide if we want menu items to have ToolTips ??
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-33-
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-34-BeginSet(EnUS)
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-35-
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-36-	MenuLabel(AP_MENU_ID__BOGUS1__,			NULL,				NULL)
./hello/ap/xp/ap_Menu_LabelSet_EnUS.h-37-
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-24-** MORE THAN ONE TIME.
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-25-******************************************************************
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-26-*****************************************************************/
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-27-
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-28-// Include each language file that we want in the build.
./hello/ap/xp/ap_Menu_LabelSet_Languages.h:29:// TODO decide if we want to ifdef these...
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-30-
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-31-#include "ap_Menu_LabelSet_EnUS.h"
./hello/ap/xp/ap_Menu_LabelSet_Languages.h-32-
./hello/ap/xp/ap_Prefs_SchemeIds.h-40-
./hello/ap/xp/ap_Prefs_SchemeIds.h-41-#define AP_PREF_KEY_StringSet						"StringSet"
./hello/ap/xp/ap_Prefs_SchemeIds.h-42-#define AP_PREF_DEFAULT_StringSet					"EnUS"						/* name of dialog/msgbox strings */
./hello/ap/xp/ap_Prefs_SchemeIds.h-43-
./hello/ap/xp/ap_Prefs_SchemeIds.h-44-#define AP_PREF_KEY_UnixStringSetDirectory			"UnixStringSetDirectory"
./hello/ap/xp/ap_Prefs_SchemeIds.h:45:#define AP_PREF_DEFAULT_UnixStringSetDirectory		"/usr/local/AbiSuite/AbiWord/lib"	/* where we find StringSets */ /* TODO DECIDE WHERE THIS SHOULD BE */
./hello/ap/xp/ap_Prefs_SchemeIds.h-46-
./hello/ap/xp/ap_Prefs_SchemeIds.h-47-#define AP_PREF_KEY_WinStringSetDirectory			"WinStringSetDirectory"
./hello/ap/xp/ap_Prefs_SchemeIds.h:48:#define AP_PREF_DEFAULT_WinStringSetDirectory		"C:\\"				/* where we find StringSets */ /* TODO DECIDE WHERE THIS SHOULD BE */
./hello/ap/xp/ap_Prefs_SchemeIds.h-49-
./hello/ap/xp/ap_Prefs_SchemeIds.h-50-#define AP_PREF_KEY_KeyBindings                                         "KeyBindings"
./hello/ap/xp/ap_Prefs_SchemeIds.h-51-#define AP_PREF_DEFAULT_KeyBindings                                     "default"           /* value in ap_LoadBindings.cpp */
./hello/ap/xp/ap_Prefs_SchemeIds.h-52-
./hello/ap/xp/ap_Prefs_SchemeIds.h-53-#define AP_PREF_KEY_MenuLayout                                          "MenuLayouts"
./hello/ap/xp/ap_TB_LabelSet_Languages.h-24-** MORE THAN ONE TIME.
./hello/ap/xp/ap_TB_LabelSet_Languages.h-25-******************************************************************
./hello/ap/xp/ap_TB_LabelSet_Languages.h-26-*****************************************************************/
./hello/ap/xp/ap_TB_LabelSet_Languages.h-27-
./hello/ap/xp/ap_TB_LabelSet_Languages.h-28-// Include each language file that we want in the build.
./hello/ap/xp/ap_TB_LabelSet_Languages.h:29:// TODO decide if we want to ifdef these...
./hello/ap/xp/ap_TB_LabelSet_Languages.h-30-
./hello/ap/xp/ap_TB_LabelSet_Languages.h-31-#include "ap_TB_LabelSet_EnUS.h"
./hello/ap/xp/ap_TB_LabelSet_Languages.h-32-
./text/fmt/xp/fl_BlockLayout.h-144-
./text/fmt/xp/fl_BlockLayout.h-145-class fl_BlockLayout : public fl_Layout
./text/fmt/xp/fl_BlockLayout.h-146-{
./text/fmt/xp/fl_BlockLayout.h-147-	friend class fl_DocListener;
./text/fmt/xp/fl_BlockLayout.h-148-
./text/fmt/xp/fl_BlockLayout.h:149:	// TODO: shack - code should be moved from toggleAuto to a function in
./text/fmt/xp/fl_BlockLayout.h-150-	// here - to handle the squiggles
./text/fmt/xp/fl_BlockLayout.h-151-	friend void FL_DocLayout::_toggleAutoSpell(UT_Bool bSpell);
./text/fmt/xp/fl_BlockLayout.h-152-
./text/fmt/xp/fl_BlockLayout.h-153-public:
./text/fmt/xp/fl_BlockLayout.h-154-	fl_BlockLayout(PL_StruxDocHandle sdh, fb_LineBreaker*, fl_BlockLayout*, fl_SectionLayout*, PT_AttrPropIndex indexAP);
./text/fmt/xp/fl_BlockLayout.h-167-	void		redrawUpdate();
./text/fmt/xp/fl_BlockLayout.h-168-
./text/fmt/xp/fl_BlockLayout.h-169-	fp_Line*	getNewLine(void);
./text/fmt/xp/fl_BlockLayout.h-170-	FV_View *       getView(void);
./text/fmt/xp/fl_BlockLayout.h-171-
./text/fmt/xp/fl_BlockLayout.h:172:// TODO: What I want to test is XML_Char != char
./text/fmt/xp/fl_BlockLayout.h-173-#ifdef HAVE_LIBXML2
./text/fmt/xp/fl_BlockLayout.h-174-	const char*	getProperty(const char * pszName, UT_Bool bExpandStyles = UT_TRUE) const;
./text/fmt/xp/fl_BlockLayout.h-175-#endif
./text/fmt/xp/fl_BlockLayout.h-176-	const char*	getProperty(const XML_Char * pszName, UT_Bool bExpandStyles = UT_TRUE) const;
./text/fmt/xp/fl_BlockLayout.h-177-	void setAlignment(UT_uint32 iAlignCmd);
./text/fmt/xp/fl_SectionLayout.h-199-
./text/fmt/xp/fl_SectionLayout.h-200-protected:
./text/fmt/xp/fl_SectionLayout.h-201-	virtual void		_lookupProperties(void);
./text/fmt/xp/fl_SectionLayout.h-202-
./text/fmt/xp/fl_SectionLayout.h-203-	/*
./text/fmt/xp/fl_SectionLayout.h:204:	  TODO support special case header/footer for first page of section
./text/fmt/xp/fl_SectionLayout.h-205-	*/
./text/fmt/xp/fl_SectionLayout.h-206-	fl_HdrFtrSectionLayout*		m_pHeaderSL;
./text/fmt/xp/fl_SectionLayout.h-207-	fl_HdrFtrSectionLayout*		m_pFooterSL;
./text/fmt/xp/fl_SectionLayout.h-208-	
./text/fmt/xp/fl_SectionLayout.h-209-	UT_uint32			m_iNumColumns;
./text/fmt/xp/fp_Run.h-50-	UT_sint32 iLeftWidth;
./text/fmt/xp/fp_Run.h-51-	UT_sint32 iRightWidth;
./text/fmt/xp/fp_Run.h-52-	UT_sint32 iOffset;
./text/fmt/xp/fp_Run.h-53-};
./text/fmt/xp/fp_Run.h-54-
./text/fmt/xp/fp_Run.h:55:// TODO The break type is not used. Is it put here looking forward,
./text/fmt/xp/fp_Run.h:56:// TODO or is it left from some earlier experiments?
./text/fmt/xp/fp_Run.h-57-enum FP_RUN_BREAK_TYPE
./text/fmt/xp/fp_Run.h-58-{
./text/fmt/xp/fp_Run.h-59-	BREAK_AUTO			= 0,
./text/fmt/xp/fp_Run.h-60-	BREAK_AVOID			= 1,
./text/fmt/xp/fp_Run.h-61-	BREAK_ALWAYS		= 2
./text/fmt/xp/fp_Run.h-62-};
./text/fmt/xp/fp_Run.h-63-
./text/fmt/xp/fp_Run.h:64:// TODO 
./text/fmt/xp/fp_Run.h-65-enum FP_RUN_RELATIVE_POINT_POSITION
./text/fmt/xp/fp_Run.h-66-{
./text/fmt/xp/fp_Run.h-67-	FP_RUN_INSIDE      	= 1,
./text/fmt/xp/fp_Run.h-68-	FP_RUN_NOT         	= 2
./text/fmt/xp/fp_Run.h-69-};
./text/fmt/xp/fp_TextRun.h-150-	  This makes the assumption that all characters in a given run
./text/fmt/xp/fp_TextRun.h-151-	  can be obtained from the same font.  This may not be true.
./text/fmt/xp/fp_TextRun.h-152-	  For example, suppose that a run includes a mixture of latin
./text/fmt/xp/fp_TextRun.h-153-	  and non-latin characters.  The resulting glyphs will probably need to be
./text/fmt/xp/fp_TextRun.h-154-	  retrieved from multiple fonts.
./text/fmt/xp/fp_TextRun.h:155:	  TODO fix this issue
./text/fmt/xp/fp_TextRun.h-156-	*/
./text/fmt/xp/fp_TextRun.h-157-	GR_Font*				m_pFont;
./text/fmt/xp/fp_TextRun.h-158-	GR_Font*				m_pFontLayout;
./text/fmt/xp/fp_TextRun.h-159-	UT_RGBColor				m_colorFG;
./text/fmt/xp/fp_TextRun.h-160-	UT_Bool					m_bSquiggled;
./text/fmt/xp/fv_View.h-148-	fp_Page*		getCurrentPage(void) const;
./text/fmt/xp/fv_View.h-149-	fl_BlockLayout*	getCurrentBlock(void);
./text/fmt/xp/fv_View.h-150-
./text/fmt/xp/fv_View.h-151-	void draw(int page, dg_DrawArgs* da);
./text/fmt/xp/fv_View.h-152-
./text/fmt/xp/fv_View.h:153:	// TODO some of these functions should move into protected
./text/fmt/xp/fv_View.h-154-	
./text/fmt/xp/fv_View.h-155-	void	getPageScreenOffsets(fp_Page* pPage, UT_sint32& xoff, UT_sint32& yoff);
./text/fmt/xp/fv_View.h-156-	void	getPageYOffset(fp_Page* pPage, UT_sint32& yoff);
./text/fmt/xp/fv_View.h-157-	virtual	UT_uint32 getPageViewLeftMargin(void) const;
./text/fmt/xp/fv_View.h-158-	virtual	UT_uint32 getPageViewTopMargin(void) const;
./text/ptbl/xp/pd_Document.h-19-
./text/ptbl/xp/pd_Document.h-20-
./text/ptbl/xp/pd_Document.h-21-#ifndef PD_DOCUMENT_H
./text/ptbl/xp/pd_Document.h-22-#define PD_DOCUMENT_H
./text/ptbl/xp/pd_Document.h-23-
./text/ptbl/xp/pd_Document.h:24:// TODO should the filename be UT_UCSChar rather than char ?
./text/ptbl/xp/pd_Document.h-25-
./text/ptbl/xp/pd_Document.h-26-#include <stdio.h>
./text/ptbl/xp/pd_Document.h-27-#include "ut_types.h"
./text/ptbl/xp/pd_Document.h-28-#include "ut_vector.h"
./text/ptbl/xp/pd_Document.h-29-#include "ut_alphahash.h"
./wp/ap/xp/ap_Dialog_Goto.h-30-
./wp/ap/xp/ap_Dialog_Goto.h-31-typedef enum _AP_JumpTarget
./wp/ap/xp/ap_Dialog_Goto.h-32-{
./wp/ap/xp/ap_Dialog_Goto.h-33-	AP_JUMPTARGET_PAGE,				// beginning of page
./wp/ap/xp/ap_Dialog_Goto.h-34-	AP_JUMPTARGET_LINE,
./wp/ap/xp/ap_Dialog_Goto.h:35:	AP_JUMPTARGET_PICTURE // TODO
./wp/ap/xp/ap_Dialog_Goto.h-36-} AP_JumpTarget;
./wp/ap/xp/ap_Dialog_Goto.h-37-		
./wp/ap/xp/ap_Dialog_Goto.h-38-class AP_Dialog_Goto : public XAP_Dialog_Modeless
./wp/ap/xp/ap_Dialog_Goto.h-39-{
./wp/ap/xp/ap_Dialog_Goto.h-40-public:
./wp/ap/xp/ap_Dialog_Goto.h-54-	// instance of the dialog.  These do not read the persistent
./wp/ap/xp/ap_Dialog_Goto.h-55-	// values.
./wp/ap/xp/ap_Dialog_Goto.h-56-  	UT_Bool						setView(FV_View * view);
./wp/ap/xp/ap_Dialog_Goto.h-57-  	FV_View * 					getView(void);
./wp/ap/xp/ap_Dialog_Goto.h-58-	void                                            setActiveFrame(XAP_Frame *pFrame);
./wp/ap/xp/ap_Dialog_Goto.h:59:	static char **              getJumpTargets(void); // TODO: Change to UT_UCSChar
./wp/ap/xp/ap_Dialog_Goto.h-60- protected:
./wp/ap/xp/ap_Dialog_Goto.h-61-	
./wp/ap/xp/ap_Dialog_Goto.h-62-	// These are the "current use" dialog data items,
./wp/ap/xp/ap_Dialog_Goto.h-63-	// which are liberally read and set by the
./wp/ap/xp/ap_Dialog_Goto.h-64-	// accessor methods above.
./wp/ap/xp/ap_FrameData.h-47-	FL_DocLayout *		m_pDocLayout;
./wp/ap/xp/ap_FrameData.h-48-	GR_Graphics *		m_pG;
./wp/ap/xp/ap_FrameData.h-49-
./wp/ap/xp/ap_FrameData.h-50-	UT_Bool				m_bInsertMode;
./wp/ap/xp/ap_FrameData.h-51-	UT_Bool				m_bShowRuler;
./wp/ap/xp/ap_FrameData.h:52:	UT_Bool				m_bShowBar[3]; // TODO: 3 = NB_OF_TOOLBARS...
./wp/ap/xp/ap_FrameData.h-53-	UT_Bool				m_bShowStatusBar;
./wp/ap/xp/ap_FrameData.h-54-	UT_Bool             m_bShowPara;
./wp/ap/xp/ap_FrameData.h-55-	AP_TopRuler *		m_pTopRuler;
./wp/ap/xp/ap_FrameData.h-56-	AP_LeftRuler *		m_pLeftRuler;
./wp/ap/xp/ap_FrameData.h:57:	EV_Toolbar *		m_pToolbar[3]; // TODO: 3 = NB_OF_TOOLBARS...
./wp/ap/xp/ap_FrameData.h-58-	AP_StatusBar *		m_pStatusBar;
./wp/ap/xp/ap_FrameData.h-59-};
./wp/ap/xp/ap_FrameData.h-60-
./wp/ap/xp/ap_FrameData.h-61-#endif /* AP_FRAMEDATA_H */
./wp/ap/xp/ap_LeftRuler.h-90-
./wp/ap/xp/ap_LeftRuler.h-91-	// must be static so that I can pass as a functional arg - shack
./wp/ap/xp/ap_LeftRuler.h-92-	static void _prefsListener( XAP_App *pApp, XAP_Prefs *pPrefs, UT_AlphaHashTable *phChanges, void *data );
./wp/ap/xp/ap_LeftRuler.h-93-	
./wp/ap/xp/ap_LeftRuler.h-94-	XAP_Frame *			m_pFrame;
./wp/ap/xp/ap_LeftRuler.h:95:	AV_View *			m_pView;		/* TODO make this a FV_View */
./wp/ap/xp/ap_LeftRuler.h-96-	AV_ScrollObj *		m_pScrollObj;
./wp/ap/xp/ap_LeftRuler.h-97-	GR_Graphics *		m_pG;
./wp/ap/xp/ap_LeftRuler.h-98-	UT_Dimension		m_dim;
./wp/ap/xp/ap_LeftRuler.h-99-	UT_uint32			m_iHeight;		/* size of window */
./wp/ap/xp/ap_LeftRuler.h-100-	UT_uint32			m_iWidth;		/* size of window */
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-24-** MORE THAN ONE TIME.
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-25-******************************************************************
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-26-*****************************************************************/
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-27-
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-28-// Include each language file that we want in the build.
./wp/ap/xp/ap_Menu_LabelSet_Languages.h:29:// TODO decide if we want to ifdef these...
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-30-
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-31-#include "ap_Menu_LabelSet_en-US.h"
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-32-#include "ap_Menu_LabelSet_ca-ES.h"
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-33-#include "ap_Menu_LabelSet_es-ES.h"
./wp/ap/xp/ap_Menu_LabelSet_Languages.h-34-#include "ap_Menu_LabelSet_fi-FI.h"
./wp/ap/xp/ap_TB_LabelSet_Languages.h-24-** MORE THAN ONE TIME.
./wp/ap/xp/ap_TB_LabelSet_Languages.h-25-******************************************************************
./wp/ap/xp/ap_TB_LabelSet_Languages.h-26-*****************************************************************/
./wp/ap/xp/ap_TB_LabelSet_Languages.h-27-
./wp/ap/xp/ap_TB_LabelSet_Languages.h-28-// Include each language file that we want in the build.
./wp/ap/xp/ap_TB_LabelSet_Languages.h:29:// TODO decide if we want to ifdef these...
./wp/ap/xp/ap_TB_LabelSet_Languages.h-30-
./wp/ap/xp/ap_TB_LabelSet_Languages.h-31-#include "ap_TB_LabelSet_en-US.h"
./wp/ap/xp/ap_TB_LabelSet_Languages.h-32-#include "ap_TB_LabelSet_ca-ES.h"
./wp/ap/xp/ap_TB_LabelSet_Languages.h-33-#include "ap_TB_LabelSet_cs-CZ.h"
./wp/ap/xp/ap_TB_LabelSet_Languages.h-34-#include "ap_TB_LabelSet_es-ES.h"
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-48-
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-49-        ToolbarItem(AP_TOOLBAR_ID_UNINDENT)
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-50-        ToolbarItem(AP_TOOLBAR_ID_INDENT)
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-51-
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-52-#if defined(HAVE_GNOME)
./wp/ap/xp/ap_TB_Layouts_FormatOps.h:53:     /* TODO: these should be moved out into the general public */
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-54-     Spacer()
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-55-     ToolbarItem(AP_TOOLBAR_ID_COLOR_BACK)
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-56-     ToolbarItem(AP_TOOLBAR_ID_COLOR_FORE)
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-57-#endif
./wp/ap/xp/ap_TB_Layouts_FormatOps.h-58-	
